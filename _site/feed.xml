<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.0">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2018-06-24T16:42:59+09:00</updated><id>http://localhost:4000/blog/</id><title type="html">윤상준의 기술 블로그</title><subtitle>Software &amp; Cloud Engineer 입니다. Kubernetes, Cloud Foundry등의 PaaS와 Cloud 및 DevOps 관련 기술에 관심이 있습니다.</subtitle><author><name>Yun SangJun</name></author><entry><title type="html">Pod에 타임존 설정하기</title><link href="http://localhost:4000/blog/kubernetes/2018/06/24/setup-timezone-to-pod.html" rel="alternate" type="text/html" title="Pod에 타임존 설정하기" /><published>2018-06-24T00:00:00+09:00</published><updated>2018-06-24T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/06/24/setup-timezone-to-pod</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/06/24/setup-timezone-to-pod.html">&lt;p&gt;이 페이지는 Pod에 타임존을 설정하는 방법에 대해 설명합니다.&lt;/p&gt;

&lt;p&gt;클라우드 환경에서는 기본 타임존이 UTC로 설정되어 있는 경우가 많습니다.&lt;/p&gt;

&lt;p&gt;Kubernetes 클러스터의 경우에도 호스트의 타임존이 UTC로 설정되어 있으면 Pod의 타임존 또한 UTC로 설정됩니다.&lt;/p&gt;

&lt;p&gt;아래의 가이드를 참고하여 특정 Pod의 타임존을 변경할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;준비하기&quot;&gt;준비하기&lt;/h2&gt;

&lt;p&gt;먼저 테스트를 위한 샘플앱을 Kubernetes 클러스터에 배포합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl run nginx --image=nginx --port=80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;현재-타임존-확인&quot;&gt;현재 타임존 확인&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하여 현재 Pod의 타임존을 확인합니다.&lt;/p&gt;

&lt;p&gt;현재 타임존이 UTC로 설정되어 있는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get po
NAME                     READY     STATUS    RESTARTS   AGE
nginx-7587c6fdb6-wl962   1/1       Running   0          11s

$ kubectl exec nginx-7587c6fdb6-wl962 -it -- date
Sun Jun 24 07:30:17 UTC 2018
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod의 로그 또한 UTC 시간을 기준으로 조회되는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl logs -f nginx-7587c6fdb6-wl962
127.0.0.1 - - [24/Jun/2018:07:30:34 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36&quot; &quot;-&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;타임존-변경&quot;&gt;타임존 변경&lt;/h2&gt;

&lt;p&gt;아래와 같이 타임존을 변경하기 위해 deployment 리소스를 편집합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get deploy
NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx     1         1         1            1           2m

$ kubectl edit deploy nginx
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx
spec:
  ...
  template:
    ...
    spec:
      containers:
      ...
        volumeMounts:
        - mountPath: /etc/localtime
          name: timezone-config
      volumes:
      - hostPath:
          path: /usr/share/zoneinfo/Asia/Seoul
        name: timezone-config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;변경된-타임존-확인&quot;&gt;변경된 타임존 확인&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하여 변경된 Pod의 타임존을 확인합니다.&lt;/p&gt;

&lt;p&gt;타임존이 KST로 변경된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get po
NAME                    READY     STATUS    RESTARTS   AGE
nginx-7c8fc894b-m6cw9   1/1       Running   0          1m

$ kubectl exec nginx-7c8fc894b-m6cw9 -it -- date
Sun Jun 24 16:35:31 KST 2018
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod의 로그 또한 KST 시간을 기준으로 조회되는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl logs -f nginx-7c8fc894b-m6cw9
127.0.0.1 - - [24/Jun/2018:16:37:04 +0900] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36&quot; &quot;-&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Pod에 타임존을 설정하는 방법에 대해 설명합니다.</summary></entry><entry><title type="html">Spinnaker 설치하기</title><link href="http://localhost:4000/blog/spinnaker/2018/06/03/installing-spinnaker.html" rel="alternate" type="text/html" title="Spinnaker 설치하기" /><published>2018-06-03T00:00:00+09:00</published><updated>2018-06-03T00:00:00+09:00</updated><id>http://localhost:4000/blog/spinnaker/2018/06/03/installing-spinnaker</id><content type="html" xml:base="http://localhost:4000/blog/spinnaker/2018/06/03/installing-spinnaker.html">&lt;p&gt;이 페이지는 Spinnaker를 설치하는 방법에 대해 설명합니다.
자세한 내용은 &lt;a href=&quot;https://www.spinnaker.io/setup/&quot;&gt;Set up Spinnaker&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;halyard-설치하기&quot;&gt;Halyard 설치하기&lt;/h2&gt;

&lt;p&gt;Halyard는 배포 구성 작성 및 유효성 검사, Spinnaker의 마이크로 서비스 배포 및 업데이트를 포함하여 Spinnaker 배포의 수명주기를 관리합니다.
운영가능한 Spinnaker를 설치 및 업데이트하기 위해 Halyard가 필요합니다. Halyard없이 Spinnaker를 설치할 수는 있지만 권장하지 않습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;&gt;Docker CE&lt;/a&gt;를 설치&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로컬 환경에 Halyard 설정 디렉토리를 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ mkdir ~/.hal
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Halyard Docker 컨테이너 실행&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 Halyard Docker 컨테이너를 생성합니다. 이 명령은 Halyard 설정 및 kubeconfig 디렉토리를 마운트합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ docker run -p 8084:8084 -p 9000:9000 \
     --name halyard --rm \
     -v ~/.hal:/home/spinnaker/.hal \
     -v ~/.kube:/home/spinnaker/.kube \
     -it \
     gcr.io/spinnaker-marketplace/halyard:stable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Halyard에 접속&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 Halyard Docker 컨테이너에 접속합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ docker exec -it halyard bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자동 완성&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 자동완성을 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ source &amp;lt;(hal --print-bash-completion)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hal&lt;/code&gt; 명령어에 대한 자세한 내용은 &lt;a href=&quot;https://www.spinnaker.io/reference/halyard/commands&quot;&gt;Halyard command Reference&lt;/a&gt;를 참고하세요.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cloud-공급자-선택하기&quot;&gt;Cloud 공급자 선택하기&lt;/h2&gt;

&lt;p&gt;Spinnaker를 통해 애플리케이션을 배포할 Cloud 공급자를 선택합니다.&lt;/p&gt;

&lt;p&gt;아래와 같은 Cloud 공급자를 지원합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;App Engine&lt;/li&gt;
  &lt;li&gt;Amazon Web Services&lt;/li&gt;
  &lt;li&gt;Amazon Web Services - ECS&lt;/li&gt;
  &lt;li&gt;Azure&lt;/li&gt;
  &lt;li&gt;DC/OS&lt;/li&gt;
  &lt;li&gt;Google Compute Engine&lt;/li&gt;
  &lt;li&gt;Kubernetes (legacy)&lt;/li&gt;
  &lt;li&gt;Kubernetes V2 (manifest based)&lt;/li&gt;
  &lt;li&gt;Openstack&lt;/li&gt;
  &lt;li&gt;Oracle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 페이지에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Kubernetes V2&lt;/code&gt;를 선택해 Spinnaker를 설치해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;kubernetes-v2-공급자&quot;&gt;Kubernetes V2 공급자&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Kubernetes V2&lt;/code&gt;는 Spinnaker 1.6의 알파 기능을 포함하고 있으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Kubernetes (legacy)&lt;/code&gt;에 비해 불안정할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;계정&quot;&gt;계정&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Kubernetes V2&lt;/code&gt;의 경우 Spinnaker 계정이 Kubernetes Cluster에 대해 인증 할 수 있는 자격 증명에 매핑됩니다. V1 공급자와 달리 V2에서는 Docker Registry Accounts가 필요하지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h4&gt;

&lt;p&gt;아래 두 가지 사항이 필요합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;kubeconfig&lt;/p&gt;

    &lt;p&gt;kubeconfig를 사용하면 Spinnaker가 관리 할 것으로 예상되는 모든 리소스에 대한 읽기/쓰기 권한을 가질 수 있습니다. Kubernetes 클러스터 관리자에게 요청할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;이 페이지에서는 Docker 컨테이너에서 Halyard를 실행시 로컬환경의 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.kube&lt;/code&gt; 폴더를 Docker 컨테이너의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/home/spinnaker/.kube&lt;/code&gt;에 mount 했습니다.
  로컬환경의 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.kube&lt;/code&gt; 폴더 하위에 kubeconfig를 생성하면됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kubectl&lt;/p&gt;

    &lt;p&gt;Spinnaker는 kubectl을 사용하여 모든 API 액세스를 관리합니다. Spinnaker와 함께 설치됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;계정-추가&quot;&gt;계정 추가&lt;/h4&gt;

&lt;p&gt;이제 계정을 추가합니다. 먼저, 공급자가 활성화 되어 있는지 확인합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal config provider kubernetes enable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 계정을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal config provider kubernetes account add my-k8s-v2-account \
    --provider-version v2 \
    --context $(kubectl config current-context)

$ hal config features edit --artifacts true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;추가-설정&quot;&gt;추가 설정&lt;/h4&gt;

&lt;p&gt;추가 설정에 대한 내용은 &lt;a href=&quot;https://www.spinnaker.io/reference/halyard/commands#hal-config-provider-kubernetes-account-add&quot;&gt;Halyard Reference&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;설치환경-선택하기&quot;&gt;설치환경 선택하기&lt;/h2&gt;

&lt;p&gt;Halyard가 Spinnaker를 어디에 설치할지 선택합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분산 설치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Halyard가 Spinnaker’s 마이크로서비스를 분산 설치합니다. 운영환경으로 설치 시 권장합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로컬 설치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하나의 머신에 설치됩니다. 소규모 배포에 적합합니다.
 of Debian packages Spinnaker is deployed on a single machine. This is good for smaller deployments.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;github에서 설치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spinnaker 프로젝트에 기여하는 개발자에게 적합합니다.&lt;/p&gt;

&lt;p&gt;이 페이지에서는 분산 설치 방식으로 진행해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;분산-설치&quot;&gt;분산 설치&lt;/h3&gt;

&lt;p&gt;분산 설치는 리소스가 많은 개발 조직 및 Spinnaker 업데이트 중 다운 타임을 없어야 하는 경우에 적합합니다.&lt;/p&gt;

&lt;p&gt;Spinnaker는 원격 클라우드에 배포되며 각 마이크로 서비스는 독립적으로 배포됩니다. Halyard는 Spinnaker 마이크로 서비스를 무중단으로 업데이트합니다.&lt;/p&gt;

&lt;p&gt;Spinnaker를 설치하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 cores&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;8GB of RAM&lt;/code&gt;을 권장합니다.&lt;/p&gt;

&lt;p&gt;아래 명령을 실행합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;$ACCOUNT&lt;/code&gt;는 공급자 선택에서 설정한 생성한 계정입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal config deploy edit --type distributed --account-name $ACCOUNT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;스토리지-선택하기&quot;&gt;스토리지 선택하기&lt;/h2&gt;

&lt;p&gt;Spinnaker에는 애플리케이션 설정 및 파이프 라인 설정을 유지하기 위해 외부 저장소가 필요합니다.&lt;/p&gt;

&lt;p&gt;Spinnaker는 아래와 같은 스토리지를 지원합니다. 어떤 옵션을 선택해도 Cloud 공급자 선택에 영향을 미치지 않습니다.
예를 들어, Google Cloud Storage를 저장소 소스로 사용할 수 있지만 여전히 Microsoft Azure에 배포 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Azure Storage&lt;/li&gt;
  &lt;li&gt;Google Cloud Storage&lt;/li&gt;
  &lt;li&gt;Minio&lt;/li&gt;
  &lt;li&gt;Redis&lt;/li&gt;
  &lt;li&gt;S3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고: Redis는 운영환경에서는 권장하지 않습니다.&lt;/p&gt;

&lt;p&gt;이 페이지에서는 Minio를 사용해서 Self 호스팅하는 S3와 연동하는 방식으로 진행해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;minio&quot;&gt;Minio&lt;/h3&gt;

&lt;p&gt;Minio의 데이터를 잃으면 Spinnaker 애플리케이션 메타 데이터 및 파이프 라인이 모두 손실됩니다.&lt;/p&gt;

&lt;p&gt;Minio는 Self 호스팅 할 수있는 S3 호환 Object Storage입니다. Spinnaker 데이터를 호스팅하기 위해 클라우드 제공 업체에 의존하고 싶지 않을 때 권장되는 영구 저장소 솔루션입니다.&lt;/p&gt;

&lt;h4 id=&quot;사전-준비-1&quot;&gt;사전 준비&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.minio.io/&quot;&gt;Minio 홈페이지&lt;/a&gt;에 있는 가이드를 따라 Minio를 설치합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;S3에 Bucket을 생성합니다. 이 Bucket 명을 아래 스토리지 설정에서 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;스토리지-설정&quot;&gt;스토리지 설정&lt;/h4&gt;

&lt;p&gt;Minio가 버전 객체를 지원하지 않으므로 Spinnaker에서 버전 객체를 비활성화합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi ~/.hal/$DEPLOYMENT/profiles/front50-local.yml:
spinnaker.s3.versioning: false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;$DEPLOYMENT 일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;아래 명령을 실행해 S3를 저장소 유형으로 선택합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export ENDPOINT=S3_ENDPOINT
$ export MINIO_ACCESS_KEY=S3_ACCESS_KEY_ID

$ hal config storage s3 edit --endpoint $ENDPOINT \
    --access-key-id $MINIO_ACCESS_KEY \
    --bucket BUCKET_NAME
    --secret-access-key
  Your AWS Secret Key.:

$ hal config storage edit --type s3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;spinnaker-설치&quot;&gt;Spinnaker 설치&lt;/h2&gt;

&lt;p&gt;설치 가능한 버전을 조회합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal version list
  + Get current deployment
    Success
  + Get Spinnaker version
    Success
  + Get released versions
    Success
  + You are on version &quot;&quot;, and the following are available:
   - 1.5.4 (Atypical):
     Changelog: https://gist.github.com/spinnaker-release/6b9fd632caeaefd32246074998af8498
     Published: Wed Jan 10 18:46:49 UTC 2018
     (Requires Halyard &amp;gt;= 0.40.0)
   - 1.6.1 (GLOW):
     Changelog: https://gist.github.com/spinnaker-release/f1cd6232151b70492ebdcbb557a209fc
     Published: Wed Apr 04 19:20:54 UTC 2018
     (Requires Halyard &amp;gt;= 0.41.0)
   - 1.7.6 (Ozark):
     Changelog: https://gist.github.com/spinnaker-release/5d3af465f07eaca64f4383167877897d
     Published: Tue May 29 16:26:20 UTC 2018
     (Requires Halyard &amp;gt;= 1.0.0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원하는 버전을 선택합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal config version edit --version $VERSION
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ingress에서 사용할 도메인을 입력합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal config security ui edit --override-base-url http://spinnaker.zcp-dev.jp-tok.containers.mybluemix.net
$ hal config security api edit --override-base-url http://spinnaker-api.zcp-dev.jp-tok.containers.mybluemix.net
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 Spinnaker를 배포합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal deploy apply
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;spinnaker-expose&quot;&gt;Spinnaker expose&lt;/h2&gt;

&lt;p&gt;Spinnaker에 접속하기 위해서 ingress를 통해 서비스를 노출시켜보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;ingress.yaml&lt;/code&gt;을 작성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi ingress.yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: spinnaker
spec:
  rules:
  - host: spinnaker.example.com
    http:
      paths:
      - backend:
          serviceName: spin-deck
          servicePort: 9000
  - host: spinnaker-api.example.com
    http:
      paths:
      - backend:
          serviceName: spin-gate
          servicePort: 8084
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 명령어를 통해 ingress를 배포합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl apply -f ingress.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;spinnaker.example.com&lt;/code&gt;에 접속해 Spinnaker 대시보드를 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;trouble-shooting&quot;&gt;Trouble Shooting&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Service: Amazon S3; Status Code: 400; Error Code: InvalidLocationConstraint&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;아래와 같은 에러 발생 시 S3에서 bucket을 수동으로 생성 후 halyard config에서 새로 생성한 bucket명으로 수정한 후 다시 배포해봅니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.netflix.spinnaker.front50.model.S3StorageService]: Factory method 's3StorageService' threw exception; nested exception is com.amazonaws.services.s3.model.AmazonS3Exception: Container storage location with specified provisioning code not available (Service: Amazon S3; Status Code: 400; Error Code: InvalidLocationConstraint; Request ID: d08c26ee-34ba-4e62-83bc-5d9a26b23947; S3 Extended Request ID: null), S3 Extended Request ID: null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ vi ~/.hal/config
  - name: default
    persistentStorage:
      s3:
        bucket: example-bucket

  $ hal deploy apply      
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Spinnaker를 설치하는 방법에 대해 설명합니다. 자세한 내용은 Set up Spinnaker을 참고하세요.</summary></entry><entry><title type="html">Cannot find module ‘webpack/lib/node/NodeTemplatePlugin’</title><link href="http://localhost:4000/blog/angular/2018/05/29/angular-cannot-find-module.html" rel="alternate" type="text/html" title="Cannot find module 'webpack/lib/node/NodeTemplatePlugin'" /><published>2018-05-29T00:00:00+09:00</published><updated>2018-05-29T00:00:00+09:00</updated><id>http://localhost:4000/blog/angular/2018/05/29/angular-cannot-find-module</id><content type="html" xml:base="http://localhost:4000/blog/angular/2018/05/29/angular-cannot-find-module.html">&lt;p&gt;Angular build 시 아래와 같은 에러가 나는 경우가 있습니다.
npm5에 도입된 &lt;code class=&quot;highlighter-rouge&quot;&gt;package-lock.json&lt;/code&gt;을 삭제하지 않고 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt;을 한 경우 발생합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn run xxx
yarn run v1.7.0
$ ng build --prod --aot --progress=false --output-path rootfs/dist
Cannot find module 'webpack/lib/node/NodeTemplatePlugin'
Error: Cannot find module 'webpack/lib/node/NodeTemplatePlugin'
    at Function.Module._resolveFilename (module.js:547:15)
    at Function.Module._load (module.js:474:25)
    at Module.require (module.js:596:17)
    at require (internal/module.js:11:18)
    at Object.&amp;lt;anonymous&amp;gt; (/Users/sangjunyun/git/zcp-catalog-ui/node_modules/html-webpack-plugin/lib/compiler.js:11:26)
    at Module._compile (module.js:652:30)
    at Object.Module._extensions..js (module.js:663:10)
    at Module.load (module.js:565:32)
    at tryModuleLoad (module.js:505:12)
    at Function.Module._load (module.js:497:3)
    at Module.require (module.js:596:17)
    at require (internal/module.js:11:18)
    at Object.&amp;lt;anonymous&amp;gt; (/Users/sangjunyun/git/zcp-catalog-ui/node_modules/html-webpack-plugin/index.js:7:21)
    at Module._compile (module.js:652:30)
    at Object.Module._extensions..js (module.js:663:10)
    at Module.load (module.js:565:32)
error Command failed with exit code 1.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
make: *** [compile-aot] Error 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 명령어를 실행해 &lt;code class=&quot;highlighter-rouge&quot;&gt;node_modules&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;dist&lt;/code&gt; 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;package-lock.json&lt;/code&gt;을 삭제합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rm -rf node_modules dist package-lock.json
$ npm cache clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt; 명령을 실행해 node_modules을 다시 설치합니다.
이후 Angular build를 다시하면 정상적으로 실행됩니다.&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">Angular build 시 아래와 같은 에러가 나는 경우가 있습니다. npm5에 도입된 package-lock.json을 삭제하지 않고 npm install을 한 경우 발생합니다.</summary></entry><entry><title type="html">Helm 설치하기</title><link href="http://localhost:4000/blog/helm/2018/05/27/installing-helm.html" rel="alternate" type="text/html" title="Helm 설치하기" /><published>2018-05-27T00:00:00+09:00</published><updated>2018-05-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/27/installing-helm</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/27/installing-helm.html">&lt;p&gt;이 페이지는 Helm을 설치하는 방법에 대해 설명합니다.
자세한 내용은 &lt;a href=&quot;https://docs.helm.sh/using_helm/#installing-helm&quot;&gt;Installing Helm&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;helm-client-바이너리-다운로드&quot;&gt;Helm client 바이너리 다운로드&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/helm/releases&quot;&gt;Helm release&lt;/a&gt; 바이너리를 다운로드합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;바이너리 압축 해제합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  tar -zxvf helm-vX.X.X-OS_NAME-amd64.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Helm 바이너리를 원하는 위치로 이동시킵니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mv OS_NAME-amd64/helm /usr/local/bin/helm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tiller-설치&quot;&gt;Tiller 설치&lt;/h2&gt;

&lt;p&gt;Helm의 서버 부분 인 Tiller는 일반적으로 Kubernetes 클러스터 내부에서 실행됩니다. 그러나 개발을 위해 로컬로 실행될 수도 있고 원격 Kubernetes 클러스터와 통신하도록 구성 될 수도 있습니다.&lt;/p&gt;

&lt;p&gt;Tiller를 클러스터에 설치하는 가장 쉬운 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;helm init&lt;/code&gt;를 실행하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;helm init&lt;/code&gt; 실행 후 Tiller가 running 상태가 될 때까지 대기합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pods --namespace kube-system |grep tiller
tiller-deploy-7ccf99cd64-pd7c2        1/1       Running   0          3d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Helm client와 server의 버전을 확인합니다.
Server의 버전이 Client의 버전과 같거나 높아야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm version
Client: &amp;amp;version.Version{SemVer:&quot;v2.9.0&quot;, GitCommit:&quot;xxx&quot;, GitTreeState:&quot;clean&quot;}
Server: &amp;amp;version.Version{SemVer:&quot;v2.9.1&quot;, GitCommit:&quot;xxx&quot;, GitTreeState:&quot;clean&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Server를 제외한 Client만 설치하고 싶은 경우 아래와 같이 실행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm init --client-only
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 Helm을 활용해 chart를 Kubernetes에 배포할 수 있습니다.&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Helm을 설치하는 방법에 대해 설명합니다. 자세한 내용은 Installing Helm을 참고하세요.</summary></entry><entry><title type="html">Ingress TLS Secret 생성하기</title><link href="http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html" rel="alternate" type="text/html" title="Ingress TLS Secret 생성하기" /><published>2018-05-27T00:00:00+09:00</published><updated>2018-05-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html">&lt;p&gt;이 페이지에서는 Ingress에 TLS를 적용하기 위한 Secret을 생성하는 방법을 가이드합니다.&lt;/p&gt;

&lt;h2 id=&quot;tls-secret-생성&quot;&gt;TLS Secret 생성&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하여 TLS Secret을 생성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create secret tls example-tls --cert example.crt --key example.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 아래와 같이 yaml 파일 형태로 생성할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi secret.yaml
apiVersion: v1
data:
  tls.crt: base64 encoded cert
  tls.key: base64 encoded key
kind: Secret
metadata:
  name: example-tls
type: Opaque

$ kubectl create -f secret.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tls-secret을-ingress에-적용&quot;&gt;TLS Secret을 Ingress에 적용&lt;/h2&gt;

&lt;p&gt;아래와 같이 Ingress의 secretName 속성에 example-tls을 적용합니다.
이제 Ingress를 배포한 후 host로 접속하면 TLS가 적용된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: example-ingress
spec:
  rules:
  - host: example.com
    http:
      paths:
      - backend:
          serviceName: example
          servicePort: 80
  tls:
  - hosts:
    - example.com
    secretName: example-tls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지에서는 Ingress에 TLS를 적용하기 위한 Secret을 생성하는 방법을 가이드합니다.</summary></entry><entry><title type="html">Helm chart를 사용하여 Jenkins를 컨테이너로 배포하기</title><link href="http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart.html" rel="alternate" type="text/html" title="Helm chart를 사용하여 Jenkins를 컨테이너로 배포하기" /><published>2018-05-26T00:00:00+09:00</published><updated>2018-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart.html">&lt;p&gt;이 페이지는 Helm chart를 사용하여 Jenkins를 컨테이너로 배포하는 방법에 대해 설명합니다.
자세한 내용은 &lt;a href=&quot;https://github.com/kubernetes/charts/tree/master/stable/jenkins&quot;&gt;Jenkins Helm Chart&lt;/a&gt;에서 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;준비-사항&quot;&gt;준비 사항&lt;/h2&gt;

&lt;p&gt;아래 가이드를 참고하여 Helm Client를 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/helm/2018/05/27/installing-helm.html&quot;&gt;Helm 설치하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;빠른-설치&quot;&gt;빠른 설치&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하면 Kubernetes 클러스터에 Jenkins가 배포됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm install --name jenkins stable/jenkins
NAME:   jenkins
...
NOTES:
1. Get your 'admin' user password by running:
  printf $(kubectl get secret --namespace default jenkins -o jsonpath=&quot;{.data.jenkins-admin-password}&quot; | base64 --decode);echo
2. Get the Jenkins URL to visit by running these commands in the same shell:
  NOTE: It may take a few minutes for the LoadBalancer IP to be available.
        You can watch the status of by running 'kubectl get svc --namespace default -w jenkins'
  ...
  echo http://$SERVICE_IP:8080/login

3. Login with the password from step 1 and the username: admin

For more information on running Jenkins on Kubernetes, visit:
https://cloud.google.com/solutions/jenkins-on-container-engine
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정상적으로 설치가 완료되었다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOTES&lt;/code&gt;의 가이드를 참고하여 Jenkins 대시보드에 접속할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;참고 : 기본 설정을 사용하므로 클러스터 환경에 따라 설치 중 에러가 발생할 수 있습니다.
이런 경우 아래 가이드를 따라 사용자 설정 방식으로 배포 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사용자-정의-설치&quot;&gt;사용자 정의 설치&lt;/h2&gt;

&lt;h3 id=&quot;설정&quot;&gt;설정&lt;/h3&gt;

&lt;p&gt;사용자의 Kubernetes 클러스터 환경에 맞게 Jenkins의 서비스, 스토리지 등의 설정을 변경할 수 있습니다.
아래 가이드를 참고하여 사용자의 환경에 맞도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;values.yaml&lt;/code&gt; 파일을 작성합니다.&lt;/p&gt;

&lt;h4 id=&quot;jenkins-admin-사용자-암호&quot;&gt;Jenkins admin 사용자 암호&lt;/h4&gt;

&lt;p&gt;Jenkins admin의 초기 사용자 암호입니다. 기본 설정은 랜덤한 패스워드입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  AdminPassword: ExamplePassword
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;서비스&quot;&gt;서비스&lt;/h4&gt;

&lt;p&gt;서비스는 Jenkins 대시보드를 접속을 어떤 방식으로 제공할지에 대한 설정입니다.
기본 설정은 LoadBalancer 방식입니다. 사용자의 클러스터의 환경에 동적으로 제공되는 LoadBalancer 서비스가 있다면 사용 가능합니다.
LoadBalancer 서비스가 없다면 아래와 같이 NodePort 또는 Ingress 방식을 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;NodePort&lt;/p&gt;

    &lt;p&gt;NodePort를 사용하면 Worker Node의 Public IP를 통하여 서비스에 접근 할 수 있습니다.
ServiceType을 NodePort로 설정하고 NodePort에 30000~32767사이의 포트 번호를 입력합니다.
포트 번호를 입력하지 않으면 30000~32767사이의 숫자에서 랜덤하게 선택됩니다.&lt;/p&gt;

    &lt;p&gt;접속 URI 예시 : http://WORKER_NODE_PUBLIC_IP:3xxxx&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  ServiceType: NodePort
  NodePort: 30000-32767
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ingress&lt;/p&gt;

    &lt;p&gt;Ingress를 사용하면 Ingress Controller의 Public IP를 통하여 서비스에 접근 할 수 있습니다.
ServiceType을 ClusterIP로 설정하고 HostName에 원하는 도메인을 입력합니다.(이 때 도메인이 Ingress Controller의 Public IP와 연결되어야 합니다.)
SSL 접속을 지원하려면 TLS 설정의 secretName과 host명을 입력합니다.&lt;/p&gt;

    &lt;p&gt;Ingress TLS Secret 생성 방법은 아래 가이드를 참고하세요.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html&quot;&gt;Ingress TLS Secret 생성하기&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  ServiceType: ClusterIP
  HostName: jenkins.example.com
  Ingress:
    TLS:
      - secretName: example-tls
        hosts:
          - jenkins.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;스토리지&quot;&gt;스토리지&lt;/h4&gt;

&lt;p&gt;Jenkins는 영구적으로 저장해야 하는 데이터를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/jenkins_home&lt;/code&gt;에 저장합니다.
이 데이터를 영구적으로 저장하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/jenkins_home&lt;/code&gt; 폴더를 PV(Persistent Volume)에 mount 해야합니다.
사용자의 Cluster에서 동적으로 PV를 생성 및 관리해주는 기능이 있다면 별도의 설정이 필요없습니다.
GKE, AWS, AKS 등의 환경에서는 Storage Class를 정의하면 PV를 생성하고 관리합니다.
또한 미리 구성된 PVC(PersistentVolumeClaim)를 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Storage Class 사용&lt;/p&gt;

    &lt;p&gt;Storage Class를 사용하여 동적으로 PV를 생성합니다.
Storage Class 명은 아래와 같이 확인할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get storageclass
NAME                       PROVISIONER         AGE
default                    ibm.io/ibmc-file    41d
ibmc-block-bronze          ibm.io/ibmc-block   3d
ibmc-file-bronze           ibm.io/ibmc-file    26d
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;원하는 Storage Class 명을 입력합니다. Storage의 크기를 원하는 값으로 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Persistence:
  StorageClass: &quot;default&quot;
  Size: 8Gi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사전 구성된 PVC 사용&lt;/p&gt;

    &lt;p&gt;미리 구성된 PVC(PersistentVolumeClaim)를 사용합니다.
미리 구성된 PVC 명은 아래와 같이 확인할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pvc
NAME          STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS        AGE
jenkins-pvc   Bound     pvc-47aec304-5e4e-11e8-915d-82c09a00d8d2   20Gi       RWO            ibmc-block-bronze   3d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;미리 구성된 PVC 명을 입력합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Persistence:
  ExistingClaim: &quot;jenkins-pvc&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설치&quot;&gt;설치&lt;/h3&gt;

&lt;p&gt;이제 아래 명령을 실행하여 사용자 정의에 맞게 Jenkins를 설치합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm install --name jenkins -f values.yaml stable/jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Helm chart를 사용하여 Jenkins를 컨테이너로 배포하는 방법에 대해 설명합니다. 자세한 내용은 Jenkins Helm Chart에서 참고하세요.</summary></entry><entry><title type="html">Helm chart repository 호스팅</title><link href="http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository.html" rel="alternate" type="text/html" title="Helm chart repository 호스팅" /><published>2018-05-26T00:00:00+09:00</published><updated>2018-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository.html">&lt;p&gt;Helm chart를 개발한 후 외부에서 helm cli를 통해 다운로드 및 설치 하려면 Helm chart repository를 만들어야 합니다.&lt;/p&gt;

&lt;p&gt;kubernetes helm &lt;a href=&quot;https://github.com/kubernetes/helm/blob/master/docs/chart_repository.md&quot;&gt;가이드&lt;/a&gt;에서 지원하는 방식은 3가지 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Github Pages&lt;/li&gt;
  &lt;li&gt;Object Storage(GCS, AWS S3)&lt;/li&gt;
  &lt;li&gt;Ordinary Web Servers&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github-pages&quot;&gt;Github Pages&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Github에 Repository 생성 및 docs 폴더 생성&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/YunSangJun/sj-charts&quot;&gt;샘플 코드&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Chart Repository
     | ㅡ docs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Github Page 설정&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Repository -&amp;gt; Settings -&amp;gt; Github Pages&lt;/code&gt; 메뉴 클릭&lt;/p&gt;

    &lt;p&gt;Source를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/docs&lt;/code&gt; 로 지정. 지정 후 아래와 같은 site 주소 확인&lt;/p&gt;

    &lt;p&gt;https://yunsangjun.github.io/sj-charts&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm Package 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # helm create mychart
 # helm package mychart
 # mv mychart-0.1.0.tgz docs
 # helm repo index docs --url https://yunsangjun.github.io/sj-charts
 # git add --all
 # git commit -m 'init'
 # git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm repository에 추가&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # helm repo add mychart https://yunsangjun.github.io/sj-charts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>윤상준</name></author><summary type="html">Helm chart를 개발한 후 외부에서 helm cli를 통해 다운로드 및 설치 하려면 Helm chart repository를 만들어야 합니다.</summary></entry><entry><title type="html">Docker 이미지 레이어란?</title><link href="http://localhost:4000/blog/docker/2018/05/26/docker-image-layer.html" rel="alternate" type="text/html" title="Docker 이미지 레이어란?" /><published>2018-05-26T00:00:00+09:00</published><updated>2018-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/docker/2018/05/26/docker-image-layer</id><content type="html" xml:base="http://localhost:4000/blog/docker/2018/05/26/docker-image-layer.html">&lt;p&gt;Docker Image를 pull, push 하다보면 layer라는 용어가 나옵니다. Docker 에서 사용하는 layer 구조가 무엇이고 왜 사용할까요?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
2a72cbf407d6: Pulling fs layer
04b2d3302d48: Pulling fs layer
e7f619103861: Pulling fs layer
...
2a72cbf407d6: Pull complete
04b2d3302d48: Pull complete
e7f619103861: Pull complete
Digest: sha256:18156dcd747677b03968621b2729d46021ce83a5bc15118e5bcced925fb4ebb9
Status: Downloaded newer image for nginx:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;docker-image-layer-구조란&quot;&gt;Docker Image Layer 구조란?&lt;/h2&gt;

&lt;p&gt;Dockerfile을 build 하면 정의된 명령어에 따라 Docker 이미지가 생성됩니다. 하나의 이미지로 보이지만 내부적으로는 여러개의 이미지가 층층히 쌓여있는 layer 구조입니다. 좀 더 쉽게 예를 들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;아래 예제는 nginx image를 build하기 위한 Dockerfile입니다. step1~6까지 총 6개의 명령으로 이루어져 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;Dockerfile&amp;gt;
# step1. Base image
FROM ubuntu:latest

# step2. Install Nginx.
RUN \
  apt-get update &amp;amp;&amp;amp; \
  apt-get install -y nginx

# step3. Define mountable directories.
VOLUME [&quot;/etc/nginx/sites-enabled&quot;, &quot;/etc/nginx/certs&quot;, &quot;/etc/nginx/conf.d&quot;, &quot;/var/log/nginx&quot;, &quot;/var/www/html&quot;]

# step4. Define working directory.
WORKDIR /etc/nginx

# step5. Define default command.
CMD [&quot;nginx&quot;]

# step6. Expose port.
EXPOSE 80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 Dockerfile을 build 해보겠습니다. 아래와 같이 각 명령어 단계마다 이미지가 생성됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker build -t nginx .
Sending build context to Docker daemon  2.048kB
Step 1/6 : FROM ubuntu:latest
...
 ---&amp;gt; c9d990395902    # 1번 이미지
Step 2/6 : RUN   apt-get update &amp;amp;&amp;amp;   apt-get install -y nginx
...
 ---&amp;gt; 90100bc32c07    # 2번 이미지
Step 3/6 : VOLUME [&quot;/etc/nginx/sites-enabled&quot;, &quot;/etc/nginx/certs&quot;, &quot;/etc/nginx/conf.d&quot;, &quot;/var/log/nginx&quot;, &quot;/var/www/html&quot;]
...
 ---&amp;gt; 8ea7a4443b1e    # 3번 이미지
Step 4/6 : WORKDIR /etc/nginx
...
 ---&amp;gt; 37773795f83d    # 4번 이미지
Step 5/6 : CMD [&quot;nginx&quot;]
...
 ---&amp;gt; 4f8728cb93dc    # 5번 이미지
Step 6/6 : EXPOSE 80
...
 ---&amp;gt; bec972ccfa66    # 6번 이미지
Successfully built b5d127ff2140
Successfully tagged nginx:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;왜-사용할까요&quot;&gt;왜 사용할까요?&lt;/h2&gt;

&lt;p&gt;그렇다면 이런 Image layer 구조는 왜 사용할까?
Nginx 이미지를 기반으로 Web App을 만들었다고 가정해보자. App source를 수정할 때 마다 전체 이미지를 다시 다운로드 받는다면 매우 비효율적이라 생각된다. 하지만 Docker Image는 layer 구조로 되어있기 때문에 Base image인 nginx image layer는 다운로드 받지 않고 변경된 source layer만 받게 된다. 이런 이유로 Docker Image는 layer 구조로 설계되어 있다.&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">Docker Image를 pull, push 하다보면 layer라는 용어가 나옵니다. Docker 에서 사용하는 layer 구조가 무엇이고 왜 사용할까요?</summary></entry><entry><title type="html">Docker Private Registry로 부터 이미지 가져오기</title><link href="http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry.html" rel="alternate" type="text/html" title="Docker Private Registry로 부터 이미지 가져오기" /><published>2018-05-25T00:00:00+09:00</published><updated>2018-05-25T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry.html">&lt;p&gt;이 페이지는 Secret을 사용하여 Private Docker Registry에서 이미지를 가져오는 Pod를 만드는 방법을 보여줍니다.&lt;br /&gt;
상세한 내용은 아래 링크를 참고하세요.&lt;/p&gt;

&lt;p&gt;https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&lt;/p&gt;

&lt;h2 id=&quot;docker-private-registry에-로그인&quot;&gt;Docker Private Registry에 로그인&lt;/h2&gt;

&lt;p&gt;개인 이미지를 가져오려면 Registry로 인증해야합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker login YOUR_REPOSITORY_URI
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;config.json&lt;/code&gt; 파일을 조회합니다. 해당 Repository에 대한 인증 토큰 정보가 출력됩니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat ~/.docker/config.json
{
    &quot;auths&quot;: {
        &quot;YOUR_REPOSITORY_URI&quot;: {
            &quot;auth&quot;: &quot;c3R...zE2&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;인증-토큰을-사용하여-secret-생성하기&quot;&gt;인증 토큰을 사용하여 Secret 생성하기&lt;/h2&gt;

&lt;p&gt;Kubernetes 클러스터는 docker-registry 유형의 Secret을 사용하여 컨테이너 레지스트리로 인증하여 개인 이미지를 가져옵니다.&lt;/p&gt;

&lt;p&gt;이 Secret 만들어서 이름을 regcred로 지정하십시오.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create secret docker-registry regcred --docker-server=&amp;lt;your-registry-server&amp;gt; --docker-username=&amp;lt;your-name&amp;gt; --docker-password=&amp;lt;your-pword&amp;gt; --docker-email=&amp;lt;your-email&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;your-registry-server : Private Docker Registry FQDN.&lt;/li&gt;
  &lt;li&gt;your-name : Docker username.&lt;/li&gt;
  &lt;li&gt;your-pword : Docker password.&lt;/li&gt;
  &lt;li&gt;your-email : Docker email.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;secret-확인하기&quot;&gt;Secret 확인하기&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;regcred&lt;/code&gt; Secret 내용 조회&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get secret regcred --output=yaml
apiVersion: v1
data:
  .dockercfg: eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=
kind: Secret
metadata:
  ...
  name: regcred
  ...
type: kubernetes.io/dockercfg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.dockercfg&lt;/code&gt; 정보 Decode&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get secret regcred --output=&quot;jsonpath={.data.\.dockercfg}&quot; | base64 --decode
{&quot;auths&quot;:{&quot;yourprivateregistry.com&quot;:{&quot;username&quot;:&quot;janedoe&quot;,&quot;password&quot;:&quot;xxxxxxxxxxx&quot;,&quot;email&quot;:&quot;jdoe@example.com&quot;,&quot;auth&quot;:&quot;c3R...zE2&quot;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인증 토큰 조회&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo &quot;c3R...zE2&quot; | base64 -d
janedoe:xxxxxxxxxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;secret을-사용하여-pod-생성하기&quot;&gt;Secret을 사용하여 Pod 생성하기&lt;/h2&gt;

&lt;p&gt;Pod yaml 생성&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi my-private-reg-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: private-reg
spec:
  containers:
  - name: private-reg-container
    image: &amp;lt;your-private-image&amp;gt;
  imagePullSecrets:
  - name: regcred
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod 배포. 정상적으로 완료했다면 이미지를 Docker Private Registry로 부터 가져오고 Pod가 Running 상태로 변경됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create -f my-private-reg-pod.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Secret을 사용하여 Private Docker Registry에서 이미지를 가져오는 Pod를 만드는 방법을 보여줍니다. 상세한 내용은 아래 링크를 참고하세요.</summary></entry><entry><title type="html">KubeCon &amp;amp; CloudNativeCon Europe 2018</title><link href="http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018.html" rel="alternate" type="text/html" title="KubeCon &amp; CloudNativeCon Europe 2018" /><published>2018-05-25T00:00:00+09:00</published><updated>2018-05-25T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018.html">&lt;h2 id=&quot;jenkins-x-easy-cicd-for-kubernetes---james-strachan-cloudbees&quot;&gt;Jenkins X: Easy CI/CD for Kubernetes - James Strachan, CloudBees&lt;/h2&gt;

&lt;h3 id=&quot;link&quot;&gt;Link&lt;/h3&gt;
&lt;p&gt;https://www.youtube.com/watch?v=uHe7R_iZSLU&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;</content><author><name>윤상준</name></author><summary type="html">Jenkins X: Easy CI/CD for Kubernetes - James Strachan, CloudBees</summary></entry></feed>