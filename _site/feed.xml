<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2019-06-21T13:08:53+09:00</updated><id>http://localhost:4000/blog/</id><title type="html">윤상준의 기술 블로그</title><subtitle>Software &amp; Cloud Engineer 입니다. Kubernetes, Cloud Foundry등의 PaaS와 Cloud 및 DevOps 관련 기술에 관심이 있습니다.</subtitle><author><name>Yun SangJun</name></author><entry><title type="html">AWS에서 CI/CD 환경 구성 #2 - 형상 관리 구성, CodeCommit</title><link href="http://localhost:4000/blog/cloud/2019/06/20/aws-cicd02.html" rel="alternate" type="text/html" title="AWS에서 CI/CD 환경 구성 #2 - 형상 관리 구성, CodeCommit" /><published>2019-06-20T00:00:00+09:00</published><updated>2019-06-20T00:00:00+09:00</updated><id>http://localhost:4000/blog/cloud/2019/06/20/aws-cicd02</id><content type="html" xml:base="http://localhost:4000/blog/cloud/2019/06/20/aws-cicd02.html">&lt;p&gt;AWS에서 CodeCommit 서비스를 활용하여 형상 관리를 구성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;p&gt;CodeCommit 서비스를 사용하기 위해 아래와 같이 사전 준비를 합니다.&lt;/p&gt;

&lt;h3 id=&quot;git-버전-확인&quot;&gt;Git 버전 확인&lt;/h3&gt;

&lt;p&gt;로컬 환경의 Git 버전이 1.7.9 이상을 지원하는지 확인합니다.&lt;/p&gt;

&lt;h3 id=&quot;권한-생성&quot;&gt;권한 생성&lt;/h3&gt;

&lt;p&gt;IAM 사용자가 CodeCommit 서비스에 접근할 수 있도록 권한을 생성합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;AWS IAM Console에 접속 &amp;gt; 왼쪽 메뉴의 사용자 메뉴 선택 &amp;gt; CodeCommit 서비스를 사용할 IAM 사용자 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; 권한 탭 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;권한 추가&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-06.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;권한 부여 방식에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;기존 정책 직접 연결&lt;/code&gt; 선택 &amp;gt; 권한 리스트에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;AWSCodeCommitFullAccess&lt;/code&gt; 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음 검토&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;권한 요약을 리뷰 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;권한 추가&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;git-자격-증명-생성&quot;&gt;Git 자격 증명 생성&lt;/h3&gt;

&lt;p&gt;Git 클라이언트 툴을 사용해 CodeCommit에 접속하기 위해 자격 증명을 생성합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;AWS IAM Console에 접속 &amp;gt; 왼쪽 메뉴의 사용자 메뉴 선택 &amp;gt; CodeCommit 서비스를 사용할 IAM 사용자 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; 보안 자격 증명 탭 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-09.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;페이지 하단으로 이동 &amp;gt; AWS CodeCommit에 대한 HTTPS Git 자격 증명 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;팝업 화면의 사용자 이름, 비밀번호를 복사해서 보관 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;닫기&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;저장소repository-생성&quot;&gt;저장소(Repository) 생성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;AWS CodeCommit Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; 소스 &amp;gt; 시작하기를 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-01.png&quot; alt=&quot;&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;페이지의 &lt;code class=&quot;highlighter-rouge&quot;&gt;리포지토리 생성&lt;/code&gt; 버튼을 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리포지토리 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt;로 입력 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;저장소 생성 완료&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;저장소repository-사용&quot;&gt;저장소(Repository) 사용&lt;/h2&gt;

&lt;h3 id=&quot;저장소-복제&quot;&gt;저장소 복제&lt;/h3&gt;

&lt;p&gt;앞에서 생성한 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 저장소를 로컬 환경으로 복제합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;CodeCommit 콘솔 &amp;gt; 저장소의 복제 명령어 복사&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로컬 환경의 터미널 &amp;gt; 복사한 명령어를 실행&lt;/p&gt;

    &lt;p&gt;계정 입력 메세지가 출력되면 사전 준비에서 생성한 git 자격 증명의 사용자 이름, 비밀번호를 입력합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ git clone https://git-codecommit.ap-northeast-2.amazonaws.com/v1/repos/cicd-demo
 Cloning into 'cicd-demo'...
 warning: You appear to have cloned an empty repository.
 $ cd cicd-demo/
 $ ls -a
 .       ..      .git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;저장소에-샘플-소스코드-commit&quot;&gt;저장소에 샘플 소스코드 Commit&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;CI/CD 환경 구성에서 사용할 샘플 애플리케이션의 소스코드를 다운로드&lt;/p&gt;

    &lt;p&gt;이 문서에서는 &lt;a href=&quot;https://github.com/spring-projects/spring-petclinic&quot;&gt;spring-petclinic&lt;/a&gt; 프로젝트를 활용하겠습니다.&lt;/p&gt;

    &lt;p&gt;웹 브라우저에서 &lt;a href=&quot;https://github.com/spring-projects/spring-petclinic&quot;&gt;spring-petclinic&lt;/a&gt; 프로젝트에 접속한 후 아래와 같이 소스코드를 다운로드 합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spring-petclinic-master.zip&lt;/code&gt; 프로젝트의 압축 해제 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 폴더로 복사&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 폴더에 추가된 소스코드를 CodeCommit 저장소로 Commit&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ git add --all
 $ git commit -m &quot;Init&quot;
 [master (root-commit) 2420d24] Init
 95 files changed, 14563 insertions(+)
 ...
 $ git push
 Counting objects: 141, done.
 Delta compression using up to 8 threads.
 Compressing objects: 100% (127/127), done.
 Writing objects: 100% (141/141), 401.09 KiB | 7.16 MiB/s, done.
 Total 141 (delta 27), reused 0 (delta 0)
 To https://git-codecommit.ap-northeast-2.amazonaws.com/v1/repos/cicd-demo
 * [new branch]      master -&amp;gt; master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CodeCommit 콘솔에 접속&lt;/p&gt;

    &lt;p&gt;이제 CodeCommit 콘솔에 접속해보면 저장소에 Commit한 소스코드를 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd02-14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>윤상준</name></author><category term="aws" /><category term="cicd" /><category term="devops" /><category term="awscodecommit" /><summary type="html">AWS에서 CodeCommit 서비스를 활용하여 형상 관리를 구성하는 방법을 알아보겠습니다.</summary></entry><entry><title type="html">AWS에서 CI/CD 환경 구성 #1 - Overview</title><link href="http://localhost:4000/blog/cloud/2019/06/19/aws-cicd01.html" rel="alternate" type="text/html" title="AWS에서 CI/CD 환경 구성 #1 - Overview" /><published>2019-06-19T00:00:00+09:00</published><updated>2019-06-19T00:00:00+09:00</updated><id>http://localhost:4000/blog/cloud/2019/06/19/aws-cicd01</id><content type="html" xml:base="http://localhost:4000/blog/cloud/2019/06/19/aws-cicd01.html">&lt;p&gt;AWS에서 CI/CD 환경을 구성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 아래와 같은 AWS의 서비스를 활용하여 CI/CD 환경을 구성합니다. 
에플리케이션을 서버는 ECS(Elastic Container Service) Fargate를 활용하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;형상 관리: CodeCommit. Git 기반으로 Github와 사용방법이 동일함&lt;/li&gt;
  &lt;li&gt;빌드: CodeBuild. 애플리케이션 빌드 및 패키징(Maven, NPM 등), Docker 이미지 빌드 및 ECR(Elastic Container Registry)에 Push&lt;/li&gt;
  &lt;li&gt;배포: CodeDeploy. Rolling Update 또는 Blue/Green 방식의 배포 지원함&lt;/li&gt;
  &lt;li&gt;파이프라인:  CodePipeline. CodeCommit, CodeBuild, CodeDeploy를 파이프라인으로 관리&lt;/li&gt;
  &lt;li&gt;Docker Registry: ECR(Elastic Container Registry)&lt;/li&gt;
  &lt;li&gt;애플리케이션 서버: ECS(Elastic Container Service) Fargate. Fargate는 ECS용 EC2가 없는 완전 관리형 컨테이너 서비스&lt;/li&gt;
  &lt;li&gt;알림: SNS(Simple Notification Service), Lambda를 활용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CI/CD 전체적인 아키텍처는 아래와 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자(개발자, 운영자 등) 개발한 코드를 CodeCommit에 반영합니다.&lt;/li&gt;
  &lt;li&gt;CodeCommit에서 코드 변화를 감지하고 CloudWathch를 통해 CodeBuild에 이벤트를 전달합니다.&lt;/li&gt;
  &lt;li&gt;CodeBuild에서 애플리케이션 빌드 및 패키징을, Docker 이미지를 빌드, 그리고 빌드한 이미지를 ECR에 Push합니다. Build가 완료되면 CodeDeploy로 이벤트를 전달합니다.&lt;/li&gt;
  &lt;li&gt;CodeDeploy에서 빌드된 이미지를 활용하여 ECS에 Rolling Update 또는 Blue/Green 방식으로 배포합니다.&lt;/li&gt;
  &lt;li&gt;CodePipeline의 대시보드를 활용해서 위 과정의 상태를 조회할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;CodeDeploy에 SNS, Lambda를 연동해서 Slack등의 Chat 서비스로 배포 과정을 전달할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/aws-cicd01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 &lt;a href=&quot;/blog/cloud/2019/06/20/aws-cicd02.html&quot;&gt;AWS에서 CI/CD 환경 구성 #2 - 형상 관리 구성, CodeCommit&lt;/a&gt;
문서에서 형상 관리 서비스인 CodeCommit을 구성하는 방법을 살펴보겠습니다.&lt;/p&gt;</content><author><name>윤상준</name></author><category term="aws" /><category term="cicd" /><category term="devops" /><category term="awscodecommit" /><category term="awscodebuild" /><category term="awscodedeploy" /><category term="awscodepipeline" /><category term="awsecs" /><category term="awsecr" /><category term="awssns" /><category term="awslambda" /><summary type="html">AWS에서 CI/CD 환경을 구성하는 방법을 알아보겠습니다.</summary></entry><entry><title type="html">Solidity Programming #8 제어문</title><link href="http://localhost:4000/blog/solidity/2018/11/14/solidity-programming-control.html" rel="alternate" type="text/html" title="Solidity Programming #8 제어문" /><published>2018-11-14T00:00:00+09:00</published><updated>2018-11-14T00:00:00+09:00</updated><id>http://localhost:4000/blog/solidity/2018/11/14/solidity-programming-control</id><content type="html" xml:base="http://localhost:4000/blog/solidity/2018/11/14/solidity-programming-control.html">&lt;p&gt;이 페이지에서는 Solidity의 제어문에 대해 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;Javascript의 &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt; 및 &lt;code class=&quot;highlighter-rouge&quot;&gt;goto&lt;/code&gt;를 제외한 대부분의 제어문을 Solidity에서 사용할 수 있습니다.
if, else, while, do, for, break, continue, return 등의 제어문을 지원합니다.&lt;/p&gt;

&lt;h2 id=&quot;조건문if&quot;&gt;조건문(if)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a = 3;

if(a &amp;gt; 1) {
  return &quot;a is greater than 1&quot;;
} else{
  return &quot;a is less than 1&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;주의 : bool 아닌 유형에 대해 유형 변환이 없기 때문에 if(1) {…}이 유효하지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;반복문while&quot;&gt;반복문(while)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int i = 0;
int sum = 0;

while(i&amp;lt;10){
    sum = sum + i;
    i++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;반복문for&quot;&gt;반복문(for)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int num = 5;

for(int i=0; i&amp;lt;10; i++){
    if(num % 2 == 0){
        return &quot;Even&quot;;
    } else{
        return &quot;Odd&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><category term="ethereum" /><category term="solidity" /><category term="smartcontract" /><summary type="html">이 페이지에서는 Solidity의 제어문에 대해 살펴보겠습니다.</summary></entry><entry><title type="html">Solidity Programming #7 가변성(Mutability)</title><link href="http://localhost:4000/blog/solidity/2018/11/13/solidity-programming-mutability.html" rel="alternate" type="text/html" title="Solidity Programming #7 가변성(Mutability)" /><published>2018-11-13T00:00:00+09:00</published><updated>2018-11-13T00:00:00+09:00</updated><id>http://localhost:4000/blog/solidity/2018/11/13/solidity-programming-mutability</id><content type="html" xml:base="http://localhost:4000/blog/solidity/2018/11/13/solidity-programming-mutability.html">&lt;p&gt;이 페이지에서는 Solidity의 함수 상태 가변성(Mutability)에 대해 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;함수의-상태-가변성&quot;&gt;함수의 상태 가변성&lt;/h2&gt;

&lt;p&gt;함수의 상태 가변성은 contract에 선언된 상태 변수를 함수에서 읽거나 쓸 수 있는지를 제어하기 위한 용도로 사용됩니다.&lt;/p&gt;

&lt;p&gt;먄약 함수의 상태 가변성을 위반한 경우가 있는 경우 컴파일 오류가 발생합니다.&lt;/p&gt;

&lt;p&gt;함수의 상태 가변성은 키워드는 아래와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;pure&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;payable&lt;/code&gt; 세 가지가 있습니다.
각 키워드별로 읽기, 쓰기와 송금에 대한 권한이 다르게 설정됩니다.
키워드를 설정하지 않으면 기본 값이 설정됩니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;상태 가변성&lt;/td&gt;
      &lt;td&gt;읽기&lt;/td&gt;
      &lt;td&gt;쓰기&lt;/td&gt;
      &lt;td&gt;송금&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pure&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;view&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;payable&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;기본&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;실제 예제를 통해서 어떤 방식으로 동작하는지 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;Contract &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;getData&lt;/code&gt; 함수에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 상태 변수의 값을 읽어와 결과 값으로 반환하는 기능을
수행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.4.24;

contract C {
    uint public data = 1;

    function getData() public pure returns(uint){
        return data;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수 내에서 상태 변수에 접근해 읽기 동작을 수행해야 하는데 읽기 동작 수행이 금지된 가변성 키워드 &lt;code class=&quot;highlighter-rouge&quot;&gt;pure&lt;/code&gt;를 사용하므로
아래 그림과 같은 컴파일 에러가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/solidity/mutability1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 키워드 &lt;code class=&quot;highlighter-rouge&quot;&gt;pure&lt;/code&gt;를 삭제하면 어떻게 될까요?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.4.24;

contract C {
    uint public data = 1;

    function getData() public returns(uint){
        return data;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;키워드를 설정하지 않았기 때문에 실제 함수 상태 가변성은 기본 값이 설정됩니다. 기본 값에서는 함수에서 상태 변수에
접근해 읽기 동작을 수행할 수 있으므로 컴파일 에러는 발생하지 않지만 경고 메세지가 출력되는 것을 볼 수 있습니다.
경고 메세지의 뜻은 함수의 상태 가변성을 &lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt;로 제한할 수 있다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/solidity/mutability2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;경고 메시지의 가이드에 따라 함수 상태 가변성 키워드를 &lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt;로 변경해주면 컴파일이나 경고 메세지가 출력되지 않는
것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.4.24;

contract C {
    uint public data = 1;

    function getData() public view returns(uint){
        return data;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><category term="ethereum" /><category term="solidity" /><category term="smartcontract" /><summary type="html">이 페이지에서는 Solidity의 함수 상태 가변성(Mutability)에 대해 살펴보겠습니다.</summary></entry><entry><title type="html">Solidity Programming #6 가시성(Visibility)</title><link href="http://localhost:4000/blog/solidity/2018/11/12/solidity-programming-visibility.html" rel="alternate" type="text/html" title="Solidity Programming #6 가시성(Visibility)" /><published>2018-11-12T00:00:00+09:00</published><updated>2018-11-12T00:00:00+09:00</updated><id>http://localhost:4000/blog/solidity/2018/11/12/solidity-programming-visibility</id><content type="html" xml:base="http://localhost:4000/blog/solidity/2018/11/12/solidity-programming-visibility.html">&lt;p&gt;이 페이지에서는 Solidity의 가시성(Visibility)에 대해 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;가시성visibility&quot;&gt;가시성(Visibility)&lt;/h2&gt;

&lt;p&gt;Solidity에는 두 가지의 함수 호출(function call)이 있습니다.
실제 EVM 호출을 만들지 않는 내부(internal) 함수 호출과 EVM 함수 호출을 만드는 외부(external) 함수 호출입니다.&lt;/p&gt;

&lt;h3 id=&quot;가시성의-종류&quot;&gt;가시성의 종류&lt;/h3&gt;

&lt;p&gt;함수와 상태 변수(state variables)는 아래와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;external&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;internal&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; 4가지로 선언할 수 있습니다.&lt;/p&gt;

&lt;p&gt;함수(function)의 기본 값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;상태 변수(state variables)는 &lt;code class=&quot;highlighter-rouge&quot;&gt;external&lt;/code&gt; 사용이 불가능하고 기본값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;internal&lt;/code&gt;입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;external: contract 외부에서만 호출 가능합니다.&lt;/li&gt;
  &lt;li&gt;public: contract 내부 및 외부애서 호출 가능합니다. 상태 변수를 public으로 선언하면 자동으로 getter 함수가 생성됩니다.&lt;/li&gt;
  &lt;li&gt;internal: contract 내부 및 상속받은 contract에서 호출 가능합니다.&lt;/li&gt;
  &lt;li&gt;private: contract 내부에서만 호출 가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
contract 내부의 모든 것은 외부에 노출됩니다. private으로 선언하여 다른 contract가 정보를 접근하고 수정하는 것을 막을 수는 있지만
여전히 전 세계의 블록체인(Block Chain)에서 볼 수 있습니다. Ethereum 환경에서 smart contract 개발은 실제 현금과
교환할 수 있는 암호화폐를 다루기 때문에 일반 애플리케이션을 개발할 때보다 더 주의해야한다는 것을 명심해야합니다.
&lt;/p&gt;

&lt;h3 id=&quot;practice&quot;&gt;Practice&lt;/h3&gt;

&lt;p&gt;가시성은 상태 변수의 자료형 뒤에 선언하고 함수의 매개 변수 및 반환 값 사이에 선언합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;

contract C {
    function f(uint a) private pure returns (uint b) { return a + 1; }
    function setData(uint a) internal { data = a; }
    uint public data;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 예제에서 contract &lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;으로 선언된 &lt;code class=&quot;highlighter-rouge&quot;&gt;c.getData()&lt;/code&gt; 함수를 호출해 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 상태 변수의 값을 가져올 수 있습니다.
하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;으로 선언된 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; 함수는 호출할 수 없습니다.&lt;/p&gt;

&lt;p&gt;Contract &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;를 상속받은 &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;internal&lt;/code&gt;로 선언된 &lt;code class=&quot;highlighter-rouge&quot;&gt;compute&lt;/code&gt; 함수를 호출할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;

contract C {
    uint private data;

    function f(uint a) private returns(uint b) { return a + 1; }
    function setData(uint a) public { data = a; }
    function getData() public returns(uint) { return data; }
    function compute(uint a, uint b) internal returns (uint) { return a+b; }
}

contract D {
    function readData() public {
        C c = new C();
        uint local = c.f(7); // error: member `f` is not visible
        c.setData(3);
        local = c.getData();
        local = c.compute(3, 5); // error: member `compute` is not visible
    }
}

contract E is C {
    function g() public {
        C c = new C();
        uint val = compute(3, 5); // access to internal member (from derived to parent contract)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;getter-함수&quot;&gt;Getter 함수&lt;/h2&gt;

&lt;p&gt;상태 변수를 &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;으로 선언하면 컴파일러가 자동으로 getter 함수를 생성합니다.&lt;/p&gt;

&lt;p&gt;아래 예제에서 컴파일러는 &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;으로 선언된 상태 변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;에 대한 getter 함수를 생성합니다.
getter 함수는 입력받는 매개변수가 없으며 반환 값으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;uint&lt;/code&gt; 형의 상태 변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;의 값을 반환합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.4.0;

contract C {
    uint public data = 42;

    //컴파일 시 내부적으로 생성되는 getter 함수.(실제 코드 상에는 존재하지 않음)
    function data() public returns(uint) {
      return data;
    }
}

contract Caller {
    C c = new C();

    function f() public {
        uint local = c.data();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;상태 변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;으로 선언했으므로 외부에서 접근할 수 있습니다.
만약 내부적으로(접근자 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 사용 안함) 접근하면 상태 변수로 간주되고, 외부적으로(접근자 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 사용) 접근하면 getter 함수로 간주됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.4.0;

contract C {
    uint public data;

    function x() public {
        data = 3; // 내부 접근
        uint val = this.data(); // 외부 접근
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><category term="ethereum" /><category term="solidity" /><category term="smartcontract" /><summary type="html">이 페이지에서는 Solidity의 가시성(Visibility)에 대해 살펴보겠습니다.</summary></entry><entry><title type="html">Solidity Programming #5 함수 호출</title><link href="http://localhost:4000/blog/solidity/2018/11/12/solidity-programming-function.html" rel="alternate" type="text/html" title="Solidity Programming #5 함수 호출" /><published>2018-11-12T00:00:00+09:00</published><updated>2018-11-12T00:00:00+09:00</updated><id>http://localhost:4000/blog/solidity/2018/11/12/solidity-programming-function</id><content type="html" xml:base="http://localhost:4000/blog/solidity/2018/11/12/solidity-programming-function.html">&lt;p&gt;이 페이지에서는 Solidity의 함수 호출(function call)에 대해 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;내부-함수-호출internal-function-call&quot;&gt;내부 함수 호출(internal function call)&lt;/h2&gt;

&lt;p&gt;Contract 내부에 있는 함수를 그대로 호출하는 경우를 내부 함수 호출이라하고 합니다.
내부 함수 호출은 EVM 호출을 만들지 않고 단순 점프로 변환됩니다. 이 때 함수의 매개변수는 EVM의 메모리에 저장됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;

contract C {
    function sum(uint x, uint y) public returns(uint) {
        return x + y;
    }

    function internalFunctionCall(uint x, uint y, uint z) public returns(uint) {
        //내부 함수 호출
        return sum(x, y) + z;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;외부-함수-호출external-function-call&quot;&gt;외부 함수 호출(external function call)&lt;/h2&gt;

&lt;p&gt;다른 contract의 함수를 호출하는 것을 외부 함수 호출이라하고 합니다.
또 같은 contract 내부의 함수라도 접근자 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;를 붙이면 외부 함수 호출로 처리됩니다.
외부 함수 호출은 EVM 함수 호출을 생성합니다. 이 때 함수의 매개변수는 EVM의 메모리가 아니라 콜 데이터 영역에 저장됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;

contract C {
    function sum(uint x, uint y) public returns(uint) {
        return x + y;
    }

    function externalFunctionCall(uint x, uint y, uint z) public returns(uint) {
        //외부 함수 호출
        return this.sum(x, y) + z;
    }
}

contract D {
    function externalFunctionCall(uint x, uint y, uint z) public returns(uint) {
        //외부 함수 호출
        C c = new C();
        return c.sum(x, y) + z;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
가시성이 public인 함수는 외부 및 내부 호출이 둘 다 가능합니다. 따라서 함수를 pulbic으로 선언하면
매개변수를 메모리로 복사하게 됩니다. 만약 매개변수의 데이터 크기가 크다면 메모리를 많이 사용하므로
이에 대한 비용 또한 많이 지불해야합니다. 따라서 외부에서만 호출하고 내부에서 호출하지 않는 함수라면
external로 선언하는 것이 좋습니다. 함수를 external로 선언하면 내부에서 호출이 불가능하므로 매개변수를
메모리에 복사하지 않습니다.
&lt;/p&gt;

&lt;p&gt;외부 함수 호출 시 &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;를 사용해 전송하는 이더 값을 설정할 수 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;gas&lt;/code&gt;를 사용해 사용할 가스를 설정할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;

contract C {
    function sum(uint x, uint y) public payable returns(uint) {
        return x + y;
    }
}

contract D {
    function externalFunctionCall(uint x, uint y, uint z) public returns(uint) {
        //외부 함수 호출
        C c = new C();
        return c.sum.value(10).gas(100)(x, y) + z;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><category term="ethereum" /><category term="solidity" /><category term="smartcontract" /><summary type="html">이 페이지에서는 Solidity의 함수 호출(function call)에 대해 살펴보겠습니다.</summary></entry><entry><title type="html">Solidity Programming #4 자료형</title><link href="http://localhost:4000/blog/solidity/2018/11/07/solidity-programming-type.html" rel="alternate" type="text/html" title="Solidity Programming #4 자료형" /><published>2018-11-07T00:00:00+09:00</published><updated>2018-11-07T00:00:00+09:00</updated><id>http://localhost:4000/blog/solidity/2018/11/07/solidity-programming-type</id><content type="html" xml:base="http://localhost:4000/blog/solidity/2018/11/07/solidity-programming-type.html">&lt;p&gt;이 페이지에서는 Solidity의 자료형 대해 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;값-타입value-types&quot;&gt;값 타입(Value Types)&lt;/h2&gt;

&lt;h3 id=&quot;부울boolean&quot;&gt;부울(Boolean)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;은 true와 false 두 가지 상수를 사용할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;연산자&quot;&gt;연산자&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;연산자&lt;/td&gt;
      &lt;td&gt;의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;not&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;and&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;or&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;not equal&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;연산자 &lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;short-circuiting&lt;/code&gt; 규칙이 적용됩니다.
예를 들어, f(x) || g(y) 연산에서 만약 f(x)가 참이면, g(y)는 실행되지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;practice&quot;&gt;Practice&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool a = true;
bool b = false;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;정수integers&quot;&gt;정수(Integers)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;는 부호가 있는 정수, &lt;code class=&quot;highlighter-rouge&quot;&gt;uint&lt;/code&gt;는 부호가 없는 정수에 사용합니다.&lt;/p&gt;

&lt;p&gt;uint8 ~ uint256는 부호 없는 8 ~ 256 비트 정수입니다.
uint 및 int는 각각 uint256 및 int256를 뜻합니다.&lt;/p&gt;

&lt;h4 id=&quot;연산자-1&quot;&gt;연산자&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;연산자&lt;/td&gt;
      &lt;td&gt;의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=, &amp;lt;, ==, !=, &amp;gt;=, &amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;비교 연산&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;, |, ^(xor), ~(not)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;비트 연산&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+, -, *, /, % , ** (제곱), &amp;lt;&amp;lt; (left shift), &amp;gt;&amp;gt; (right shift)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;산술 연산&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;0으로 나누거나 나머지를 계산하면 예외가 발생합니다.&lt;/p&gt;

&lt;h4 id=&quot;practice-1&quot;&gt;Practice&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a = 1;
int b = 2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;고정-소수점-수fixed-point-numbers&quot;&gt;고정 소수점 수(Fixed Point Numbers)&lt;/h3&gt;

&lt;p class=&quot;warning-title&quot;&gt;경고&lt;/p&gt;
&lt;p class=&quot;warning-content&quot;&gt;
Solidity는 고정 소수점 수를 아직 완벽하게 지원하지 않습니다.
고정 소수점 수를 선언할 수는 있지만 할당할 수는 없습니다.
&lt;/p&gt;

&lt;h3 id=&quot;주소address&quot;&gt;주소(Address)&lt;/h3&gt;

&lt;p&gt;주소는 20 바이트(이더리움 주소의 크기)를 보유합니다.
주소 유형은 멤버를 가지며 contract의 기반이 됩니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
Solidity 버전 0.5.0부터 contract는 주소 유형에서 파생되지 않지만 명시 적으로 주소로 변환 할 수 있습니다.
&lt;/p&gt;

&lt;h4 id=&quot;연산자-2&quot;&gt;연산자&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=, &amp;lt;, ==, !=, &amp;gt;= and &amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;멤버&quot;&gt;멤버&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;멤버&lt;/td&gt;
      &lt;td&gt;타입&lt;/td&gt;
      &lt;td&gt;의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;balance (uint256)&lt;/td&gt;
      &lt;td&gt;Property&lt;/td&gt;
      &lt;td&gt;Wei 단위의 주소의 잔고&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;transfer (uint256 amount)&lt;/td&gt;
      &lt;td&gt;Function&lt;/td&gt;
      &lt;td&gt;주소에 정해진 Wei를 보내고, 실패시에 예외를 발생시킴. 2300 개의 가스를 전달하고 조절할 수 없음.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;send(uint256 amount) returns (bool)&lt;/td&gt;
      &lt;td&gt;Function&lt;/td&gt;
      &lt;td&gt;주소에 정해진 Wei를 보내고, 실패시에 false를 반환함. 2300 개의 가스를 전달하고 조절할 수 없음.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;call(…) returns (bool)&lt;/td&gt;
      &lt;td&gt;Function&lt;/td&gt;
      &lt;td&gt;low-level의 CALL을 발생시키고 실패시에 false를 반환함. 가능한 모든 gas를 전달하고 조절 가능함.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;callcode(…) returns (bool)&lt;/td&gt;
      &lt;td&gt;Function&lt;/td&gt;
      &lt;td&gt;low-level의 CALLCODE를 발생시키고 실패시에 false를 반환함. 가능한 모든 gas를 전달하고 조절 가능함.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;delegatecall(…) returns (bool)&lt;/td&gt;
      &lt;td&gt;Function&lt;/td&gt;
      &lt;td&gt;low-level의 DELEGATECALL을 발생시키고 실패시에 false를 반환함. 가능한 모든 gas를 전달하고 조절 가능함.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;practice-2&quot;&gt;Practice&lt;/h4&gt;

&lt;p&gt;아래와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;balnace&lt;/code&gt; property를 활용하여 특정 주소의 잔고를 조회 할 수 있고,
&lt;code class=&quot;highlighter-rouge&quot;&gt;transfer&lt;/code&gt; 함수를 사용하여 ether를 특정 주소로 전송할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;address x = 0x123;
address myAddress = this;
if (x.balance &amp;lt; 10 &amp;amp;&amp;amp; myAddress.balance &amp;gt;= 10) x.transfer(10);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;고정-크기-배열fixed-size-byte-arrays&quot;&gt;고정 크기 배열(Fixed-size byte arrays)&lt;/h3&gt;

&lt;p&gt;고정 크기 배열에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes1, bytes2, bytes3, ..., bytes32&lt;/code&gt; 까지 32개의 타입이 있습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;byte&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes1&lt;/code&gt;과 동일합니다.&lt;/p&gt;

&lt;h4 id=&quot;연산자-3&quot;&gt;연산자&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;연산자&lt;/td&gt;
      &lt;td&gt;의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=, &amp;lt;, ==, !=, &amp;gt;=, &amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;비교 연산&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;, |, ^(xor), ~(not) &amp;lt;&amp;lt; (left shift), &amp;gt;&amp;gt; (right shift)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;비트 연산&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x[k]&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;인덱스 접근, x가 bytesI 배열인 경우, x[k]로 k번째 바이트에 접근 가능(read-only)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;멤버-1&quot;&gt;멤버&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;멤버&lt;/td&gt;
      &lt;td&gt;타입&lt;/td&gt;
      &lt;td&gt;의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;length&lt;/td&gt;
      &lt;td&gt;Property&lt;/td&gt;
      &lt;td&gt;바이트 배열의 고정 길이를 가져옴(read-only)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;practice-3&quot;&gt;Practice&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bytes1 b1 = &quot;a&quot;;
bytes4 b4 = &quot;abcd&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;이넘-타입enums&quot;&gt;이넘 타입(Enums)&lt;/h3&gt;

&lt;p&gt;0부터 6까지의 숫자를 입력받아 각각 월요일 부터 일요일까지의 요일을 반환하는 함수가 있다고 가정해보겠습니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 입력받은 값에 따라 요일을 반환하는 방식입니다.
이 때 입력받는 값을 비교할 때 숫자 0~6이 아니라 의미있는 값으로 변환하고 싶다면 이넘 타입을 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;

contract EnumTest {

    function returnDayInKorean(uint day) public view returns (string) {

        if(day == 0) {
            return &quot;월요일&quot;;

        } else if(day == 1) {
            return &quot;화요일&quot;;

        } else if(day == 2) {
            return &quot;수요일&quot;;

        } else if(day == 3) {
            return &quot;목요일&quot;;

        } else if(day == 4) {
            return &quot;금요일&quot;;

        } else if(day == 5) {
            return &quot;토요일&quot;;

        } else if(day == 6) {
            return &quot;일요일&quot;;

        }
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이넘 타입은 &lt;code class=&quot;highlighter-rouge&quot;&gt;enum&lt;/code&gt; 키워드를 사용하고 값은 일반적으로 대문자로 시작하도록 입력합니다.
이넘 타입에 입력한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Monday부터 Sunday&lt;/code&gt;값에는 순서대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;0부터 6&lt;/code&gt;까지의 값이 할당됩니다.
이넘 타입과 정수 타입간에는 서로 변환이 가능한데 변환 시에는 명시적으로 선언해줘야합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;이넘 타입 -&amp;gt; 정수 타입&lt;/code&gt;으로 변환은 &lt;code class=&quot;highlighter-rouge&quot;&gt;uint(Day.Monday)&lt;/code&gt; 방식으로 선언합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;정수 타입 -&amp;gt; 이넘 타입&lt;/code&gt;으로 변환은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Day(0)&lt;/code&gt; 방식으로 선언합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;

contract EnumTest {

    enum Day {
        Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
    }

    function returnDayInKorean(uint day) public view returns (string) {

        if(day == uint(Day.Monday)) {
            return &quot;월요일&quot;;

        } else if(Day(day) == Day.Tuesday) {
            return &quot;화요일&quot;;

        } else if(day == uint(Day.Wednesday)) {
            return &quot;수요일&quot;;

        } else if(day == uint(Day.Thursday)) {
            return &quot;목요일&quot;;

        } else if(day == uint(Day.Friday)) {
            return &quot;금요일&quot;;

        } else if(day == uint(Day.Saturday)) {
            return &quot;토요일&quot;;

        } else if(day == uint(Day.Sunday)) {
            return &quot;일요일&quot;;

        }
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참조-타입reference-types&quot;&gt;참조 타입(Reference Types)&lt;/h2&gt;

&lt;h3 id=&quot;배열arrays&quot;&gt;배열(Arrays)&lt;/h3&gt;

&lt;p&gt;배열에는 컴파일 시 크기가 결정되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;정적 배열&lt;/code&gt;과 프로그램 실행 시 동적으로 크기가 결정되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;동적 배열&lt;/code&gt;이 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;정적-배열static-array&quot;&gt;정적 배열(Static Array)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//선언
uint8[5] odd = [1, 3, 5, 7, 9];

//인덱싱. odd 배열의 두 번째 element에 접근
odd[1];

//element에 값 할당. odd 배열의 두 번째 element 값 변경
odd[1] = 2;

//배열의 크기 조회. odd 배열의 크기 조회
odd.length;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;동적-배열dynamic-array&quot;&gt;동적 배열(Dynamic Array)&lt;/h4&gt;

&lt;p&gt;동적 배열에는 스토리지 배열(Storage Array)과 메모리 배열(Memory Array)이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;동적 스토리지 배열(Dynamic Storage Array)&lt;/p&gt;

    &lt;p&gt;배열을 선언할 때 크기를 지정하지 않으면 동적 스토리지 배열로 생성됩니다. 동적 스토리지는 배열의 멤버인
  &lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;를 사용해서 크기를 조절할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //선언
  uint[] odd;

  //element에 값 할당. odd 배열의 첫 번째 element에 숫자 1 할당
  odd[0] = 1;
  odd.push(3);

  //인덱싱. odd 배열의 첫 번째 element에 접근
  odd[0];

  //배열의 크기 조회. odd 배열의 크기 조회
  odd.length;

  //배열의 크기 조절. odd 배열의 크기 조절
  odd.length = 5;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동적 메모리 배열(Dynamic Memory Array)&lt;/p&gt;

    &lt;p&gt;동적 메모리 배열은 키워드 &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;를 사용하여 생성합니다. 동적 스토리지 배열과 다르게 배열의 크기가
  한번 결정되면 변경할 수 없고, 멤버인 &lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;를 사용할 수 없습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //선언
  uint[] odd = new uint[](5);

  //element에 값 할당. odd 배열의 첫 번째 element에 숫자 1 할당
  odd[0] = 1;

  //인덱싱. odd 배열의 첫 번째 element에 접근
  odd[0];

  //배열의 크기 조회. odd 배열의 크기 조회
  odd.length;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동적 스토리지 배열(Storage Array)과 메모리 배열(Memory Array) 비교&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;항목&lt;/td&gt;
      &lt;td&gt;동적 스토리지 배열&lt;/td&gt;
      &lt;td&gt;동적 메모리 배열&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;push 사용&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;배열 크기 조회&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;배열 크기 조절&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;바이트-배열bytes&quot;&gt;바이트 배열(bytes)&lt;/h3&gt;

&lt;p&gt;데이터의 크기를 미리 알 수 없는 경우 바이트 배열 &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;을 사용하고 크기를 알고 있는 경우
고정 크기 배열(Fixed-size byte arrays)인 &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes1 ~ bytes32&lt;/code&gt; 중 하나를 사용하는 것이 좋습니다
&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes1 ~ bytes32&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt; 보다 자원을 덜 사용하기 때문입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//선언
bytes memory b = new bytes(10);

//element에 값 할당. b 배열의 첫 번째 element에 바이트 할당
b[0] = byte(65);

//인덱싱. b 배열의 첫 번째 element에 접근
b[0];

//배열의 크기 조회. b 배열의 크기 조회
b.length;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;문자열string&quot;&gt;문자열(String)&lt;/h3&gt;

&lt;p&gt;문자열은 &lt;code class=&quot;highlighter-rouge&quot;&gt;UTF-8&lt;/code&gt;로 인코딩된 문자열을 저장하기 위한 동적 크기 배열입니다.&lt;/p&gt;

&lt;p&gt;문자열은 바이트 배열(bytes)과 동일하지만 길이나 인덱스 접근을 허용하지 않습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string memory str = &quot;foo&quot;
string memory str = 'bar'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;매핑mappings&quot;&gt;매핑(Mappings)&lt;/h2&gt;

&lt;p&gt;매핑은 다른 프로그래밍 언어에서의 map 또는 dictionary와 같은 해시테이블(hash tables) 형태의 자료 구조입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mapping(KeyType =&amp;gt; ValueType)&lt;/code&gt;과 같은 형태로 선언하며 키 타입에는(KeyType)에는 매핑, 동적 크기 배열,
컨트랙트, 스트럭트, 이넘을 사용할 수 없습니다. 값 타입(ValueType)에는 모든 타입을 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;

contract MappingExample {
    mapping(address =&amp;gt; uint) public balances;

    function update(uint newBalance) public {
        balances[msg.sender] = newBalance;
    }
}

contract MappingUser {
    function f() public returns (uint) {
        MappingExample m = new MappingExample();
        m.update(100);
        return m.balances(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예제에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;balances&lt;/code&gt; 상태 변수를 매핑 타입으로 선언했습니다. 키 타입은 주소이고 값은 정수입니다.&lt;/p&gt;</content><author><name>윤상준</name></author><category term="ethereum" /><category term="solidity" /><category term="smartcontract" /><summary type="html">이 페이지에서는 Solidity의 자료형 대해 살펴보겠습니다.</summary></entry><entry><title type="html">Solidity Programming #3 Contract의 구조</title><link href="http://localhost:4000/blog/solidity/2018/11/07/solidity-programming-contract.html" rel="alternate" type="text/html" title="Solidity Programming #3 Contract의 구조" /><published>2018-11-07T00:00:00+09:00</published><updated>2018-11-07T00:00:00+09:00</updated><id>http://localhost:4000/blog/solidity/2018/11/07/solidity-programming-contract</id><content type="html" xml:base="http://localhost:4000/blog/solidity/2018/11/07/solidity-programming-contract.html">&lt;p&gt;이 페이지에서는 Solidity의 Contract의 구조에 대해 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;Solidity에서 contract는 객체 지향(object-oriented) 언어의 클래스(Class)와 유사합니다.
각각의 contract는 상태 변수(state variables), 함수(function), 이벤트(events), 구조체(structure)를 포함할 수 있습니다.
또한 contract는 다른 contract를 상속받을 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;상태-변수state-variables&quot;&gt;상태 변수(state variables)&lt;/h2&gt;

&lt;p&gt;상태 변수는 contract의 저장소(Storage)에 영구적으로 저장되는 값입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;

contract SimpleStorage {
    uint storedData; // 상태 변수
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;상태 변수의 유형에 대한 내용은 &lt;a href=&quot;/blog/solidity/2018/11/07/solidity-programming-type.html&quot;&gt;자료형&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;p&gt;상태 변수의 &lt;a href=&quot;/blog/solidity/2018/11/12/solidity-programming-visibility.html&quot;&gt;가시성&lt;/a&gt;은 상태 변수에 대한 접근을 제어하는 용도로 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;함수function&quot;&gt;함수(function)&lt;/h2&gt;

&lt;p&gt;함수는 contract 내에서 실행 가능한 코드 단위입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;

contract SimpleAuction {
    function bid() public payable { // 함수
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Solidity에서 &lt;a href=&quot;/blog/solidity/2018/11/12/solidity-programming-function.html&quot;&gt;함수 호출&lt;/a&gt; 방식은 내부 호출(internal function call)과 외부 호출(external function call)이 있습니다.&lt;/p&gt;

&lt;p&gt;함수의 &lt;a href=&quot;/blog/solidity/2018/11/12/solidity-programming-visibility.html&quot;&gt;가시성&lt;/a&gt;은 함수에 대한 접근을 제어하는 용도로 사용합니다.&lt;/p&gt;

&lt;p&gt;함수의 &lt;a href=&quot;/blog/solidity/2018/11/13/solidity-programming-mutability.html&quot;&gt;가변성&lt;/a&gt;은 함수에서 contract에 정의된 상태 변수에 접근하는 것을 제어하는 용도로 사용합니다.&lt;/p&gt;</content><author><name>윤상준</name></author><category term="ethereum" /><category term="solidity" /><category term="smartcontract" /><summary type="html">이 페이지에서는 Solidity의 Contract의 구조에 대해 살펴보겠습니다.</summary></entry><entry><title type="html">Solidity Programming #2 소스코드 레이아웃</title><link href="http://localhost:4000/blog/solidity/2018/11/06/solidity-programming-layout.html" rel="alternate" type="text/html" title="Solidity Programming #2 소스코드 레이아웃" /><published>2018-11-06T00:00:00+09:00</published><updated>2018-11-06T00:00:00+09:00</updated><id>http://localhost:4000/blog/solidity/2018/11/06/solidity-programming-layout</id><content type="html" xml:base="http://localhost:4000/blog/solidity/2018/11/06/solidity-programming-layout.html">&lt;p&gt;이 페이지에서는 Solidity 소스코드의 레이아웃에 대해 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;version-pragma&quot;&gt;Version Pragma&lt;/h2&gt;

&lt;p&gt;소스코드가 호환되지 않는 버전으로 컴파일되는 것을 방지하기 위해 Version Pragma를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 컴파일러의 버전을 선언해 특정 버전으로 컴파일 되도록 설정할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;file-import&quot;&gt;File import&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;동일 환경의 file import&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import &quot;./filename.sol&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;원격 경로의 file import&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import &quot;github.com/xxx/filename.sol&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;comments&quot;&gt;Comments&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Single line&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// This is a single-line comment.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Multi line&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
This is a
multi-line comment.
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Documentation&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.x.x;

/** @title Shape calculator. */
contract shapeCalculator {
    /** @dev Calculates a rectangle's surface and perimeter.
      * @param w Width of the rectangle.
      * @param h Height of the rectangle.
      * @return s The calculated surface.
      * @return p The calculated perimeter.
      */
    function rectangle(uint w, uint h) returns (uint s, uint p) {
        s = w * h;
        p = 2 * (w + h);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>윤상준</name></author><category term="ethereum" /><category term="solidity" /><category term="smartcontract" /><summary type="html">이 페이지에서는 Solidity 소스코드의 레이아웃에 대해 살펴보겠습니다.</summary></entry><entry><title type="html">Solidity Programming #1 Getting started</title><link href="http://localhost:4000/blog/solidity/2018/11/06/solidity-programming-getting-started.html" rel="alternate" type="text/html" title="Solidity Programming #1 Getting started" /><published>2018-11-06T00:00:00+09:00</published><updated>2018-11-06T00:00:00+09:00</updated><id>http://localhost:4000/blog/solidity/2018/11/06/solidity-programming-getting-started</id><content type="html" xml:base="http://localhost:4000/blog/solidity/2018/11/06/solidity-programming-getting-started.html">&lt;p&gt;Solidity는 Ethereum 환경에서 Smart Contract를 프로그래밍하는데 사용하는 언어 중 하나입니다.&lt;/p&gt;

&lt;p&gt;이 페이지에서는 Solidity 언어로 Hello world를 출력하는 Smart Contract를 작성해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;solidity-ide-실행&quot;&gt;Solidity IDE 실행&lt;/h2&gt;

&lt;p&gt;Ethereum에서는 Solidity 프로그래밍을 하기 위한 개발환경으로 Web IDE를 제공합니다.&lt;/p&gt;

&lt;p&gt;웹 브라우저에서 &lt;a href=&quot;http://remix.ethereum.org&quot;&gt;Solidity IDE&lt;/a&gt;를 접속합니다.&lt;/p&gt;

&lt;h2 id=&quot;컴파일러-버전-선택&quot;&gt;컴파일러 버전 선택&lt;/h2&gt;

&lt;p&gt;IDE 오른쪽 &amp;gt; Compile 탭에서 컴파일러 버전을 선택합니다.&lt;/p&gt;

&lt;p&gt;이 페이지에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;0.4.24&lt;/code&gt; 버전을 선택하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/solidity/select-compiler-version.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;실행-환경-선택&quot;&gt;실행 환경 선택&lt;/h2&gt;

&lt;p&gt;IDE 오른쪽 &amp;gt; Run 탭에서 실행 환경을 선택합니다.&lt;/p&gt;

&lt;p&gt;일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Javascript VM&lt;/code&gt;을 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/solidity/select-running-environment.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;파일-생성&quot;&gt;파일 생성&lt;/h2&gt;

&lt;p&gt;화면 상단의 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/solidity/create-file1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파일명을 입력하고 OK 버튼을 선택해 파일을 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/solidity/create-file2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;smart-contract-작성&quot;&gt;Smart Contract 작성&lt;/h2&gt;

&lt;p&gt;아래와 같이 Hello world를 출력하는 Smart Contract를 작성합니다.&lt;/p&gt;

&lt;p&gt;컴파일러 버전은 위에서 선택한 &lt;code class=&quot;highlighter-rouge&quot;&gt;0.4.24&lt;/code&gt; 버전을 선언합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity ^0.4.24;

contract HelloWorld {

    function printHello() returns (string) {

        return &quot;Hello world&quot;;

    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문법을 자세히 보면 Javascript와 유사한 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;문법에 대한 상세한 내용은 추후 자세히 다루겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;smart-contract-배포-및-실행&quot;&gt;Smart Contract 배포 및 실행&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl + s&lt;/code&gt;로 파일을 저장한 후 오른쪽 Run 탭을 확인해보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello World&lt;/code&gt; Smart Contract가 생성
된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/solidity/deploy-smart-contract.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Deploy&lt;/code&gt;를 선택하면 Smart Contract가 배포됩니다.&lt;/p&gt;

&lt;p&gt;하단의 콘솔 로그를 확인하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello world&lt;/code&gt; 문자열이 출력된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/solidity/console-log.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>윤상준</name></author><category term="ethereum" /><category term="geth" /><category term="smartcontract" /><category term="dapp" /><category term="mining" /><summary type="html">Solidity는 Ethereum 환경에서 Smart Contract를 프로그래밍하는데 사용하는 언어 중 하나입니다.</summary></entry></feed>