<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.0">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2019-08-12T01:22:17+09:00</updated><id>http://localhost:4000/blog/</id><title type="html">윤상준의 기술 블로그</title><subtitle>Software &amp; Cloud Engineer 입니다. Kubernetes, Cloud Foundry등의 PaaS와 Cloud 및 DevOps 관련 기술에 관심이 있습니다.</subtitle><author><name>Yun SangJun</name></author><entry><title type="html">Istio를 활용해 Multi Cluster 환경에 Service Mesh 구성하기</title><link href="http://localhost:4000/blog/istio/2019/08/11/istio-multi-cluster-mesh.html" rel="alternate" type="text/html" title="Istio를 활용해 Multi Cluster 환경에 Service Mesh 구성하기" /><published>2019-08-11T00:00:00+09:00</published><updated>2019-08-11T00:00:00+09:00</updated><id>http://localhost:4000/blog/istio/2019/08/11/istio-multi-cluster-mesh</id><content type="html" xml:base="http://localhost:4000/blog/istio/2019/08/11/istio-multi-cluster-mesh.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Istio를 활용하여 여러개의 Kubernetes Cluster 환경에 Service Mesh를 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;인프라 및 Kubernetes Cluster 환경에 따라 3가지 구성 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 1번 방법을 활용하여 Service Mesh를 구성해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://istio.io/docs/setup/kubernetes/install/multicluster/shared-gateways/&quot;&gt;Shared control plane (multi-network)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;이 방법은 여러개의 Cluster가 하나의 Istio Control Plane을 공유합니다.
 Istio Gateway를 통해 Cluster간 통신하므로 각 Cluster의 네트워크가 분리되어 있고 VPN 또는 Direct 네트워크로 연결되어 있지 않아도 됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/istio/istio-shared-multi.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://istio.io/docs/setup/kubernetes/install/multicluster/shared-vpn/&quot;&gt;Shared control plane (single-network)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;1번과 마찬가지로 여러개의 Cluster가 하나의 Istio Control Plane을 공유합니다.
 별도의 Gateway가 없기 때문에 각 Cluster의 네트워크가 VPN 등을 통해 연결성이 있어야합니다.
 각 Cluster의 네트워크에서 Pod와 Service의 CIDR은 중복되서는 안되고 서로간의 라우팅이 가능해야합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/istio/istio-shared-single.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://istio.io/docs/setup/kubernetes/install/multicluster/gateways/&quot;&gt;Multiple control planes&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;1번과 마찬가지로 Istio Gateway를 통해 Cluster간 통신을 하지만 Istio Control Plance을 공유하지 않고 각각의 Cluster에 설치합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/istio/istio-multiple-multi.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;준비하기&quot;&gt;준비하기&lt;/h2&gt;

&lt;h3 id=&quot;kubernetes-cluster-준비&quot;&gt;Kubernetes Cluster 준비&lt;/h3&gt;

&lt;p&gt;1.12, 1.13, 1.14 버전의 Kubernetes Cluster를 2개 이상 준비합니다.
이 문서에서는 1.12 버전의 2개의 Cluster를 활용하겠습니다.&lt;/p&gt;

&lt;p&gt;편의상 2개의 Cluster를 아래와 같이 환경 변수로 설정합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl config get-contexts
CURRENT   NAME       CLUSTER    AUTHINFO       NAMESPACE
*         cluster1   cluster1   user@foo.com   default
          cluster2   cluster2   user@foo.com   default

$ export CTX_CLUSTER1=$(kubectl config view -o jsonpath='{.contexts[0].name}')
$ export CTX_CLUSTER2=$(kubectl config view -o jsonpath='{.contexts[1].name}')
$ echo CTX_CLUSTER1 = ${CTX_CLUSTER1}, CTX_CLUSTER2 = ${CTX_CLUSTER2}
CTX_CLUSTER1 = cluster1, CTX_CLUSTER2 = cluster2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;istio-다운로드&quot;&gt;Istio 다운로드&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/istio/istio/releases&quot;&gt;Istio Release&lt;/a&gt; 페이지에서 원하는 버전을 다운로드합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -L https://git.io/getLatestIstio | ISTIO_VERSION=x.x.x sh -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;platform-설정&quot;&gt;Platform 설정&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://istio.io/docs/setup/kubernetes/platform-setup/&quot;&gt;platform-specific setup&lt;/a&gt; 페이지를 참고하여 각 클라우드별로
필요한 설정을합니다.&lt;/p&gt;

&lt;h3 id=&quot;helm-설치&quot;&gt;Helm 설치&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/blog/helm/2018/05/27/installing-helm.html&quot;&gt;Helm 설치하기&lt;/a&gt; 문서를 참고하여 Helm Client를 설치합니다.&lt;/p&gt;

&lt;h2 id=&quot;multi-cluster에-service-mesh-구성하기&quot;&gt;Multi Cluster에 Service Mesh 구성하기&lt;/h2&gt;

&lt;h3 id=&quot;primary-cluster-설정&quot;&gt;Primary Cluster 설정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster의 Istio deployment yaml 생성합니다.&lt;/p&gt;

    &lt;p&gt;위에서 다운로드 받은 Istio 디렉토리로 이동합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ cd istio-x.x.x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;helm template 기능을 사용하여 istio deployment yaml 파일을 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ helm template --name=istio --namespace=istio-system \
 --set global.mtls.enabled=true \
 --set security.selfSigned=false \
 --set global.controlPlaneSecurityEnabled=true \
 --set global.proxy.accessLogFile=&quot;/dev/stdout&quot; \
 --set global.meshExpansion.enabled=true \
 --set 'global.meshNetworks.network1.endpoints[0].fromRegistry'=Kubernetes \
 --set 'global.meshNetworks.network1.gateways[0].address'=0.0.0.0 \
 --set 'global.meshNetworks.network1.gateways[0].port'=443 \
 --set gateways.istio-ingressgateway.env.ISTIO_META_NETWORK=&quot;network1&quot; \
 --set global.network=&quot;network1&quot; \
 --set 'global.meshNetworks.network2.endpoints[0].fromRegistry'=n2-k8s-config \
 --set 'global.meshNetworks.network2.gateways[0].address'=0.0.0.0 \
 --set 'global.meshNetworks.network2.gateways[0].port'=443 \
 install/kubernetes/helm/istio &amp;gt; istio-auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster에 Istio를 설치합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER1 ns istio-system
 $ kubectl create --context=$CTX_CLUSTER1 secret generic cacerts -n istio-system --from-file=samples/certs/ca-cert.pem --from-file=samples/certs/ca-key.pem --from-file=samples/certs/root-cert.pem --from-file=samples/certs/cert-chain.pem
 $ for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply --context=$CTX_CLUSTER1 -f $i; done
 $ kubectl apply --context=$CTX_CLUSTER1 -f istio-auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;아래와 같이 모든 Pod의 Running 상태가 될 때까지 기다립니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get pods --context=$CTX_CLUSTER1 -n istio-system
 NAME                                      READY   STATUS      RESTARTS   AGE
 istio-citadel-9bbf9b4c8-nnmbt             1/1     Running     0          2m8s
 istio-cleanup-secrets-1.1.0-x9crw         0/1     Completed   0          2m12s
 istio-galley-868c5fff5d-9ph6l             1/1     Running     0          2m9s
 istio-ingressgateway-6c756547b-dwc78      1/1     Running     0          2m8s
 istio-pilot-54fcf8db8-sn9cn               2/2     Running     0          2m8s
 istio-policy-5fcbd55d8b-xhbpz             2/2     Running     2          2m8s
 istio-security-post-install-1.1.0-ww5zz   0/1     Completed   0          2m12s
 istio-sidecar-injector-6dcc9d5c64-7hnnl   1/1     Running     0          2m8s
 istio-telemetry-57875ffb6d-n2vmf          2/2     Running     3          2m8s
 prometheus-66c9f5694-8pccr                1/1     Running     0          2m8s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ingress Gateway를 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl apply --context=$CTX_CLUSTER1 -f - &amp;lt;&amp;lt;EOF
 apiVersion: networking.istio.io/v1alpha3
 kind: Gateway
 metadata:
 name: cluster-aware-gateway
 namespace: istio-system
 spec:
 selector:
     istio: ingressgateway
 servers:
 - port:
     number: 443
     name: tls
     protocol: TLS
     tls:
     mode: AUTO_PASSTHROUGH
     hosts:
     - &quot;*.local&quot;
 EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster의 Ingress IP와 Port를 확인합니다.&lt;/p&gt;

    &lt;p&gt;Primary Cluster에서 Ingress Gateway의 Service를 조회합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl config use-context $CTX_CLUSTER1
 $ kubectl get svc istio-ingressgateway -n istio-system
 NAME                   TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)                                      AGE
 istio-ingressgateway   LoadBalancer   172.x.x.1        130.x.x.1       80:31380/TCP,443:31390/TCP,31400:31400/TCP   17h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Ingress의 Host 주소와 Secure port를 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ export INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
 $ export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==&quot;https&quot;)].port}')
 $ echo The ingress gateway of cluster1: address=$INGRESS_HOST, port=$SECURE_INGRESS_PORT
 130.x.x.1, 443
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Istio Configmap의 mesh nework 설정에서 gateway 주소를 위에서 조회한 Ingress 정보로 변경합니다.&lt;/p&gt;

    &lt;p&gt;data.mesh.meshNetworks.networks.network1.address를 0.0.0.0에서 INGRESS_HOST로 변경합니다.
 data.mesh.meshNetworks.networks.network1.port를 443에서 SECURE_INGRESS_PORT 변경합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl edit cm -n istio-system --context=$CTX_CLUSTER1 istio
 apiVersion: v1
 data:
     mesh:
     ...
         meshNetworks: &quot;networks:\n  network1:\n    endpoints:\n    - fromRegistry: Kubernetes\n
     \   gateways:\n    - address: 0.0.0.0\n      port: 443\n  ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;second-cluster-설정&quot;&gt;Second Cluster 설정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster의 Ingress Gateway 주소를 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ export LOCAL_GW_ADDR=$(kubectl get --context=$CTX_CLUSTER1 svc --selector=app=istio-ingressgateway \
 -n istio-system -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}') &amp;amp;&amp;amp; echo ${LOCAL_GW_ADDR}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Second Cluster의 Istio deployment yaml 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ helm template --name istio-remote --namespace=istio-system \
 --values install/kubernetes/helm/istio/values-istio-remote.yaml \
 --set global.mtls.enabled=true \
 --set gateways.enabled=true \
 --set security.selfSigned=false \
 --set global.controlPlaneSecurityEnabled=true \
 --set global.createRemoteSvcEndpoints=true \
 --set global.remotePilotCreateSvcEndpoint=true \
 --set global.remotePilotAddress=${LOCAL_GW_ADDR} \
 --set global.remotePolicyAddress=${LOCAL_GW_ADDR} \
 --set global.remoteTelemetryAddress=${LOCAL_GW_ADDR} \
 --set gateways.istio-ingressgateway.env.ISTIO_META_NETWORK=&quot;network2&quot; \
 --set global.network=&quot;network2&quot; \
 install/kubernetes/helm/istio &amp;gt; istio-remote-auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Second Cluster에 Istio를 설치합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER2 ns istio-system
 $ kubectl create --context=$CTX_CLUSTER2 secret generic cacerts -n istio-system --from-file=samples/certs/ca-cert.pem --from-file=samples/certs/ca-key.pem --from-file=samples/certs/root-cert.pem --from-file=samples/certs/cert-chain.pem
 $ kubectl apply --context=$CTX_CLUSTER2 -f istio-remote-auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Istio의 모든 Pod가 Running 상태가 될때까지 기다립니다. 
 Primary Cluster와 다르게 일부 컴포넌트만 설치됩니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get pods --context=$CTX_CLUSTER2 -n istio-system -l istio!=ingressgateway
 NAME                                     READY   STATUS      RESTARTS   AGE
 istio-citadel-75c8fcbfcf-9njn6           1/1     Running     0          12s
 istio-cleanup-secrets-1.1.0-vtp62        0/1     Completed   0          14s
 istio-sidecar-injector-cdb5d4dd5-rhks9   1/1     Running     0          12s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Second Cluster의 Ingress IP와 Port를 확인합니다.&lt;/p&gt;

    &lt;p&gt;Second Cluster에서 Ingress Gateway의 Service를 조회합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl config use-context $CTX_CLUSTER2
 $ kubectl get svc istio-ingressgateway -n istio-system
 NAME                   TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)                                      AGE
 istio-ingressgateway   LoadBalancer   172.x.x.2        130.x.x.2       80:31380/TCP,443:31390/TCP,31400:31400/TCP   17h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Ingress의 Host 주소와 Secure port를 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ export INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
 $ export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==&quot;https&quot;)].port}')
 $ echo The ingress gateway of cluster2: address=$INGRESS_HOST, port=$SECURE_INGRESS_PORT
 130.x.x.2, 443
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Istio Configmap의 mesh nework 설정에서 gateway 주소를 위에서 조회한 Ingress 정보로 변경합니다.&lt;/p&gt;

    &lt;p&gt;data.mesh.meshNetworks.networks.network2.address를 0.0.0.0에서 INGRESS_HOST로 변경합니다.
 data.mesh.meshNetworks.networks.network2.port를 443에서 SECURE_INGRESS_PORT 변경합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl edit cm -n istio-system --context=$CTX_CLUSTER2 istio
 apiVersion: v1
 data:
     mesh:
     ...
     meshNetworks: &quot;networks:\n  network1:\n    endpoints:\n    - fromRegistry: Kubernetes\n
         \   gateways:\n    - address: 0.0.0.0\n      port: 443\n  network2:\n    endpoints:\n
         \   - fromRegistry: n2-k8s-config\n    gateways:\n    - address: 0.0.0.0\n
         \     port: 443\n  &quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;n2-k8s-config 설정 파일을 생성하기 위한 환경 변수를 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ CLUSTER_NAME=$(kubectl --context=$CTX_CLUSTER2 config view --minify=true -o jsonpath='{.clusters[].name}')
 $ SERVER=$(kubectl --context=$CTX_CLUSTER2 config view --minify=true -o jsonpath='{.clusters[].cluster.server}')
 $ SECRET_NAME=$(kubectl --context=$CTX_CLUSTER2 get sa istio-multi -n istio-system -o jsonpath='{.secrets[].name}')
 $ CA_DATA=$(kubectl get --context=$CTX_CLUSTER2 secret ${SECRET_NAME} -n istio-system -o jsonpath=&quot;{.data['ca\.crt']}&quot;)
 $ TOKEN=$(kubectl get --context=$CTX_CLUSTER2 secret ${SECRET_NAME} -n istio-system -o jsonpath=&quot;{.data['token']}&quot; | base64 --decode)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;n2-k8s-config 파일을 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ cat &amp;lt;&amp;lt;EOF &amp;gt; n2-k8s-config
 apiVersion: v1
 kind: Config
 clusters:
 - cluster:
     certificate-authority-data: ${CA_DATA}
     server: ${SERVER}
     name: ${CLUSTER_NAME}
 contexts:
 - context:
     cluster: ${CLUSTER_NAME}
     user: ${CLUSTER_NAME}
     name: ${CLUSTER_NAME}
 current-context: ${CLUSTER_NAME}
 users:
 - name: ${CLUSTER_NAME}
     user:
     token: ${TOKEN}
 EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;primary-cluster와-second-cluster-동기화&quot;&gt;Primary Cluster와 Second Cluster 동기화&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster에서 Second Cluster를 동기화합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER1 secret generic n2-k8s-secret --from-file n2-k8s-config -n istio-system
 $ kubectl label --context=$CTX_CLUSTER1 secret n2-k8s-secret istio/multiCluster=true -n istio-system
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Second Cluster의 Ingress Gateway가 Running 상태가 될때까지 기다립니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get pods --context=$CTX_CLUSTER2 -n istio-system -l istio=ingressgateway
 NAME                                    READY     STATUS    RESTARTS   AGE
 istio-ingressgateway-5c667f4f84-bscff   1/1       Running   0          16m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 Primary Cluster와 Seconde Cluster가 Service Mesh로 구성되었습니다.&lt;/p&gt;

&lt;p&gt;다음으로 샘플 서비스를 배포하여 2개의 Cluster에서 Service Mesh가 어떻게 동작하는지 확인해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;샘플-서비스-배포하기&quot;&gt;샘플 서비스 배포하기&lt;/h2&gt;

&lt;p&gt;Overview의 구성도와 같이 helloworld 애플리케이션을 Primary와 Second 클러스터에 각각 배포할것입니다.&lt;/p&gt;

&lt;p&gt;각각의 인스턴스는 동일한 애플리케이션이지만 이미지의 버전이 v1, v2로 다릅니다.&lt;/p&gt;

&lt;h3 id=&quot;second-cluster에-helloworld-v2-버전-배포&quot;&gt;Second Cluster에 helloworld v2 버전 배포&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sample namespace를 생성하고 istio proxy가 자동으로 injection 되도록 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER2 ns sample
 $ kubectl label --context=$CTX_CLUSTER2 namespace sample istio-injection=enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;helloworld v2를 배포합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER2 -f samples/helloworld/helloworld.yaml -l app=helloworld -n sample
 $ kubectl create --context=$CTX_CLUSTER2 -f samples/helloworld/helloworld.yaml -l version=v2 -n sample
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;helloworld v2가 Running 상태가 될때까지 기다립니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get po --context=$CTX_CLUSTER2 -n sample
 NAME                             READY     STATUS    RESTARTS   AGE
 helloworld-v2-7dd57c44c4-f56gq   2/2       Running   0          35s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;primary-cluster에-helloworld-v1-버전-배포&quot;&gt;Primary Cluster에 helloworld v1 버전 배포&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sample namespace를 생성하고 istio proxy가 자동으로 injection 되도록 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER1 ns sample
 $ kubectl label --context=$CTX_CLUSTER1 namespace sample istio-injection=enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;helloworld v1을 배포합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER1 -f samples/helloworld/helloworld.yaml -l app=helloworld -n sample
 $ kubectl create --context=$CTX_CLUSTER1 -f samples/helloworld/helloworld.yaml -l version=v1 -n sample
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;helloworld v1이 Running 상태가 될때까지 기다립니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get po --context=$CTX_CLUSTER1 -n sample
 NAME                            READY     STATUS    RESTARTS   AGE
 helloworld-v1-d4557d97b-pv2hr   2/2       Running   0          40s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;cluster간-트래픽-흐름-확인&quot;&gt;Cluster간 트래픽 흐름 확인&lt;/h3&gt;

&lt;p&gt;2개의 Cluster에서 트래픽을 확인하기 위해 sleep 애플리케이션에서 helloworld 애플리케이션을 호출해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sleep 애플리케이션을 2개의 Cluster에 배포하고 Running 상태가 될때까지 기다립니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl apply --context=$CTX_CLUSTER1 -f samples/sleep/sleep.yaml -n sample
 $ kubectl apply --context=$CTX_CLUSTER2 -f samples/sleep/sleep.yaml -n sample
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster에서 helloworld를 여러번 호출합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl exec --context=$CTX_CLUSTER1 -it -n sample -c sleep $(kubectl get pod --context=$CTX_CLUSTER1 -n sample -l app=sleep -o jsonpath='{.items[0].metadata.name}') -- curl helloworld.sample:5000/hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;각 클러스터의 v1, v2 버전이 번갈아가면서 호출되는 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Hello version: v2, instance: helloworld-v2-758dd55874-6x4t8
 Hello version: v1, instance: helloworld-v1-86f77cd7bd-cpxhv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Primary Cluster의 sleep pod의 istio-proxy 컨테이너의 로그를 조회해봅니다.
 한번은 Second Cluster의 Gateway를 통하여 Second Cluster에 있는 helloworld v2가 호출되었고
 다른 한번은 같은 Cluster의 helloworld v1이 호출되었습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl logs --context=$CTX_CLUSTER1 -n sample $(kubectl get pod --context=$CTX_CLUSTER1 -n sample -l app=sleep -o jsonpath='{.items[0].metadata.name}') istio-proxy
 [2018-11-25T12:37:52.077Z] &quot;GET /hello HTTP/1.1&quot; 200 - 0 60 190 189 &quot;-&quot; &quot;curl/7.60.0&quot; &quot;6e096efe-f550-4dfa-8c8c-ba164baf4679&quot; &quot;helloworld.sample:5000&quot; &quot;130.x.x.2:15443&quot; outbound|5000||helloworld.sample.svc.cluster.local - 10.20.194.146:5000 10.10.0.89:59496 -
 [2018-11-25T12:38:06.745Z] &quot;GET /hello HTTP/1.1&quot; 200 - 0 60 171 170 &quot;-&quot; &quot;curl/7.60.0&quot; &quot;6f93c9cc-d32a-4878-b56a-086a740045d2&quot; &quot;helloworld.sample:5000&quot; &quot;10.10.0.90:5000&quot; outbound|5000||helloworld.sample.svc.cluster.local - 10.20.194.146:5000 10.10.0.89:59646 -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;지금까지 살펴본 내용을 보면 Istio의 Service Mesh 구성을 통해 서로 다른 네트워크에 구성한 Cluster에서 실행중인 서비스간의 통신이
가능하다는 것을 확인할 수 있었습니다.&lt;/p&gt;</content><author><name>윤상준</name></author><category term="istio" /><category term="servicemesh" /><category term="multicluster" /><category term="kubernetes" /><summary type="html">Overview</summary></entry><entry><title type="html">Jenkins CI를 활용한 지속적인 소스코드 통합 환경 구성하기</title><link href="http://localhost:4000/blog/cicd/2019/08/04/jenkinsci.html" rel="alternate" type="text/html" title="Jenkins CI를 활용한 지속적인 소스코드 통합 환경 구성하기" /><published>2019-08-04T00:00:00+09:00</published><updated>2019-08-04T00:00:00+09:00</updated><id>http://localhost:4000/blog/cicd/2019/08/04/jenkinsci</id><content type="html" xml:base="http://localhost:4000/blog/cicd/2019/08/04/jenkinsci.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;소스코드를 지속적으로 통합하기 위해서 TravisCI, CircleCI, Jenkins 등 다양한 툴을 활용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 Jenkins CI를 활용하여 소스코드를 지속적으로 통합하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;Jenkins CI와 아래 서비스를 통합하여 CI 환경을 구성해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소스코드 저장소: Github&lt;/li&gt;
  &lt;li&gt;이미지 저장소: Docker Hub&lt;/li&gt;
  &lt;li&gt;통합(CI): Jenkins&lt;/li&gt;
  &lt;li&gt;애플리케이션 서버: Kubernetes&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;h3 id=&quot;소스코드-다운로드&quot;&gt;소스코드 다운로드&lt;/h3&gt;

&lt;p&gt;이 문서에서 사용할 &lt;a href=&quot;https://github.com/YunSangJun/jenkinsci-demo.git&quot;&gt;jenkinsci-demo&lt;/a&gt; 프로젝트를 복사합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/YunSangJun/jenkinsci-demo.git
cd jenkinsci-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;소스코드-저장소&quot;&gt;소스코드 저장소&lt;/h3&gt;

&lt;p&gt;Github에 sample-app 저장소를 생성합니다.&lt;/p&gt;

&lt;h3 id=&quot;이미지-저장소-준비&quot;&gt;이미지 저장소 준비&lt;/h3&gt;

&lt;p&gt;Docker Hub에 sample-app 저장소를 생성합니다.&lt;/p&gt;

&lt;h3 id=&quot;kubernetes-클러스터-구성&quot;&gt;Kubernetes 클러스터 구성&lt;/h3&gt;

&lt;p&gt;애플리케이션 서버로 사용할 Kubernetes 클러스터를 준비합니다.&lt;/p&gt;

&lt;h3 id=&quot;jenkins-설치&quot;&gt;Jenkins 설치&lt;/h3&gt;

&lt;p&gt;Jenkins를 설치할 namespace를 생성합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create namespace jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에서 다운로드한 jenkinsci-demo 디렉토리로 이동합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd jenkinsci-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jenkins Helm chart를 설치합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm install --name jenkins-release --namespace jenkins \
-f jenkins/values.yaml stable/jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Maven Build Cache 용도의 pvc를 생성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create -f jenkins/maven-cache-pvc.yaml -n jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jenkins에 대한 자세한 내용은 &lt;a href=&quot;/blog/cicd/2018/05/26/installing-jenkins.html&quot;&gt;Jenkins 설치하기&lt;/a&gt; 문서를 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;jenkins-ui-접속&quot;&gt;Jenkins UI 접속&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkins UI에 접속하기 위해 포트포워딩을 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; export POD_NAME=$(kubectl get pods --namespace jenkins -l &quot;app.kubernetes.io/component=jenkins-master&quot; -l &quot;app.kubernetes.io/instance=jenkins-release&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
 kubectl --namespace jenkins port-forward $POD_NAME 8080:8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkins admin 계정의 암호를 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; printf $(kubectl get secret --namespace jenkins jenkins-release -o jsonpath=&quot;{.data.jenkins-admin-password}&quot; | base64 --decode);echo
 xxxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제 웹 브라우저에서 localhost:8080 로 접속해서 admin 계정으로 로그인합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkins 관리 &amp;gt; 시스템 설정 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;# of executors&lt;/code&gt;의 값을 10으로 변경하고 저장합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;credential-생성하기&quot;&gt;Credential 생성하기&lt;/h2&gt;

&lt;p&gt;DockerHub에 접속하기 위한 credential을 생성해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkins UI에서 왼쪽 메뉴의 Credentials을 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;목록에서 Jenkins를 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Global credentials을 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;왼쪽 메뉴의 Add Credentials을 클릭합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DockerHub의 Username, Password를 입력하고 ID에 docker_credential을 입력합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OK 버튼을 선택해 저장합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;jenkins-job-생성하기&quot;&gt;Jenkins Job 생성하기&lt;/h2&gt;

&lt;p&gt;소스코드를 빌드하고 DockerHub에 저장하는 Job을 생성해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;왼쪽 메뉴의 New Item을 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Item 이름을 sample-app으로 입력하고 Multibranch Pipeline을 선택합니다.
그리고 OK 버튼을 선택해 다음 화면으로 이동합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;화면 상단의 General으로 이동합니다.
Display Name에 sample-app을 입력합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Branch Sources로 이동합니다.
Add source &amp;gt; Git을 선택합니다. Project Repository에 앞에서 생성한 sample-app 저장소 주소를 입력합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scan Multibranch Pipeline Triggers로 이동합니다.
Periodically if not otherwise run를 체크하고 Interval을 1 minute로 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Save 버튼을 선택해 설정을 저장합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sample-app-저장소에-소스코드-업로드&quot;&gt;sample-app 저장소에 소스코드 업로드&lt;/h2&gt;

&lt;p&gt;위에서 미리 생성한 sample-app 저장소에 소스코드를 업로드하겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sample-app 디렉토리를 생성하고 jenkinsci-demo/sample-app의 소스코드를 복사합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; mkdir sample-app
 cd sample-app
 cp -r ../jenkinsci-demo/sample-app/. ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkinsfile을 수정합니다.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DOCKER_REPOSITORY&lt;/code&gt;를 위에서 생성한 DockerHub 저장소명으로 변경합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; def dockerCredential = &quot;docker_credential&quot;
 def imageTag = &quot;DOCKER_REPOSITORY:${env.BRANCH_NAME}.${env.BUILD_NUMBER}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;소스코드를 저장소에 업로드합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; git init
 git add --all
 git commit -m &quot;first commit&quot;
 git remote add origin https://github.com/YunSangJun/sample-app.git
 git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>윤상준</name></author><category term="jenkinsci" /><category term="cicd" /><category term="devops" /><category term="kubernetes" /><summary type="html">Overview</summary></entry><entry><title type="html">Argo CD 설치하기</title><link href="http://localhost:4000/blog/cicd/2019/08/04/installing-argocd.html" rel="alternate" type="text/html" title="Argo CD 설치하기" /><published>2019-08-04T00:00:00+09:00</published><updated>2019-08-04T00:00:00+09:00</updated><id>http://localhost:4000/blog/cicd/2019/08/04/installing-argocd</id><content type="html" xml:base="http://localhost:4000/blog/cicd/2019/08/04/installing-argocd.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Argo CD는 지속적인 배포 환경을 구성하기 위한 툴입니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 Argo CD를 Kubernetes 환경에 구성하는 방법에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;h3 id=&quot;kubernetes-클러스터-구성&quot;&gt;Kubernetes 클러스터 구성&lt;/h3&gt;

&lt;p&gt;Argo CD를 설치할 Kubernetes 클러스터 환경을 준비합니다.&lt;/p&gt;

&lt;h3 id=&quot;kubectl-cli-설치&quot;&gt;Kubectl CLI 설치&lt;/h3&gt;

&lt;p&gt;Argo CD를 설치하기 위해 kubectl cli를 설치합니다.&lt;/p&gt;

&lt;h2 id=&quot;argo-cd-설치&quot;&gt;Argo CD 설치&lt;/h2&gt;

&lt;p&gt;argocd namespace를 생성하고 kubectl 명령을 통해 argocd를 kubernetes cluster에 배포합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정상적으로 배포되었는지 조회해봅니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get po -n argocd
NAME                                             READY   STATUS    RESTARTS   AGE
argocd-application-controller-5576758b85-r45zq   1/1     Running   2          26m
argocd-dex-server-c87ff4c6-kgrcp                 1/1     Running   1          26m
argocd-redis-6f4db95c5-r5zbp                     1/1     Running   0          26m
argocd-repo-server-7dc5cc9b47-4m6ng              1/1     Running   0          26m
argocd-server-67c6bd95bc-7qdbl                   1/1     Running   0          26m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;argo-cd-cli-설치&quot;&gt;Argo CD CLI 설치&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/argoproj/argo-cd/releases&quot;&gt;Argo CD Release&lt;/a&gt; 페이지에서 CLI 바이너리를 다운로드합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//OSX
curl -LO https://github.com/argoproj/argo-cd/releases/download/[VERSION]/argocd-darwin-amd64
chmod u+x argocd-darwin-amd64
mv argocd-darwin-amd64 /usr/local/bin/argocd

//Linux
curl -LO https://github.com/argoproj/argo-cd/releases/download/[VERSION]/argocd-linux-amd64
chmod u+x argocd-linux-amd64
mv argocd-linux-amd64 /usr/local/bin/argocd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;argo-cd-api-서버에-접속하기&quot;&gt;Argo CD API 서버에 접속하기&lt;/h2&gt;

&lt;p&gt;Argo CD 설치 시 기본 설정은 API 서버를 외부 주소로 노출시키지 않습니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 세 가지 방법으로 API 서버를 외부에서 접속할 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Service Type을 Load Balancer로 설정&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 Service Type을 Load Balancer로 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl patch svc argocd-server -n argocd -p '{&quot;spec&quot;: {&quot;type&quot;: &quot;LoadBalancer&quot;}}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ingress 설정&lt;/p&gt;

    &lt;p&gt;아래 가이드를 참고하여 Ingress를 설정합니다.&lt;/p&gt;

    &lt;p&gt;https://argoproj.github.io/argo-cd/operator-manual/ingress/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Port Forwarding 설정&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 Port Forwarding을 설정합니다.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8080&lt;/code&gt;으로 서버에 접속할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl port-forward svc/argocd-server -n argocd 8080:443
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;로그인&quot;&gt;로그인&lt;/h2&gt;

&lt;p&gt;Argo CD의 admin 계정 암호는 argocd-server pod 이름으로 자동 설정됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server -o name | cut -d'/' -f 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 암호를 사용하여 admin으로 로그입합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;argocd login [SERVER_ADDRESS]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 명령을 실행하여 패스워드를 변경합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;argocd account update-password
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;웹 브라우저를 통해서도 서버에 접속할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/argocd/installing-argocd-login.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;샘플-애플리케이션-배포&quot;&gt;샘플 애플리케이션 배포&lt;/h2&gt;

&lt;p&gt;이제 Argo CD를 활용하여 샘플 애플리케이션을 배포해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;cli-사용&quot;&gt;CLI 사용&lt;/h3&gt;

&lt;p&gt;Argo CD CLI를 사용하여 샘플 애플리케이션을 배포합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;아래 명령을 실행하여 샘플 애플리케이션을 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; argocd app create sample-app \
 --repo https://github.com/argoproj/argocd-example-apps.git \
 --path guestbook \
 --dest-server https://kubernetes.default.svc \
 --dest-namespace default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;생성한 sample-app을 조회해보면 STATUS가 OutOfSync입니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ argocd app get sample-app
 Name:               guestbook
 Server:             https://kubernetes.default.svc
 Namespace:          default
 ...
 GROUP  KIND        NAMESPACE  NAME          STATUS     HEALTH
 apps   Deployment  default    guestbook-ui  OutOfSync  Missing
     Service     default    guestbook-ui  OutOfSync  Missing
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아래 명령을 실행하여 sample-app을 동기화합니다.
동기화하면 kubectl apply 명령을 실행해 애플리케이션을 클러스터에 배포합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; argocd app sync guestbook
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;ui-활용&quot;&gt;UI 활용&lt;/h3&gt;

&lt;p&gt;웹 브라우저에서 Argo CD UI를 통해 샘플 애플리케이션을 배포해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Create Application 버튼을 선택합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/argocd/installing-argocd-deploy-00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Application Name에 sample-app, Project는 default를 선택합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/argocd/installing-argocd-deploy-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Repository URL에 https://github.com/argoproj/argocd-example-apps.git 를 입력합니다.
Revision은 Head, Path는 guestbook을 입력합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/argocd/installing-argocd-deploy-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cluster URL은 https://kubernetes.default.svc, Namespace는 default를 선택합니다.
그리고 화면 상단의 Create 버튼을 선택해 애플리케이션을 생성합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/argocd/installing-argocd-deploy-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;처음 배포하면 Status가 OutOfSync 상태입니다. Sync 버튼을 선택해 동기화합니다.
동기화하면 kubectl apply 명령을 실행해 애플리케이션을 클러스터에 배포합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/argocd/installing-argocd-deploy-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포가 완료되면 아래와 같은 모습니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/argocd/installing-argocd-deploy-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>윤상준</name></author><category term="argocd" /><category term="cicd" /><category term="devops" /><category term="kubernetes" /><summary type="html">Overview</summary></entry><entry><title type="html">CircleCI를 활용한 코드 통합, 빌드, 배포 파이프라인 구성하기</title><link href="http://localhost:4000/blog/cicd/2019/07/03/circleci.html" rel="alternate" type="text/html" title="CircleCI를 활용한 코드 통합, 빌드, 배포 파이프라인 구성하기" /><published>2019-07-03T00:00:00+09:00</published><updated>2019-07-03T00:00:00+09:00</updated><id>http://localhost:4000/blog/cicd/2019/07/03/circleci</id><content type="html" xml:base="http://localhost:4000/blog/cicd/2019/07/03/circleci.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;CircleCI는 소스코드를 통합하고 빌드, 배포를 자동화하는 파이프라인을 구성하기 위한 툴입니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 아래와 같은 서비스를 통합하여 CI/CD 환경을 구성해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;형상 관리: Github&lt;/li&gt;
  &lt;li&gt;빌드, 배포, 파이프라인: Circle CI&lt;/li&gt;
  &lt;li&gt;이미지 저장소: AWS ECR(Elastic Container Registry)&lt;/li&gt;
  &lt;li&gt;애플리케이션 서버: AWS ECS(Elastic Container Service) Fargate&lt;/li&gt;
  &lt;li&gt;알림: Slack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci_architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;h3 id=&quot;샘플-코드-준비하기&quot;&gt;샘플 코드 준비하기&lt;/h3&gt;

&lt;p&gt;이 문서에서는 &lt;a href=&quot;https://github.com/YunSangJun/circleci-demo&quot;&gt;circleci-demo&lt;/a&gt; 프로젝트를 활용하겠습니다.&lt;/p&gt;

&lt;p&gt;위 프로젝트를 자신의 Github 계정으로 fork합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-prep-code.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;aws-ecrelastic-container-registry-구성&quot;&gt;AWS ECR(Elastic Container Registry) 구성&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/21/aws-cicd03.html&quot;&gt;AWS에서 CI/CD 환경 구성 #3 - 코드 빌드, CodeBuild&lt;/a&gt;
문서의 &lt;code class=&quot;highlighter-rouge&quot;&gt;사전 준비 &amp;gt; ECR(Elastic Container Registry) 생성&lt;/code&gt; 섹션을 참고하여 ECR을 생성하겠습니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
ECR 이름은 `circleci-demo`로 생성하겠습니다.
&lt;/p&gt;

&lt;h3 id=&quot;ecr에-샘플-코드-이미지-저장&quot;&gt;ECR에 샘플 코드 이미지 저장&lt;/h3&gt;

&lt;p&gt;위에서 fork한 프로젝트를 로컬로 복제합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone REPOSITORY_URL
$ cd circleci-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Maven 빌드 명령을 실행해 jar 파일을 생성합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mvn clean package
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Docker 빌드 명령을 실행해 Docker 이미지를 생성합니다. 
AWS_ACCOUNT_ID, AWS_DEFAULT_REGION는 자신의 AWS 환경 정보를 입력합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export ECR_REPOSITORY_NAME=&quot;circleci-demo&quot;
$ export AWS_ACCOUNT_ID=&quot;xxx&quot;
$ export AWS_DEFAULT_REGION=&quot;xxx&quot;
$ export FULL_IMAGE_NAME=&quot;${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY_NAME}:latest&quot;
$ docker build -t $FULL_IMAGE_NAME .
$ docker images
REPOSITORY                                    TAG                 IMAGE ID            CREATED             SIZE
xxx.dkr.ecr.xxx.amazonaws.com/circleci-demo   latest              d692168175e6        2 minutes ago       122MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ECR에 로그인하고 Docker 이미지를 ECR에 저장합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ eval $(aws ecr get-login --region $AWS_DEFAULT_REGION --no-include-email)
$ docker push $FULL_IMAGE_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ECR Console에 접속해서 circleci-demo 저장소로 이동해 위에서 저장한 이미지의 주소를 복사해둡니다.
이 주소는 아래 ECS Task 구성시 사용하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xxx.dkr.ecr.xxx.amazonaws.com/circleci-demo:latest&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;aws-ecs-cluster-구성&quot;&gt;AWS ECS Cluster 구성&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/23/aws-ecs-01.html&quot;&gt;AWS ECS 구성 및 활용하기 #1 - 사전 준비 및 클러스터 생성하기&lt;/a&gt; 
문서의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ECS Cluster 생성&lt;/code&gt; 섹션을 참고하여 클러스터를 생성하겠습니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
클러스터 이름은 `circleci-demo`로 생성하겠습니다.
&lt;/p&gt;

&lt;h3 id=&quot;aws-ecs-task-구성&quot;&gt;AWS ECS Task 구성&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/23/aws-ecs-02.html&quot;&gt;AWS ECS 구성 및 활용하기 #2 - 작업 정의 구성하기(ECS Task)&lt;/a&gt;
문서를 참고하여 작업 정의를 생성하겠습니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
작업 정의 이름은 `circleci-demo`로 생성하겠습니다.&lt;br /&gt;
컨테이너 이미지 주소는 `ECR에 샘플 코드 이미지 저장` 섹션에서 복사해둔 주소를 입력하겠습니다.
&lt;/p&gt;

&lt;h3 id=&quot;aws-ecs-service-구성&quot;&gt;AWS ECS Service 구성&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/23/aws-ecs-03.html&quot;&gt;AWS ECS 구성 및 활용하기 #3 - 서비스(ECS Service) 구성하기&lt;/a&gt;
문서를 참고하여 ECS 서비스를 구성하겠습니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
서비스 이름은 `circleci-demo`로 생성하겠습니다.
&lt;/p&gt;

&lt;h2 id=&quot;circleci에-빌드-및-배포-구성하기&quot;&gt;CircleCI에 빌드 및 배포 구성하기&lt;/h2&gt;

&lt;h3 id=&quot;circleci에-접속하기&quot;&gt;CircleCI에 접속하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://circleci.com&quot;&gt;CircleCI 콘솔&lt;/a&gt;에 접속합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;화면 상단 오른쪽의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Log In&lt;/code&gt; 버튼을 선택합니다.
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-login-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Log In with GitHub&lt;/code&gt; 버튼을 선택해 자신의 Github 계정으로 로그인하겠습니다. 
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-login-02.png&quot; alt=&quot;&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;github-프로젝트-연동하기&quot;&gt;Github 프로젝트 연동하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CircleCI Console에 접속 &amp;gt; 왼쪽 메뉴의 Add Project 선택&lt;/li&gt;
  &lt;li&gt;Project 리스트 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;circleci-demo&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Set Up Project&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-add-project-01.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로젝트-설정하기&quot;&gt;프로젝트 설정하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Settings &amp;gt; Organization &amp;gt; Projects &amp;gt; Followed projects &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;circleci-demo&lt;/code&gt; &amp;gt; 설정 버튼(톱니바퀴 아이콘) 선택
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-setup.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Permissions &amp;gt; AWS Permissions &amp;gt; Access Key ID, Secret Access Key 입력
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-aws-permission.png&quot; alt=&quot;&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Permissions &amp;gt; Build Settings &amp;gt; Environment Variables &amp;gt; 아래 환경 변수 입력&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-env.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;이름&lt;/td&gt;
          &lt;td&gt;값&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;AWS_ACCOUNT_ID&lt;/td&gt;
          &lt;td&gt;계정 아이디&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;AWS_DEFAULT_REGION&lt;/td&gt;
          &lt;td&gt;리전 이름&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;AWS_RESOURCE_NAME_PREFIX&lt;/td&gt;
          &lt;td&gt;circleci-demo&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;빌드-및-배포-설정하기&quot;&gt;빌드 및 배포 설정하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;circleci-demo&lt;/code&gt; 프로젝트 root에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.circleci&lt;/code&gt; 디렉토리를 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir .circleci
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.circleci&lt;/code&gt; 디렉토리 하위에 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.yml&lt;/code&gt; 파일을 생성하고 단계별로 설정해보겠습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi .circleci/config.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;먼저 Version을 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: 2.1
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;다음으로 Orbs를 설정합니다. Orbs는 CircleCI 플랫폼을 빠르게 사용할 수 있도록 도와주는 패키지입니다. 
&lt;code class=&quot;highlighter-rouge&quot;&gt;aws-cli&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;aws-ecs&lt;/code&gt; 패키지를 설정하겠습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
orbs:
  aws-cli: circleci/aws-cli@0.1.4
  aws-ecs: circleci/aws-ecs@0.0.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;working directory를 Home의 circleci-demo 디렉토리로 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    working_directory: ~/circleci-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드 서버로 사용할 컨테이너의 base image를 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    docker:
    - image: circleci/openjdk:8-jdk-browsers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;소스코드를 체크아웃하겠습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      - checkout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Remote에 있는 Docker 데몬을 사용하도록 설정하겠습니다. 
빌드 서버로 사용할 컨테이너에는 Docker 클라이언트 툴만 설치하고 실제 빌드는 Remote에 있는 Docker 데몬을 사용합나디.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - setup_remote_docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;저장된 프로젝트 의존성 라이브러리의 캐시가 있는 경우 복구합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - restore_cache:
          key: circleci-demo-        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;프로젝트 의존성 라이브러리를 다운로드합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run: mvn dependency:go-offline  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;다운로드한 프로젝트 의존성 라이브러리를 캐싱합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - save_cache:
          paths:
            - ~/.m2
          key: circleci-demo-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;소스코드를 Maven 빌드해 JAR 파일을 생성합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run: mvn package
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드 테스트 결과를 저장할 경로를 지정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - store_test_results:
          path: target/surefire-reports
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드 결과물인 JAR 파일의 저장 경로를 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - store_artifacts:
          path: target/circleci-demo-0.0.1-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;ECR의 이미지 경로를 환경 변수로 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run:
          name: Setup common environment variables
          command: |
            echo 'export ECR_REPOSITORY_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export FULL_IMAGE_NAME=&quot;${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY_NAME}:${CIRCLE_SHA1}&quot;' &amp;gt;&amp;gt; $BASH_ENV
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드한 JAR 파일을 구동할 Docker 이미지를 빌드합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run:
          name: Build image
          command: |
            docker build -t $FULL_IMAGE_NAME .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드한 Docker 이미지가 정상 동작하는지 테스트합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run:
          name: Test image
          command: |
            docker run -d -p 8080:8080 --name built-image $FULL_IMAGE_NAME
            sleep 10
            docker run --network container:built-image appropriate/curl --retry 10 --retry-connrefused http://localhost:8080 | grep &quot;Hello World&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드한 Docker 이미지를 아카이브(TAR) 파일로 저장합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run:
          name: Save image to an archive
          command: |
            mkdir docker-image
            docker save -o docker-image/image.tar $FULL_IMAGE_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Workflow의 다음 단계에서 사용할 임시 파일을 영구적으로 저장하기 위한 설정을합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - persist_to_workspace:
          root: .
          paths:
            - docker-image
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;다음으로 배포(deploy) 설정을 하겠습니다. 
배포 서버로 사용할 컨테이너 이미지를 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:  
    docker:
      - image: circleci/python:3.6.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;AWS 클라이언트 툴 사용 시 결과 출력의 포맷을 JSON으로 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy: 
    ...
    environment:
      AWS_DEFAULT_OUTPUT: json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;소스코드를 체크아웃하겠습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      - checkout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Remote에 있는 Docker 데몬을 사용하도록 설정하겠습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - setup_remote_docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;워크플로우의 workspace를 배포 서버로 사용하는 컨테이너에 연결합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - attach_workspace:
          at: workspace
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;컨테이너에 AWS CLI(Command Line Interface)를 설치합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - aws-cli/install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;AWS CLI를 사용하기 위해 Access key와 Region 정보를 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - aws-cli/configure:
          aws-access-key-id: &quot;$AWS_ACCESS_KEY_ID&quot;
          aws-region: &quot;$AWS_DEFAULT_REGION&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드 과정에서 저장한 Docker 이미지를 로드합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - run:
          name: Load image
          command: |
            docker load --input workspace/docker-image/image.tar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;ECS 및 이미지 환경 변수를 설정합니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;AWS_RESOURCE_NAME_PREFIX&lt;/code&gt;와 같은 변수는 앞의 프로젝트 설정에서 저장한 값이 주입됩니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - run:
          name: Setup common environment variables
          command: |
            echo 'export ECS_CLUSTER_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export ECS_SERVICE_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export FULL_IMAGE_NAME=&quot;${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${AWS_RESOURCE_NAME_PREFIX}:${CIRCLE_SHA1}&quot;' &amp;gt;&amp;gt; $BASH_ENV
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;ECR에 로그인하고 Docker 이미지를 push합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - run:
          name: Push image
          command: |
            eval $(aws ecr get-login --region $AWS_DEFAULT_REGION --no-include-email)
            docker push $FULL_IMAGE_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;ECS 서비스를 업데이트합니다.
기존 이미지를 새로 빌드한 Docker 이미지로 빌드합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - aws-ecs/update-service:
          family: &quot;${ECS_SERVICE_NAME}&quot;
          cluster-name: &quot;${ECS_CLUSTER_NAME}&quot;
          container-image-name-updates: &quot;container=${ECS_SERVICE_NAME},image-and-tag=${FULL_IMAGE_NAME}&quot;
          verify-revision-is-deployed: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;배포한 ECS 서비스가 정상 동작하는지 테스트합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - run:
          name: Test deployment (Please manually tear down AWS resources after use, if desired)
          command: |
            TARGET_GROUP_ARN=$(aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME | jq -r '.services[0].loadBalancers[0].targetGroupArn')
            ELB_ARN=$(aws elbv2 describe-target-groups --target-group-arns $TARGET_GROUP_ARN | jq -r '.TargetGroups[0].LoadBalancerArns[0]')
            ELB_DNS_NAME=$(aws elbv2 describe-load-balancers --load-balancer-arns $ELB_ARN | jq -r '.LoadBalancers[0].DNSName')
            for attempt in {1..50}; do
              curl -s --retry 10 http://$ELB_DNS_NAME | grep -E &quot;Hello World&quot;
            done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;workflows를 설정합니다.
앞선 과정의 build 및 deploy를 순차적으로 실행합니다.
filters를 설정해 Github의 master 브랜치에 변경이 있는 경우에만 빌드를 하도록합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
workflows:
  version: 2
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              only: master
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;전체-설정-코드&quot;&gt;전체 설정 코드&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: 2.1
orbs:
  aws-cli: circleci/aws-cli@0.1.4
  aws-ecs: circleci/aws-ecs@0.0.3
jobs:
  build:
    working_directory: ~/circleci-demo

    docker:
      - image: circleci/openjdk:8-jdk-browsers

    steps:
      - checkout
      - setup_remote_docker

      - restore_cache:
          key: circleci-demo-
      
      - run: mvn dependency:go-offline
      
      - save_cache:
          paths:
            - ~/.m2
          key: circleci-demo-
      
      - run: mvn package
      
      - store_test_results:
          path: target/surefire-reports
      
      - store_artifacts:
          path: target/circleci-demo-0.0.1-SNAPSHOT.jar

      - run:
          name: Setup common environment variables
          command: |
            echo 'export ECR_REPOSITORY_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export FULL_IMAGE_NAME=&quot;${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY_NAME}:${CIRCLE_SHA1}&quot;' &amp;gt;&amp;gt; $BASH_ENV
      
      - run:
          name: Build image
          command: |
            docker build -t $FULL_IMAGE_NAME .

      - run:
          name: Test image
          command: |
            docker run -d -p 8080:8080 --name built-image $FULL_IMAGE_NAME
            sleep 10
            docker run --network container:built-image appropriate/curl --retry 10 --retry-connrefused http://localhost:8080 | grep &quot;Hello World&quot;
      
      - run:
          name: Save image to an archive
          command: |
            mkdir docker-image
            docker save -o docker-image/image.tar $FULL_IMAGE_NAME
            
      - persist_to_workspace:
          root: .
          paths:
            - docker-image
  deploy:  
    docker:
      - image: circleci/python:3.6.1
    environment:
      AWS_DEFAULT_OUTPUT: json
    steps:
      - checkout
      - setup_remote_docker
      - attach_workspace:
          at: workspace
      - aws-cli/install
      - aws-cli/configure:
          aws-access-key-id: &quot;$AWS_ACCESS_KEY_ID&quot;
          aws-region: &quot;$AWS_DEFAULT_REGION&quot;
      - run:
          name: Load image
          command: |
            docker load --input workspace/docker-image/image.tar
      - run:
          name: Setup common environment variables
          command: |
            echo 'export ECS_CLUSTER_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export ECS_SERVICE_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export FULL_IMAGE_NAME=&quot;${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${AWS_RESOURCE_NAME_PREFIX}:${CIRCLE_SHA1}&quot;' &amp;gt;&amp;gt; $BASH_ENV
      - run:
          name: Push image
          command: |
            eval $(aws ecr get-login --region $AWS_DEFAULT_REGION --no-include-email)
            docker push $FULL_IMAGE_NAME
      - aws-ecs/update-service:
          family: &quot;${ECS_SERVICE_NAME}&quot;
          cluster-name: &quot;${ECS_CLUSTER_NAME}&quot;
          container-image-name-updates: &quot;container=${ECS_SERVICE_NAME},image-and-tag=${FULL_IMAGE_NAME}&quot;
          verify-revision-is-deployed: true
      - run:
          name: Test deployment (Please manually tear down AWS resources after use, if desired)
          command: |
            TARGET_GROUP_ARN=$(aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME | jq -r '.services[0].loadBalancers[0].targetGroupArn')
            ELB_ARN=$(aws elbv2 describe-target-groups --target-group-arns $TARGET_GROUP_ARN | jq -r '.TargetGroups[0].LoadBalancerArns[0]')
            ELB_DNS_NAME=$(aws elbv2 describe-load-balancers --load-balancer-arns $ELB_ARN | jq -r '.LoadBalancers[0].DNSName')
            for attempt in {1..50}; do
              curl -s --retry 10 http://$ELB_DNS_NAME | grep -E &quot;Hello World&quot;
            done
workflows:
  version: 2
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              only: master
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;변경사항-반영&quot;&gt;변경사항 반영&lt;/h3&gt;

&lt;p&gt;변경사항을 Github에 반영합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add --all
$ git commit -m &quot;Updated circleci configuration&quot;
$ git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;빌드-및-배포-상태-확인&quot;&gt;빌드 및 배포 상태 확인&lt;/h3&gt;

&lt;p&gt;Github에 변경사항이 발생하면 CircleCI에서 이를 감지하여 빌드 및 배포를 수행합니다.&lt;/p&gt;

&lt;p&gt;CicleCI 콘솔에서 Workflows 메뉴를 선택하면 빌드 및 배포 상태를 확인할 수 있습니다.
빌드 또는 배포 상태를 선택하면 해당 Job의 상세 정보를 확인할 수 있습니다.
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-workflows.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CicleCI 콘솔에서 Jobs 메뉴를 선택하면 실행 또는 완료된 Job의 목록을 확인할 수 있습니다.
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-jobs-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;목록에서 Job을 선택하면 상세정보를 확인할 수 있습니다.&lt;br /&gt;
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-jobs-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Deploy job의 마지막 단계인 Test deployment 로그를 확인해보면 ECS 서비스가 정상적으로 
배포되었는지 테스트하는 로그를 확인할 수 있습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Hello World(Version 1)&lt;/code&gt; 메세지가 계속 출력되면 배포가 정상적으로 완료된것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-jobs-03.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;slack-연동&quot;&gt;Slack 연동&lt;/h3&gt;

&lt;p&gt;다음으로 CircleCI를 Slack Chat 서비스와 연동하여 빌드 및 배포 성공/실패에 대한 알람을 받을 수 있도록 설정해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://api.slack.com/apps&quot;&gt;Slack MyApp&lt;/a&gt; 페이지에 접속합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create New App 버튼을 선택합니다.
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-slack-01.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;App Name에 circleci-demo를 입력하고 Slack workspace를 선택한뒤 Create App 버튼은 선택합니다.
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-slack-02.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Slack 메신저에서 circleci-demo 채널을 생성합니다.
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-slack-03.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다시 Slack MyApp 페이지로 돌아와서 생성한 circleci-demo 앱을 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Features &amp;gt; Incoming Webhooks &amp;gt; Activate Incoming Webhooks를 On으로 변경합니다.
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-slack-04.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하단의 Webhook URL의 Add New Webhook to Workspace 버튼을 선택합니다. 
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-slack-05.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Post to에서 circleci-demo 채널을 선택하고 Install 버튼을 선택합니다.
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-slack-06.png&quot; alt=&quot;&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;생성된 Webhook URL을 복사해둡니다.
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-slack-07.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다시 CircleCI 콘솔로 이동해서 프로젝트 설정 화면으로 이동합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notifications &amp;gt; Chat Notifications &amp;gt; Webhook URL에 복사해둔 URL을 붙여넣고 저장합니다.
&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-slack-08.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제 소스코드를 수정해서 빌드 및 배포를 다시 실행해보겠습니다. 
아래 파일에서 Version을 2로 변경하고 Commit &amp;amp; Push합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;circleci-demo/src/main/java/com/example/demo/HomeRestController.java&amp;gt;
...
  @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)
  public String getHome() {
    return &quot;Hello World(Version 2)&quot;; 
  }
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CircleCI에서 소스 변경을 감지하고 빌드 및 배포 Job을 실행합니다. 
완료 되면 아래와 같이 Slack 채널에 빌드 및 배포 성공을 알리는 메세지가 출력됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/circleci/circleci-slack-09.png&quot; alt=&quot;&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>윤상준</name></author><category term="circleci" /><category term="cicd" /><category term="devops" /><summary type="html">Overview</summary></entry><entry><title type="html">AWS ECS 구성 및 활용하기 #3 - 서비스(ECS Service) 구성하기</title><link href="http://localhost:4000/blog/cloud/2019/06/23/aws-ecs-03.html" rel="alternate" type="text/html" title="AWS ECS 구성 및 활용하기 #3 - 서비스(ECS Service) 구성하기" /><published>2019-06-23T00:00:00+09:00</published><updated>2019-06-23T00:00:00+09:00</updated><id>http://localhost:4000/blog/cloud/2019/06/23/aws-ecs-03</id><content type="html" xml:base="http://localhost:4000/blog/cloud/2019/06/23/aws-ecs-03.html">&lt;p&gt;AWS에서 ECS(Elastic Container Service)의 서비스(ECS Service)를 통해 작업 정의(컨테이너)를 관리할 수 있습니다. 
로드 밸런서와 연동하여 트랙픽을 다중 컨테이너에 분산할 수 있습니다. 
Auto Scailing을 사용하여 사용량에 기반하여 컨테이너 개수를 조절할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 서비스(ECS Service)를 구성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;p&gt;ECS 서비스를 구성하기 위해서 EBL를 생성합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;EC2 Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; 로드 밸런싱 &amp;gt; 로드밸런서 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;로드 밸런서 생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-01.png&quot; alt=&quot;&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로드밸런서 유형 선택 &amp;gt; Application Load Balancer &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기본 구성 &amp;gt; 이름 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리스너 &amp;gt; 기본 값인 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP, 80&lt;/code&gt; 그대로 사용(애플리케이션 접속시 http를 사용하여 접속)
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;가용 영역 &amp;gt; VPC, 가용 영역 및 Subnet(Public) 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;보안 설정은 변경 없이 &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;보안 그룹 구성&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;보안 그룹 할당 &amp;gt; 새 보안 그룹 생성 선택&lt;/li&gt;
      &lt;li&gt;보안 그룹 이름에 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력&lt;/li&gt;
      &lt;li&gt;설명에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Allow http&lt;/code&gt; 입력&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;유형 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대상 그룹&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;대상 그룹 &amp;gt; 새 대상 그룹 선택&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이름 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo-service&lt;/code&gt; 입력&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상태 검사&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;고급 상태 검사 설정 확장&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;포트 &amp;gt; 재정의 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;8080&lt;/code&gt; 입력(작업 정의에서 컨테이너 포트를 8080으로 지정)&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대상 등록은 설정 변경 없이 &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;전체적으로 검토 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;서비스-생성하기&quot;&gt;서비스 생성하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ECS Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; Amazon ECS &amp;gt; 클러스터 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터 리스트 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 탭 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-01.png&quot; alt=&quot;&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 구성&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;시작 유형 &amp;gt; FARGATE 선택&lt;/li&gt;
      &lt;li&gt;서비스 이름 &amp;gt; cicd-demo 입력&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;작업 개수 &amp;gt; 2 입력&lt;/p&gt;

        &lt;p&gt;&lt;a href=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-02.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deployments &amp;gt; Rolling Update 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
    &lt;p class=&quot;tip-content&quot;&gt;
  - Rolling Update는 기존 버전의 인스턴스를 순차적으로 새로운 버전으로 업데이트하는 방식입니다.
  새로운 인스턴스를 생성하지 않기 때문에 비용 효율적입니다.&lt;br /&gt;

  - Blue/green deployment는 기존 버전의 인스턴스만큼 새로운 버전의 인스턴스를 배포합니다.
  새로운 버전을 테스트하고 트래픽을 일시에 기존 버전에서 새로운 버전으로 이동할 수 있습니다.
  새로운 인스턴스를 기존 버전만큼 생성해야하므로 비용면에서 상대적으로 비효율적입니다.
  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;네트워크 구성 &amp;gt; VPC 및 보안 그룹&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;클러스터 VPC &amp;gt; 컨테이너가 위치할 VPC를 선택&lt;/li&gt;
      &lt;li&gt;서브넷 &amp;gt; 컨테이너가 위치할 서브넷을 선택(이 문서에서는 Private 서브넷을 기준으로 작성함)&lt;/li&gt;
      &lt;li&gt;보안 그룹 &amp;gt; 편집 선택 &amp;gt; 보안 그룹 구성&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;자동 할당 퍼블릭 IP &amp;gt; DISABLED 선택&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-04-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

        &lt;p class=&quot;warning-title&quot;&gt;경고&lt;/p&gt;
        &lt;p class=&quot;warning-content&quot;&gt;
  - 자동 할당 퍼블릭 IP를 DISABLED로 선택할 경우 컨테이너에 퍼블릭 IP가 할당되지 않습니다.
  컨테이너에서 외부와의 통신을 하려면 컨테이너가 위치한 Private 서브넷이 외부와 통신할 수 있는 NAT와 연결되어야 합니다.&lt;br /&gt;
  - 자동 할당 퍼블릭 IP를 ENABLED로 선택할 경우 컨테이너에 퍼블릭 IP가 할당됩니다.
  컨테이너는 Public 서브넷에 위치하고 해당 서브넷은 IGW(Internet Gateway)와 연결되어 있어야 합니다.
  &lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;보안 그룹 구성&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;할당된 보안 그룹 &amp;gt; 새 보안 그룹 생성 선택&lt;/li&gt;
          &lt;li&gt;보안 그룹 이름 &amp;gt; cicd-demo-service 입력&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;인바운드 규칙 &amp;gt; 유형에서 Custom TCP 선택 &amp;gt; 포트 범위 8080 입력(로드밸런서에서 컨테이너의 8080 포트로의 인바운드 트래픽)&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-04-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Elastic Load Balancing&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ELB 유형 &amp;gt; Application Load Balancer 선택&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;ELB 이름 &amp;gt; cicd-demo 선택(사전 준비에서 생성)&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로드를 밸런싱할 컨테이너&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;cicd-demo:8080:8080 선택(작업 정의에서 생성) &amp;gt; ELB에 추가 버튼 선택&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-06-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;리스너 포트 &amp;gt; 80:HTTP 선택(사전 준비에서 생성)&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;대상 그룹 이름 &amp;gt; cicd-demo-service 선택&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-06-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다른 설정은 기본 설정을 사용 &amp;gt; 다음 단계 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 Auto Scaling은 사용하지 않음 &amp;gt; 다음 단계 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 검토를 전반적으로 하고 생성하기 버튼 선택해서 서비스 생성 완료
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;서비스-확인&quot;&gt;서비스 확인&lt;/h2&gt;

&lt;p&gt;이제 서비스가 정상적으로 구성되었는지 확인해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ECS Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; Amazon ECS &amp;gt; 클러스터 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터 리스트 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 탭 선택 &amp;gt; 상태가 Active인지 확인
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;작업 탭 선택 &amp;gt; 마지막/원하는 상태가 Running인지 확인
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EC2 Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; 로드 밸런싱 &amp;gt; 로드밸런서 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로드밸런서 리스트 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대상 탭 선택 &amp;gt; 등록된 대상 &amp;gt; 상태가 healthy인지 확인
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설명 탭 선택 &amp;gt; DNS 이름 복사
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;웹 브라우저 &amp;gt; 복사한 DNS 이름 붙여넣고 접속 &amp;gt; 서비스 정상 접속 확인
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bluegreen-deployment선택&quot;&gt;Blue/green deployment(선택)&lt;/h2&gt;

&lt;p&gt;위 과정에서는 서비스 생성 시 deployment 방식을 Rolling Update로 선택했습니다.&lt;/p&gt;

&lt;p&gt;Blue/green deployment를 활용하는 방법을 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;사전-준비-1&quot;&gt;사전 준비&lt;/h3&gt;

&lt;p&gt;Blue/green deployment 방식으로 서비스를 생성하는 경우 CodeDeploy에 애플리케이션 및 배포 그룹이 자동 생성됩니다.&lt;/p&gt;

&lt;p&gt;이를 위해 CodeDeploy 서비스 권한이 있는 IAM 역할 생성이 필요합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IAM Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; AWS Account &amp;gt; 역할 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;역할 만들기&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;신뢰할 수 있는 유형의 개체 선택 &amp;gt; AWS 서비스 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-02-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 역할을 사용할 서비스 선택 &amp;gt; CodeDeploy 선택 &amp;gt; CodeDeploy - ECS 선택 &amp;gt; 다음 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-02-02.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-02-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설정 변경 없이 다음 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설정 변경 없이 다음 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;역할 이름 &amp;gt; codedeploy-cicd-demo-role 입력 &amp;gt; 역할 만들기 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서비스-생성&quot;&gt;서비스 생성&lt;/h3&gt;

&lt;p&gt;Blue/green deployment 방식으로 서비스를 생성하는 경우 Rolling Update 방식과 아래 과정만 다릅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Deployments
    &lt;ul&gt;
      &lt;li&gt;Deployment type &amp;gt; Blue/green deployment 선택&lt;/li&gt;
      &lt;li&gt;Service role for CodeDeploy &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택
  &lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-bg-01.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Additional configuration
    &lt;ul&gt;
      &lt;li&gt;Target group 1 name &amp;gt; cicd-demo-service 선택&lt;/li&gt;
      &lt;li&gt;Target group 2 name &amp;gt; 새로 생성 선택 &amp;gt; cicd-demo-service-green 입력&lt;/li&gt;
      &lt;li&gt;Target group 2 protocol &amp;gt; HTTP 선택
  &lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-bg-02.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서비스-확인-1&quot;&gt;서비스 확인&lt;/h3&gt;

&lt;p&gt;서비스 확인 방법도 Rolling Update와 동일합니다.&lt;/p&gt;

&lt;p&gt;다른 점은 Blue/green deployment 방식으로 서비스를 생성하는 경우 CodeDeploy에 애플리케이션 및 배포 그룹이 자동 생성됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeDeploy console 접속 &amp;gt; 왼쪽 메뉴의 애플리케이션 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 리스트 &amp;gt; AppECS-cicd-demo-cicd-demo 선택 
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-bg-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 그룹 리스트 &amp;gt; DgpECS-cicd-demo-cicd-demo 선택 
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-bg-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 그룹 확인
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-bg-05-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>윤상준</name></author><category term="aws" /><category term="container" /><category term="awsecs" /><category term="awsecsservice" /><category term="awsecsfargate" /><summary type="html">AWS에서 ECS(Elastic Container Service)의 서비스(ECS Service)를 통해 작업 정의(컨테이너)를 관리할 수 있습니다. 로드 밸런서와 연동하여 트랙픽을 다중 컨테이너에 분산할 수 있습니다. Auto Scailing을 사용하여 사용량에 기반하여 컨테이너 개수를 조절할 수 있습니다.</summary></entry><entry><title type="html">AWS ECS 구성 및 활용하기 #2 - 작업 정의 구성하기(ECS Task)</title><link href="http://localhost:4000/blog/cloud/2019/06/23/aws-ecs-02.html" rel="alternate" type="text/html" title="AWS ECS 구성 및 활용하기 #2 - 작업 정의 구성하기(ECS Task)" /><published>2019-06-23T00:00:00+09:00</published><updated>2019-06-23T00:00:00+09:00</updated><id>http://localhost:4000/blog/cloud/2019/06/23/aws-ecs-02</id><content type="html" xml:base="http://localhost:4000/blog/cloud/2019/06/23/aws-ecs-02.html">&lt;p&gt;AWS에서 ECS(Elastic Container Service)의 작업 정의(ECS Task)를 통해 컨테이너 관련 설정을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 작업 정의(ECS Task)를 구성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;p&gt;ECS 작업 정의를 구성하기 위해서 IAM 역할을 생성합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IAM Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; AWS Account &amp;gt; 역할 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;역할 만들기&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-iam-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;개체 선택에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS 서비스&lt;/code&gt; 선택 &amp;gt; 서비스 선택에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Elastic Container Service&lt;/code&gt; 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-iam-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용 사례에서 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Elastic Container Service Task&lt;/code&gt; 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음: 권한&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-iam-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;권한 정책 연결 &amp;gt; 정책 필터에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ecs&lt;/code&gt; 입력 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;AmazonECSTaskExecutionRolePolicy&lt;/code&gt; 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음: 태그&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-iam-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;태그 입력 또는 다음으로 넘어가기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;역할 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;ecstask-cicd-demo-role&lt;/code&gt; 입력 &amp;gt; 역할 검토 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;역할 만들기&lt;/code&gt; 버튼 선택 
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-iam-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ecs-작업-정의&quot;&gt;ECS 작업 정의&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ECS Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; Amazon ECS &amp;gt; 작업 정의 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;새 작업 정의 선택&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecstask-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Fargate 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음 단계&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecstask-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;작업 정의 이름에 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력 &amp;gt; 작업 역할 &lt;code class=&quot;highlighter-rouge&quot;&gt;ecstask-cicd-demo-role&lt;/code&gt; 선택(시작하기 에서 생성)
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecstask-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;작업 실행 역할 &lt;code class=&quot;highlighter-rouge&quot;&gt;ecsTaskExecutionRole&lt;/code&gt; 선택(없는 경우 새 역할 생성 선택)
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecstask-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;작업 메모리 &lt;code class=&quot;highlighter-rouge&quot;&gt;2GB&lt;/code&gt; 선택 &amp;gt; 작업 CPU &lt;code class=&quot;highlighter-rouge&quot;&gt;1vCPU&lt;/code&gt; 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecstask-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;컨테이너 정의
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;컨테이너 추가&lt;/code&gt; 버튼 선택&lt;/li&gt;
      &lt;li&gt;팝업 창 &amp;gt; 컨테이너 이름 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력&lt;/li&gt;
      &lt;li&gt;이미지 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;이미지 주소&lt;/code&gt; 입력(시작하기에서 복사한 주소)&lt;/li&gt;
      &lt;li&gt;메모리 제한 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;소프트 제한&lt;/code&gt; 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;500&lt;/code&gt; 입력&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;포트 매핑 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;8080&lt;/code&gt; 입력 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;추가&lt;/code&gt; 버튼 선택&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecstask-06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택해서 작업 정의 생성 완료
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecstask-07.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음으로 &lt;a href=&quot;/blog/cloud/2019/06/23/aws-ecs-03.html&quot;&gt;AWS ECS 구성 및 활용하기 #3 - 서비스(ECS Service) 구성하기&lt;/a&gt;
문서에서 서비스(ECS Service)를 구성하는 방법을 살펴보겠습니다.&lt;/p&gt;</content><author><name>윤상준</name></author><category term="aws" /><category term="container" /><category term="awsecs" /><category term="awsecstask" /><category term="awsecsfargate" /><summary type="html">AWS에서 ECS(Elastic Container Service)의 작업 정의(ECS Task)를 통해 컨테이너 관련 설정을 할 수 있습니다. 이 문서에서는 작업 정의(ECS Task)를 구성하는 방법을 알아보겠습니다.</summary></entry><entry><title type="html">AWS ECS 구성 및 활용하기 #1 - 사전 준비 및 클러스터 생성하기</title><link href="http://localhost:4000/blog/cloud/2019/06/23/aws-ecs-01.html" rel="alternate" type="text/html" title="AWS ECS 구성 및 활용하기 #1 - 사전 준비 및 클러스터 생성하기" /><published>2019-06-23T00:00:00+09:00</published><updated>2019-06-23T00:00:00+09:00</updated><id>http://localhost:4000/blog/cloud/2019/06/23/aws-ecs-01</id><content type="html" xml:base="http://localhost:4000/blog/cloud/2019/06/23/aws-ecs-01.html">&lt;p&gt;AWS에서 ECS(Elastic Container Service)를 구성하기 위해 필요한 사전 준비와 ECS 클러스터를 생성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;p&gt;ECS에 애플리케이션을 배포하기 위해서 소스코드를 Docker 이미지로 빌드하고 이를 Docker Registry에 저장해야합니다.
또한 애플리케이션을 다중 컨테이너에 배포한 경우 로드밸런싱을 활용하여 트래픽을 분산해야합니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 아래와 같은 구성을 활용하여 ECS를 구성하고 애플리케이션을 배포하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;샘플 애플리케이션: &lt;a href=&quot;https://github.com/spring-projects/spring-petclinic&quot;&gt;spring-petclinic&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;형상 관리: CodeCommit&lt;/li&gt;
  &lt;li&gt;코드 빌드: CodeBuild&lt;/li&gt;
  &lt;li&gt;이미지 저장소: ECR(Elastic Container Registry)&lt;/li&gt;
  &lt;li&gt;로드밸런싱 : ELB(Elastic Load Balancing)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
ECR 또는 외부 이미지 저장소에 이미 빌드한 이미지가 있다면 이 과정을 넘어가도됩니다.
&lt;/p&gt;

&lt;h3 id=&quot;애플리케이션-준비&quot;&gt;애플리케이션 준비&lt;/h3&gt;

&lt;p&gt;아래 문서를 참고하여 형상 관리 저장소에 샘플 애플리케이션을 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/20/aws-cicd02.html&quot;&gt;AWS에서 CI/CD 환경 구성 #2 - 형상 관리 구성, CodeCommit&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;코드-빌드-및-이미지-저장&quot;&gt;코드 빌드 및 이미지 저장&lt;/h3&gt;

&lt;p&gt;다음으로 아래 문서를 참고하여 코드를 빌드하고 이를 이미지 저장소에 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/21/aws-cicd03.html&quot;&gt;AWS에서 CI/CD 환경 구성 #3 - 코드 빌드, CodeBuild&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 단계를 완료하면 아래와 같이 이미지 저장소 주소를 복사합니다.
이 주소는 ECS 환경에 애플리케이션을 배포할 때 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-prep-ecr-01.png&quot; alt=&quot;&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ecs-cluster-생성&quot;&gt;ECS Cluster 생성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ECS Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; Amazon ECS &amp;gt; 클러스터 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;클러스터 생성&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터 템플릿 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;네트워킹 전용(AWS Fargate 제공)&lt;/code&gt; 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
    &lt;p class=&quot;tip-content&quot;&gt;
  ECS Fargate는 ECS 서비스를 위한 EC2 인스턴스를 생성하지 않는 완전 관리형 컨테이너 서비스입니다.
  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터 구성 &amp;gt; 클러스터 이름 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음으로 &lt;a href=&quot;/blog/cloud/2019/06/23/aws-ecs-02.html&quot;&gt;AWS ECS 구성 및 활용하기 #2 - 작업 정의 구성하기(ECS Task)&lt;/a&gt;
문서에서 작업 정의(ECS Task)를 구성하는 방법을 살펴보겠습니다.&lt;/p&gt;</content><author><name>윤상준</name></author><category term="aws" /><category term="container" /><category term="awsecs" /><category term="awsecsfargate" /><summary type="html">AWS에서 ECS(Elastic Container Service)를 구성하기 위해 필요한 사전 준비와 ECS 클러스터를 생성하는 방법을 알아보겠습니다.</summary></entry><entry><title type="html">AWS에서 CI/CD 환경 구성 #5 - 파이프라인 구성(Blue/green), CodePipeline</title><link href="http://localhost:4000/blog/cloud/2019/06/22/aws-cicd05.html" rel="alternate" type="text/html" title="AWS에서 CI/CD 환경 구성 #5 - 파이프라인 구성(Blue/green), CodePipeline" /><published>2019-06-22T00:00:00+09:00</published><updated>2019-06-22T00:00:00+09:00</updated><id>http://localhost:4000/blog/cloud/2019/06/22/aws-cicd05</id><content type="html" xml:base="http://localhost:4000/blog/cloud/2019/06/22/aws-cicd05.html">&lt;p&gt;지금까지 구성한 CodeCommit, CodeBuild, CodeDeploy 및 CodePipeline 서비스를 활용하여 코드를 통합, 빌드 및 배포하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 배포 방식으로 Blue/green deployment를 활용하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;h3 id=&quot;ecselastic-container-service-구성&quot;&gt;ECS(Elastic Container Service) 구성&lt;/h3&gt;

&lt;p&gt;이 문서에서는 애플리케이션을 배포할 서버로 ECS(Elastic Container Service) 서비스를 사용합니다.&lt;/p&gt;

&lt;p&gt;아래 문서를 참고하여 ECS 환경을 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/23/aws-ecs-01.html&quot;&gt;AWS ECS 구성 및 활용하기 #1 - 사전 준비 및 클러스터 생성하기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/23/aws-ecs-02.html&quot;&gt;AWS ECS 구성 및 활용하기 #2 - 작업 정의 구성하기(ECS Task)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/23/aws-ecs-03.html&quot;&gt;AWS ECS 구성 및 활용하기 #3 - 서비스(ECS Service) 구성하기&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;warning-title&quot;&gt;경고&lt;/p&gt;
&lt;p class=&quot;warning-content&quot;&gt;
이 문서에서는 서비스(ECS Service) 구성하기에서 배포 방식을 Blue/green deployment로 선택해야합니다.
&lt;/p&gt;

&lt;h3 id=&quot;branch-생성&quot;&gt;Branch 생성&lt;/h3&gt;

&lt;p&gt;Blue/green 배포를 위해 사용할 리포지토리를 생성합니다.
CodeCommit의 cicd-demo 리포지토리에 blue/green branch를 생성해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeCommit Console 접속 &amp;gt; 왼쪽 메뉴의 소스 &amp;gt; 리포지토리&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리포지토리 리스트 &amp;gt; cicd-demo 선택 &amp;gt; 왼쪽 메뉴에서 브랜치 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; 브랜치 생성 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-prep-branch-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;브랜치 이름에 bluegreen 입력 &amp;gt; 다음으로부터의 브랜치에 master 선택 &amp;gt; 브랜치 생성 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-prep-branch-02.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;브랜치 리스트 &amp;gt; bluegreen 선택해 이동
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-prep-branch-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;app-spec-변경&quot;&gt;App spec 변경&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeCommit Console 접속 &amp;gt; 왼쪽 메뉴의 소스 &amp;gt; 리포지토리&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리포지토리 리스트 &amp;gt; cicd-demo 선택 &amp;gt; bluegreen branch 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;파일 추가 &amp;gt; 파일 생성 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-prep-appspec-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;파일 내용에 아래 내용 입력&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: 0.0 
Resources: 
  - TargetService: 
      Type: AWS::ECS::Service 
      Properties: 
        TaskDefinition: &quot;arn:aws:ecs:AWS_DEFAULT_REGION:AWS_ACCOUNT_ID:task-definition/TASK_NAME&quot; 
        LoadBalancerInfo: 
          ContainerName: &quot;CONTAINER_NAME&quot; 
          ContainerPort: CONTAINER_PORT 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-prep-appspec-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
    &lt;p class=&quot;tip-content&quot;&gt;
AWS_DEFAULT_REGION과 같은 환경 변수는 코드 빌드 시 치환함
&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;파일 이름에 &lt;code class=&quot;highlighter-rouge&quot;&gt;appspec.yaml&lt;/code&gt; 파일을 입력 &amp;gt; 변경 사항 커밋 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-prep-appspec-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;build-spec-변경&quot;&gt;Build spec 변경&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeCommit Console 접속 &amp;gt; 왼쪽 메뉴의 소스 &amp;gt; 리포지토리&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리포지토리 리스트 &amp;gt; cicd-demo 선택 &amp;gt; bluegreen branch 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buildspec.yaml&lt;/code&gt; 파일 아래와 같이 편집&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;buildspec.yaml&amp;gt;
version: 0.2  
    
phases:  
  install:  
    runtime-versions:  
      java: openjdk8  
      docker: 18  
  pre_build:  
    commands:  
      - echo Logging in to Amazon ECR...  
      - $(aws ecr get-login --no-include-email --region $AWS_DEFAULT_REGION)  
  build:  
    commands:  
      - echo Build started on `date`  
      - echo Building the Docker image...     
      - mvn clean package         
      - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG .  
      - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG  
  post_build:  
    commands:  
      - echo Build completed on `date`  
      - echo Pushing the Docker image...  
      - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG  
      - sed -i s/AWS_DEFAULT_REGION/$AWS_DEFAULT_REGION/ appspec.yaml 
      - sed -i s/AWS_ACCOUNT_ID/$AWS_ACCOUNT_ID/ appspec.yaml 
      - sed -i s/TASK_NAME/$TASK_NAME/ appspec.yaml 
      - sed -i s/CONTAINER_NAME/$CONTAINER_NAME/ appspec.yaml 
      - sed -i s/CONTAINER_PORT/$CONTAINER_PORT/ appspec.yaml 
artifacts:  
  files:   
    - appspec.yaml 
cache:  
  paths:  
    - '/root/.m2/**/*' 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;추가된 내용은 아래와 같습니다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;appspec.yaml&lt;/code&gt; 파일의 &lt;code class=&quot;highlighter-rouge&quot;&gt;CONTAINER_NAME&lt;/code&gt;과 같은 환경 변수를 치환&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;appspec.yaml&lt;/code&gt; 파일을 artifacts file에 추가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;환경-변수-설정&quot;&gt;환경 변수 설정&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buildspec.yaml&lt;/code&gt; 파일의 환경 변수를 CodeBuild에서 설정하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeBuild Console 접속 &amp;gt; 왼쪽 메뉴의 프로젝트 빌드&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면의 빌드 프로젝트 리스트에서 cicd-demo 선택 &amp;gt; 빌드 세부 정보 탭 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-prep-env-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;환경 &amp;gt; 편집 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-prep-env-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;추가 구성 확장 &amp;gt; 환경 변수 입력 &amp;gt; 환경 업데이트 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-prep-env-03.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-prep-env-04-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;이름&lt;/td&gt;
          &lt;td&gt;값&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;AWS_DEFAULT_REGION&lt;/td&gt;
          &lt;td&gt;리전 이름&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;AWS_ACCOUNT_ID&lt;/td&gt;
          &lt;td&gt;계정 아이디&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;IMAGE_REPO_NAME&lt;/td&gt;
          &lt;td&gt;ECR 이름&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;IMAGE_TAG&lt;/td&gt;
          &lt;td&gt;Docker 이미지 태그 이름&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TASK_NAME&lt;/td&gt;
          &lt;td&gt;ECS Task 이름&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;CONTAINER_NAME&lt;/td&gt;
          &lt;td&gt;컨테이너 이름&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;CONTAINER_PORT&lt;/td&gt;
          &lt;td&gt;컨테이너 포트&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;배포-그룹-설정-변경&quot;&gt;배포 그룹 설정 변경&lt;/h3&gt;

&lt;p&gt;Blue/green 방식으로 배포한 후 기존 서버(Blue)의 트래픽을 신규 서버(Green)로 1)바로 이동시키거나
2)승인 후 이동하도록 설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 승인 후 이동하도록 설정을 변경해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeDeploy console 접속 &amp;gt; 왼쪽 메뉴의 애플리케이션 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 리스트 &amp;gt; AppECS-cicd-demo-cicd-demo 선택 
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-bg-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 그룹 리스트 &amp;gt; DgpECS-cicd-demo-cicd-demo 선택 
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-bg-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 그룹 &amp;gt; 편집 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-bg-05-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 설정 &amp;gt; 트래픽을 언제 다시 라우팅할지 지정 선택 &amp;gt; 시간을 1시간으로 설정
&lt;img src=&quot;/blog/assets/images/cloud/aws/ecs/aws-ecs-service-bg-05-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파이프라인-구성bluegreen-deployment&quot;&gt;파이프라인 구성(Blue/green deployment)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;CodePipeline 콘솔에 접속 &amp;gt; 왼쪽 메뉴의 파이프라인 &amp;gt; 파이프라인 선택&lt;/li&gt;
  &lt;li&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;파이프라인 생성&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-01.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파이프라인-설정-선택&quot;&gt;파이프라인 설정 선택&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;파이프라인 이름 &amp;gt; cicd-demo-bluegreen 입력&lt;/li&gt;
  &lt;li&gt;서비스 역할 &amp;gt; 기존 서비스 역할 선택&lt;/li&gt;
  &lt;li&gt;역할 이름 &amp;gt; codepipeline-cicd-demo-role 선택 &amp;gt; 다음 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-02.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;소스-스테이지-추가&quot;&gt;소스 스테이지 추가&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;소스 공급자 &amp;gt; AWS CodeCommit 선택&lt;/li&gt;
  &lt;li&gt;리포지토리 이름 &amp;gt; cicd-demo 선택&lt;/li&gt;
  &lt;li&gt;브랜치 이름 &amp;gt; bluegreen 선택 &amp;gt; 다음 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-03.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;빌드-스테이지-추가&quot;&gt;빌드 스테이지 추가&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;빌드 공급자 &amp;gt; AWS CodeBuild 선택&lt;/li&gt;
  &lt;li&gt;프로젝트 이름 &amp;gt; cicd-demo 검색 및 선택 &amp;gt; 다음 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-04.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;배포-스테이지-추가&quot;&gt;배포 스테이지 추가&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;배포 공급자 &amp;gt; Amazon CodeDeploy 선택&lt;/li&gt;
  &lt;li&gt;애플리케이션 이름 &amp;gt; AppECS-cicd-demo-cicd-demo 선택&lt;/li&gt;
  &lt;li&gt;배포 그룹 &amp;gt; DgpECS-cicd-demo-cicd-demo 선택 &amp;gt; 다음 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-05.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;검토&quot;&gt;검토&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;파이프라인 검토 후 다음 파이프라인 생성 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-06-01.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-06-02.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파이프라인-실행&quot;&gt;파이프라인 실행&lt;/h2&gt;

&lt;p&gt;파이프라인을 생성하면 자동으로 소스코드 통합 &amp;gt; 빌드 &amp;gt; 배포 과정이 발생합니다.&lt;/p&gt;

&lt;p&gt;이 후에는 1)수동으로 파이프라인을 실행하거나 2)CodeCommit의 소스코드 변경사항을 감지해 실행됩니다.&lt;/p&gt;

&lt;h3 id=&quot;수동으로-파이프라인-실행&quot;&gt;수동으로 파이프라인 실행&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodePipeline Console &amp;gt; 왼쪽 메뉴의 파이프라인 &amp;gt; 파이프라인 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면의 파이프라인 리스트 &amp;gt; cicd-demo-bluegreen 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변경사항 릴리스 버튼을 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;변경사항에-의해-자동으로-실행&quot;&gt;변경사항에 의해 자동으로 실행&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeCommit Console 접속 &amp;gt; 왼쪽 메뉴의 소스 &amp;gt; 리포지토리&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리포지토리 리스트 &amp;gt; cicd-demo 선택 &amp;gt; bluegreen branch 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;src/main/resources/messages/messages.properties&lt;/code&gt; 파일 아래와 같이 편집&lt;/p&gt;

    &lt;p&gt;메세지의 welcome 프로퍼티를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Welcome(Version 2)&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Welcome(Version 3)&lt;/code&gt;로 변경 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;변경 사항 커밋&lt;/code&gt; 버튼 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CodePipeline Console &amp;gt; 왼쪽 메뉴의 파이프라인 &amp;gt; 파이프라인 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면의 파이프라인 리스트 &amp;gt; cicd-demo-bluegreen 선택&lt;/p&gt;

    &lt;p&gt;소스코드 변경을 감지하고 자동으로 빌드와 배포 파이프라인이 실행됨
  &lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deploy 단계가 넘어가면 세부 정보 선택해서 배포 상태 조회하면으로 이동
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;교체 작업(Green)을 배포 완료했으나 트래픽은 원본 작업(Blue)으로 연결된 상태
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;웹 브라우저 &amp;gt; ELB DNS 주소로 접속 &amp;gt; 원본 작업(Blue)이므로 Version이 2임
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-12-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;웹 브라우저 &amp;gt; 테스트 포트(ELB DNS 주소 + &lt;code class=&quot;highlighter-rouge&quot;&gt;:8080&lt;/code&gt;) &amp;gt; 교체 작업(Green)이므로 Version이 3임
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-12-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;트래픽 다시 라우팅 버튼을 선택해 교체 작업(Green)으로 트래픽을 이동
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;트래픽 전환이 완료될때까지 대기
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;웹 브라우저 &amp;gt; ELB DNS 주소로 접속 &amp;gt; 트래픽이 교체 작업(Green)으로 완전히 라우팅 되었으므로 Version이 3임
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 작업이 완료되었으므로 원래 작업 세트 종료 버튼을 선택해 원본 작업은 종료 처리
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd05-codepipeline-bg-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>윤상준</name></author><category term="aws" /><category term="cicd" /><category term="devops" /><category term="awscodedeploy" /><category term="awscodepipeline" /><category term="bluegreendeployement" /><summary type="html">지금까지 구성한 CodeCommit, CodeBuild, CodeDeploy 및 CodePipeline 서비스를 활용하여 코드를 통합, 빌드 및 배포하는 방법을 알아보겠습니다.</summary></entry><entry><title type="html">AWS에서 CI/CD 환경 구성 #4 - 파이프라인 구성(Rolling Update), CodePipeline</title><link href="http://localhost:4000/blog/cloud/2019/06/22/aws-cicd04.html" rel="alternate" type="text/html" title="AWS에서 CI/CD 환경 구성 #4 - 파이프라인 구성(Rolling Update), CodePipeline" /><published>2019-06-22T00:00:00+09:00</published><updated>2019-06-22T00:00:00+09:00</updated><id>http://localhost:4000/blog/cloud/2019/06/22/aws-cicd04</id><content type="html" xml:base="http://localhost:4000/blog/cloud/2019/06/22/aws-cicd04.html">&lt;p&gt;지금까지 구성한 CodeCommit, CodeBuild, CodeDeploy 및 CodePipeline 서비스를 활용하여 코드를 통합, 빌드 및 배포하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 배포 방식으로 Rolling Update를 활용하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;h3 id=&quot;ecselastic-container-service-구성&quot;&gt;ECS(Elastic Container Service) 구성&lt;/h3&gt;

&lt;p&gt;이 문서에서는 애플리케이션을 배포할 서버로 ECS(Elastic Container Service) 서비스를 사용합니다.&lt;/p&gt;

&lt;p&gt;아래 문서를 참고하여 ECS 환경을 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/23/aws-ecs-01.html&quot;&gt;AWS ECS 구성 및 활용하기 #1 - 사전 준비 및 클러스터 생성하기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/23/aws-ecs-02.html&quot;&gt;AWS ECS 구성 및 활용하기 #2 - 작업 정의 구성하기(ECS Task)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/cloud/2019/06/23/aws-ecs-03.html&quot;&gt;AWS ECS 구성 및 활용하기 #3 - 서비스(ECS Service) 구성하기&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;warning-title&quot;&gt;경고&lt;/p&gt;
&lt;p class=&quot;warning-content&quot;&gt;
이 문서에서는 서비스(ECS Service) 구성하기에서 배포 방식을 Rolling Update로 선택해야합니다.
&lt;/p&gt;

&lt;h3 id=&quot;build-spec-변경&quot;&gt;Build spec 변경&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeCommit Console 접속 &amp;gt; 왼쪽 메뉴의 소스 &amp;gt; 리포지토리&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리포지토리 리스트 &amp;gt; cicd-demo 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buildspec.yaml&lt;/code&gt; 파일 아래와 같이 편집&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;buildspec.yaml&amp;gt;
version: 0.2 
 
phases: 
  install: 
    runtime-versions: 
      java: openjdk8 
      docker: 18 
  pre_build: 
    commands: 
      - echo Logging in to Amazon ECR... 
      - $(aws ecr get-login --no-include-email --region $AWS_DEFAULT_REGION) 
  build: 
    commands: 
      - echo Build started on `date` 
      - echo Building the Docker image...    
      - mvn clean package        
      - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG . 
      - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG 
  post_build: 
    commands: 
      - echo Build completed on `date` 
      - echo Pushing the Docker image... 
      - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG 
      - printf '[{&quot;name&quot;:&quot;cicd-demo&quot;,&quot;imageUri&quot;:&quot;%s&quot;}]' $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG &amp;gt; imagedefinitions.json 
artifacts: 
  files:  
    - imagedefinitions.json 
cache: 
  paths: 
    - '/root/.m2/**/*' 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;추가된 내용은 아래와 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이미지의 이름과 주소를 &lt;code class=&quot;highlighter-rouge&quot;&gt;imagedefinitions.json&lt;/code&gt; 파일에 쓰기 및 생성&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;imagedefinitions.json&lt;/code&gt; 파일을 artifacts file에 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파이프라인-구성rolling-update&quot;&gt;파이프라인 구성(Rolling Update)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;CodePipeline 콘솔에 접속 &amp;gt; 왼쪽 메뉴의 파이프라인 &amp;gt; 파이프라인 선택&lt;/li&gt;
  &lt;li&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;파이프라인 생성&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-01.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파이프라인-설정-선택&quot;&gt;파이프라인 설정 선택&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;파이프라인 이름 &amp;gt; cicd-demo 입력&lt;/li&gt;
  &lt;li&gt;서비스 역할 &amp;gt; 새 서비스 역할 선택&lt;/li&gt;
  &lt;li&gt;역할 이름 &amp;gt; codepipeline-cicd-demo-role &amp;gt; 다음 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-02.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;소스-스테이지-추가&quot;&gt;소스 스테이지 추가&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;소스 공급자 &amp;gt; AWS CodeCommit 선택&lt;/li&gt;
  &lt;li&gt;리포지토리 이름 &amp;gt; cicd-demo 선택&lt;/li&gt;
  &lt;li&gt;브랜치 이름 &amp;gt; master 선택 &amp;gt; 다음 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-03.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;빌드-스테이지-추가&quot;&gt;빌드 스테이지 추가&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;빌드 공급자 &amp;gt; AWS CodeBuild 선택&lt;/li&gt;
  &lt;li&gt;프로젝트 이름 &amp;gt; cicd-demo 검색 및 선택 &amp;gt; 다음 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-04.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;배포-스테이지-추가&quot;&gt;배포 스테이지 추가&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;배포 공급자 &amp;gt; Amazon ECS 선택&lt;/li&gt;
  &lt;li&gt;클러스터 이름 &amp;gt; cicd-demo 선택&lt;/li&gt;
  &lt;li&gt;서비스 이름 &amp;gt; cicd-demo 선택&lt;/li&gt;
  &lt;li&gt;이미지 정의 파일 &amp;gt; imagedefinitions.json 입력 &amp;gt; 다음 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-05.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;검토&quot;&gt;검토&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;파이프라인 검토 후 다음 파이프라인 생성 버튼 선택
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-06-01.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-06-02.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파이프라인-실행&quot;&gt;파이프라인 실행&lt;/h2&gt;

&lt;p&gt;파이프라인을 생성하면 자동으로 소스코드 통합 &amp;gt; 빌드 &amp;gt; 배포 과정이 발생합니다.&lt;/p&gt;

&lt;p&gt;이 후에는 1)수동으로 파이프라인을 실행하거나 2)CodeCommit의 소스코드 변경사항을 감지해 실행됩니다.&lt;/p&gt;

&lt;h3 id=&quot;수동으로-파이프라인-실행&quot;&gt;수동으로 파이프라인 실행&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodePipeline Console &amp;gt; 왼쪽 메뉴의 파이프라인 &amp;gt; 파이프라인 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면의 파이프라인 리스트 &amp;gt; cicd-demo 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변경사항 릴리스 버튼을 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;변경사항에-의해-자동으로-실행&quot;&gt;변경사항에 의해 자동으로 실행&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeCommit Console 접속 &amp;gt; 왼쪽 메뉴의 소스 &amp;gt; 리포지토리&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리포지토리 리스트 &amp;gt; cicd-demo 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;src/main/resources/messages/messages.properties&lt;/code&gt; 파일 아래와 같이 편집&lt;/p&gt;

    &lt;p&gt;메세지의 welcome 프로퍼티를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Welcome&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Welcome(Version 2)&lt;/code&gt;로 변경 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;변경 사항 커밋&lt;/code&gt; 버튼 선택
  &lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CodePipeline Console &amp;gt; 왼쪽 메뉴의 파이프라인 &amp;gt; 파이프라인 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면의 파이프라인 리스트 &amp;gt; cicd-demo 선택&lt;/p&gt;

    &lt;p&gt;소스코드 변경을 감지하고 자동으로 빌드와 배포 파이프라인이 실행됨
  &lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;파이프라인의 배포 단계까지 완료되면 로드밸런서 주소로 접속해서 변경한 메세지가 반영되었는지 확인
&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd04-codepipeline-rolling-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음으로 &lt;a href=&quot;/blog/cloud/2019/06/22/aws-cicd05.html&quot;&gt;AWS에서 CI/CD 환경 구성 #5 - 파이프라인 구성(Blue/green), CodePipeline&lt;/a&gt;
문서에서 Blue/green deployment 방식의 파이프라인을 구성하는 방법을 살펴보겠습니다.&lt;/p&gt;</content><author><name>윤상준</name></author><category term="aws" /><category term="cicd" /><category term="devops" /><category term="awscodedeploy" /><category term="awscodepipeline" /><category term="rollingupdate" /><summary type="html">지금까지 구성한 CodeCommit, CodeBuild, CodeDeploy 및 CodePipeline 서비스를 활용하여 코드를 통합, 빌드 및 배포하는 방법을 알아보겠습니다.</summary></entry><entry><title type="html">AWS에서 CI/CD 환경 구성 #3 - 코드 빌드, CodeBuild</title><link href="http://localhost:4000/blog/cloud/2019/06/21/aws-cicd03.html" rel="alternate" type="text/html" title="AWS에서 CI/CD 환경 구성 #3 - 코드 빌드, CodeBuild" /><published>2019-06-21T00:00:00+09:00</published><updated>2019-06-21T00:00:00+09:00</updated><id>http://localhost:4000/blog/cloud/2019/06/21/aws-cicd03</id><content type="html" xml:base="http://localhost:4000/blog/cloud/2019/06/21/aws-cicd03.html">&lt;p&gt;AWS에서 CodeBuild 서비스를 활용하여 소스코드를 빌드하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;h3 id=&quot;ecrelastic-container-registry-생성&quot;&gt;ECR(Elastic Container Registry) 생성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ECR Console에 접속 &amp;gt; 메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;리포지토리 생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-00-00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리포지토리 이름 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;리포지토리 생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;생성한 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 리포지토리를 CodeBuild 서비스에서 사용합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-00-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;iam-정책-생성&quot;&gt;IAM 정책 생성&lt;/h3&gt;

&lt;p&gt;CodeBuild에서 ECR에 접근하기 위한 정책을 생성합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IAM Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; AWS Account &amp;gt; 정책 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;정책 생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-00-02.png&quot; alt=&quot;&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정책 생성 화면 &amp;gt; JSON 탭 선택 &amp;gt; 정책 내용 입력(아래 코드 참고) &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;정책 검토&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  {
      &quot;Statement&quot;: [
          {
              &quot;Action&quot;: [
                  &quot;ecr:BatchCheckLayerAvailability&quot;,
                  &quot;ecr:CompleteLayerUpload&quot;,
                  &quot;ecr:GetAuthorizationToken&quot;,
                  &quot;ecr:InitiateLayerUpload&quot;,
                  &quot;ecr:PutImage&quot;,
                  &quot;ecr:UploadLayerPart&quot;
              ],
              &quot;Resource&quot;: &quot;*&quot;,
              &quot;Effect&quot;: &quot;Allow&quot;
          }
      ],
      &quot;Version&quot;: &quot;2012-10-17&quot;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-00-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정책 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;CodeBuildECRPolicy-cicd-demo-ap-northeast-2&lt;/code&gt;로 입력 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;정책 생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-00-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;buildspec-파일-생성&quot;&gt;BuildSpec 파일 생성&lt;/h3&gt;

&lt;p&gt;CodeBuild 서비스를 통하여 소스코드를 빌드하기 위해서 소스코드의 repository에 &lt;code class=&quot;highlighter-rouge&quot;&gt;buildspec.yml&lt;/code&gt; 파일을 생성해야합니다.&lt;/p&gt;

&lt;p&gt;아래와 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;buildspec.yml&lt;/code&gt; 파일을 CodeCommit에 생성한 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 저장소 root에 생성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;buildspec.yml&amp;gt;
version: 0.2 
 
phases: 
  install: 
    runtime-versions: 
      java: openjdk8 
      docker: 18 
  pre_build: 
    commands: 
      - echo Logging in to Amazon ECR... 
      - $(aws ecr get-login --no-include-email --region $AWS_DEFAULT_REGION) 
  build: 
    commands: 
      - echo Build started on `date` 
      - echo Building the Docker image...    
      - mvn clean package        
      - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG . 
      - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG 
  post_build: 
    commands: 
      - echo Build completed on `date` 
      - echo Pushing the Docker image... 
      - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG 
cache: 
  paths: 
    - '/root/.m2/**/*' 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;phase.install : Java SDK, Docker CLI를 설치&lt;/li&gt;
  &lt;li&gt;phase.pre_build : ECR 서비스에 로그인&lt;/li&gt;
  &lt;li&gt;phase.build : Maven 및 Docker 빌드&lt;/li&gt;
  &lt;li&gt;phase.post_build : Docker 이미지를 ECR에 push&lt;/li&gt;
  &lt;li&gt;cache.paths(선택): 소스코드 빌드에 사용하는 파일을 cache하는 경우 위치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$AWS_DEFAULT_REGION&lt;/code&gt;와 같은 환경 변수는 CodeBuild 프로젝트 구성 과정에서 설정합니다.&lt;/p&gt;

&lt;h3 id=&quot;docker-파일-생성&quot;&gt;Docker 파일 생성&lt;/h3&gt;

&lt;p&gt;Docker 이미지를 빌드하기 위해서 소스코드의 repository에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;을 생성해야합니다.&lt;/p&gt;

&lt;p&gt;아래와 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;을 CodeCommit에 생성한 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 저장소 root에 생성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;Dockerfile&amp;gt;
FROM openjdk:8-jdk-alpine
ADD target/spring-petclinic-2.1.0.BUILD-SNAPSHOT.jar app.jar
ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;codebuild-프로젝트-구성&quot;&gt;CodeBuild 프로젝트 구성&lt;/h2&gt;

&lt;p&gt;이제 CodeBuild 프로젝트를 구성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;빌드-프로젝트-생성&quot;&gt;빌드 프로젝트 생성&lt;/h3&gt;

&lt;p&gt;먼저 프로젝트를 생성합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CodeBuild 콘솔에 접속 &amp;gt; 왼쪽 메뉴의 빌드 &amp;gt; 프로젝트 빌드 선택&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;빌드 프로젝트 생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로젝트-설정&quot;&gt;프로젝트 설정&lt;/h3&gt;

&lt;p&gt;이제 프로젝트 정보를 설정합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로젝트 이름 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;빌드 배지 활성화 체크&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;소스&quot;&gt;소스&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;소스 공급자 &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS CodeCommit&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리포지토리 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;환경&quot;&gt;환경&lt;/h4&gt;

&lt;h5 id=&quot;이미지&quot;&gt;이미지&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;환경 이미지 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;관리형 이미지&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;운영 체제 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Ubuntu 선택&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;런타임 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Standard&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;이미지 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;aws/codebuild/standart:2.0&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;이미지 버전 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;이 런타임 버전에 항상 최신 이미지 사용&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;권한이 있음 체크&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;역할&quot;&gt;역할&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;서비스 역할 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;새 서비스 역할&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;역할 이름 &lt;code class=&quot;highlighter-rouge&quot;&gt;codebuild-cicd-demo-service-role&lt;/code&gt; 입력&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;추가-구성&quot;&gt;추가 구성&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;추가 구성 메뉴 확장 &amp;gt; 환경 변수 입력&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-06-00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-06-01.png&quot; alt=&quot;&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;환경 변수 이름, 값 설명&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;이름&lt;/td&gt;
          &lt;td&gt;값&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;AWS_DEFAULT_REGION&lt;/td&gt;
          &lt;td&gt;리전 이름&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;AWS_ACCOUNT_ID&lt;/td&gt;
          &lt;td&gt;계정 아이디&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;IMAGE_REPO_NAME&lt;/td&gt;
          &lt;td&gt;ECR 이름&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;IMAGE_TAG&lt;/td&gt;
          &lt;td&gt;Docker 이미지 태그 이름&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;build-spec&quot;&gt;Build Spec&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;빌드 사양 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;buildspec 파일 사용&lt;/code&gt; 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;아티팩트&quot;&gt;아티팩트&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;유형 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;아티팩트 없음&lt;/code&gt; 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;로그&quot;&gt;로그&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;유형 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;CloudWatch 로그&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;빌드 프로젝트 생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;codebuild-역할과-정책-연결&quot;&gt;CodeBuild 역할과 정책 연결&lt;/h3&gt;

&lt;p&gt;빌드 프로젝트 생성이 완료되면 CodeBuild용 IAM 역할이 생성됩니다.&lt;/p&gt;

&lt;p&gt;이 역할에 사전 준비에서 생성한 정책을 연결합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IAM Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; AWS Account &amp;gt; 역할 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; 검색 창 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;codebuild&lt;/code&gt; 입력 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;codebuild-cicd-demo-service-role&lt;/code&gt; 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-10-00.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;권한 탭 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;정책 연결&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-10-01.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정책 필터 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;codebuild&lt;/code&gt; 입력 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;CodeBuildECRPolicy-cicd-demo-ap-northeast-2&lt;/code&gt; 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;정책 연결&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-10-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;codebuild-시작&quot;&gt;CodeBuild 시작&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeBuild 콘솔에 접속 &amp;gt; 왼쪽 메뉴의 빌드 &amp;gt; 프로젝트 빌드 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 프로젝트 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;빌드 시작&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-11-00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;빌드가 성공적으로 종료되면 상태가 성공함으로 변경됩니다&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-11-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ECR의 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 저장소에 접속해보면 새로운 이미지가 생성되어 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-11-02.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;codebuild-캐시-설정선택&quot;&gt;CodeBuild 캐시 설정(선택)&lt;/h2&gt;

&lt;p&gt;위에서 빌드 결과를 보면 빌드에 소요된 시간이 14분 55초로 다소 오래 걸립니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-11-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빌드 기록을 선택해 상세보기 페이지로 이동한 후 단계 세부 정보를 확인해보면 BUILD 단계에서 14분이 소요된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-11-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빌드 로그 탭을 선택해 로그를 확인해보면 Maven Build를 하기 위해 의존성 라이브러리를 다운로드하는데 많은 시간이 소요되는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-11-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CodeBuild 서비스에서는 소스코드를 빌드하기 위한 파일을 한번만 다운받고 이 후에는 다시 받지 않도록 캐시 옵션을 설정할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeBuild Console에 접속 &amp;gt; 빌드 &amp;gt; 프로젝트 빌드 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;빌드 세부 정보&lt;/code&gt; 탭 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아티팩트 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;편집&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-12-00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;추가 구성 메뉴 확장 &amp;gt; 캐시 유형 &lt;code class=&quot;highlighter-rouge&quot;&gt;Amazon S3&lt;/code&gt; 선택 &amp;gt; 캐시 버킷 선택(S3 콘솔에서 생성)&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-12-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;설정을 완료한 후 다시 빌드를 시작합니다. 빌드가 완료된 후 기록을 보겠습니다. 
아래와 같이 기존 &lt;code class=&quot;highlighter-rouge&quot;&gt;14분 55초&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;1분 54초로&lt;/code&gt; 빌드 시간이 단축되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-12-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;단계 세부 정보를 확인해보면 BUILD 단계가 기존 &lt;code class=&quot;highlighter-rouge&quot;&gt;14분&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;1분&lt;/code&gt;으로 단축되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/cloud/aws/cicd/aws-cicd03-12-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 &lt;a href=&quot;/blog/cloud/2019/06/22/aws-cicd04.html&quot;&gt;AWS에서 CI/CD 환경 구성 #4 - 파이프라인 구성(Rolling Update), CodePipeline&lt;/a&gt;
문서에서 파이프라인 서비스인 CodePipeline을 구성하는 방법을 살펴보겠습니다.&lt;/p&gt;</content><author><name>윤상준</name></author><category term="aws" /><category term="cicd" /><category term="devops" /><category term="awscodebuild" /><summary type="html">AWS에서 CodeBuild 서비스를 활용하여 소스코드를 빌드하는 방법을 알아보겠습니다.</summary></entry></feed>