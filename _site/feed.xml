<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.0">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2018-06-04T01:22:05+09:00</updated><id>http://localhost:4000/blog/</id><title type="html">윤상준의 기술 블로그</title><subtitle>Software &amp; Cloud Engineer 입니다. Kubernetes, Cloud Foundry등의 PaaS와 Cloud 및 DevOps 관련 기술에 관심이 있습니다.</subtitle><author><name>Yun SangJun</name></author><entry><title type="html">Cannot find module ‘webpack/lib/node/NodeTemplatePlugin’</title><link href="http://localhost:4000/blog/angular/2018/05/29/angular-cannot-find-module.html" rel="alternate" type="text/html" title="Cannot find module 'webpack/lib/node/NodeTemplatePlugin'" /><published>2018-05-29T00:00:00+09:00</published><updated>2018-05-29T00:00:00+09:00</updated><id>http://localhost:4000/blog/angular/2018/05/29/angular-cannot-find-module</id><content type="html" xml:base="http://localhost:4000/blog/angular/2018/05/29/angular-cannot-find-module.html">&lt;p&gt;Angular build 시 아래와 같은 에러가 나는 경우가 있습니다.
npm5에 도입된 &lt;code class=&quot;highlighter-rouge&quot;&gt;package-lock.json&lt;/code&gt;을 삭제하지 않고 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt;을 한 경우 발생합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn run xxx
yarn run v1.7.0
$ ng build --prod --aot --progress=false --output-path rootfs/dist
Cannot find module 'webpack/lib/node/NodeTemplatePlugin'
Error: Cannot find module 'webpack/lib/node/NodeTemplatePlugin'
    at Function.Module._resolveFilename (module.js:547:15)
    at Function.Module._load (module.js:474:25)
    at Module.require (module.js:596:17)
    at require (internal/module.js:11:18)
    at Object.&amp;lt;anonymous&amp;gt; (/Users/sangjunyun/git/zcp-catalog-ui/node_modules/html-webpack-plugin/lib/compiler.js:11:26)
    at Module._compile (module.js:652:30)
    at Object.Module._extensions..js (module.js:663:10)
    at Module.load (module.js:565:32)
    at tryModuleLoad (module.js:505:12)
    at Function.Module._load (module.js:497:3)
    at Module.require (module.js:596:17)
    at require (internal/module.js:11:18)
    at Object.&amp;lt;anonymous&amp;gt; (/Users/sangjunyun/git/zcp-catalog-ui/node_modules/html-webpack-plugin/index.js:7:21)
    at Module._compile (module.js:652:30)
    at Object.Module._extensions..js (module.js:663:10)
    at Module.load (module.js:565:32)
error Command failed with exit code 1.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
make: *** [compile-aot] Error 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 명령어를 실행해 &lt;code class=&quot;highlighter-rouge&quot;&gt;node_modules&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;dist&lt;/code&gt; 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;package-lock.json&lt;/code&gt;을 삭제합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rm -rf node_modules dist package-lock.json
$ npm cache clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt; 명령을 실행해 node_modules을 다시 설치합니다.
이후 Angular build를 다시하면 정상적으로 실행됩니다.&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">Angular build 시 아래와 같은 에러가 나는 경우가 있습니다. npm5에 도입된 package-lock.json을 삭제하지 않고 npm install을 한 경우 발생합니다.</summary></entry><entry><title type="html">Helm 설치하기</title><link href="http://localhost:4000/blog/helm/2018/05/27/installing-helm.html" rel="alternate" type="text/html" title="Helm 설치하기" /><published>2018-05-27T00:00:00+09:00</published><updated>2018-05-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/27/installing-helm</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/27/installing-helm.html">&lt;p&gt;이 페이지는 Helm을 설치하는 방법에 대해 설명합니다.
자세한 내용은 &lt;a href=&quot;https://docs.helm.sh/using_helm/#installing-helm&quot;&gt;Installing Helm&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;helm-client-바이너리-다운로드&quot;&gt;Helm client 바이너리 다운로드&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/helm/releases&quot;&gt;Helm release&lt;/a&gt; 바이너리를 다운로드합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;바이너리 압축 해제합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  tar -zxvf helm-vX.X.X-OS_NAME-amd64.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Helm 바이너리를 원하는 위치로 이동시킵니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mv OS_NAME-amd64/helm /usr/local/bin/helm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tiller-설치&quot;&gt;Tiller 설치&lt;/h2&gt;

&lt;p&gt;Helm의 서버 부분 인 Tiller는 일반적으로 Kubernetes 클러스터 내부에서 실행됩니다. 그러나 개발을 위해 로컬로 실행될 수도 있고 원격 Kubernetes 클러스터와 통신하도록 구성 될 수도 있습니다.&lt;/p&gt;

&lt;p&gt;Tiller를 클러스터에 설치하는 가장 쉬운 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;helm init&lt;/code&gt;를 실행하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;helm init&lt;/code&gt; 실행 후 Tiller가 running 상태가 될 때까지 대기합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pods --namespace kube-system |grep tiller
tiller-deploy-7ccf99cd64-pd7c2        1/1       Running   0          3d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Helm client와 server의 버전을 확인합니다.
Server의 버전이 Client의 버전과 같거나 높아야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm version
Client: &amp;amp;version.Version{SemVer:&quot;v2.9.0&quot;, GitCommit:&quot;xxx&quot;, GitTreeState:&quot;clean&quot;}
Server: &amp;amp;version.Version{SemVer:&quot;v2.9.1&quot;, GitCommit:&quot;xxx&quot;, GitTreeState:&quot;clean&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Server를 제외한 Client만 설치하고 싶은 경우 아래와 같이 실행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm init --client-only
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 Helm을 활용해 chart를 Kubernetes에 배포할 수 있습니다.&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Helm을 설치하는 방법에 대해 설명합니다. 자세한 내용은 Installing Helm을 참고하세요.</summary></entry><entry><title type="html">Ingress TLS Secret 생성하기</title><link href="http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html" rel="alternate" type="text/html" title="Ingress TLS Secret 생성하기" /><published>2018-05-27T00:00:00+09:00</published><updated>2018-05-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html">&lt;p&gt;이 페이지에서는 Ingress에 TLS를 적용하기 위한 Secret을 생성하는 방법을 가이드합니다.&lt;/p&gt;

&lt;h2 id=&quot;tls-secret-생성&quot;&gt;TLS Secret 생성&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하여 TLS Secret을 생성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create secret tls example-tls --cert example.crt --key example.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 아래와 같이 yaml 파일 형태로 생성할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi secret.yaml
apiVersion: v1
data:
  tls.crt: base64 encoded cert
  tls.key: base64 encoded key
kind: Secret
metadata:
  name: example-tls
type: Opaque

$ kubectl create -f secret.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tls-secret을-ingress에-적용&quot;&gt;TLS Secret을 Ingress에 적용&lt;/h2&gt;

&lt;p&gt;아래와 같이 Ingress의 secretName 속성에 example-tls을 적용합니다.
이제 Ingress를 배포한 후 host로 접속하면 TLS가 적용된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: example-ingress
spec:
  rules:
  - host: example.com
    http:
      paths:
      - backend:
          serviceName: example
          servicePort: 80
  tls:
  - hosts:
    - example.com
    secretName: example-tls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지에서는 Ingress에 TLS를 적용하기 위한 Secret을 생성하는 방법을 가이드합니다.</summary></entry><entry><title type="html">Helm chart를 사용하여 Jenkins를 컨테이너로 배포하기</title><link href="http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart.html" rel="alternate" type="text/html" title="Helm chart를 사용하여 Jenkins를 컨테이너로 배포하기" /><published>2018-05-26T00:00:00+09:00</published><updated>2018-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart.html">&lt;p&gt;이 페이지는 Helm chart를 사용하여 Jenkins를 컨테이너로 배포하는 방법에 대해 설명합니다.
자세한 내용은 &lt;a href=&quot;https://github.com/kubernetes/charts/tree/master/stable/jenkins&quot;&gt;Jenkins Helm Chart&lt;/a&gt;에서 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;준비-사항&quot;&gt;준비 사항&lt;/h2&gt;

&lt;p&gt;아래 가이드를 참고하여 Helm Client를 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/helm/2018/05/27/installing-helm.html&quot;&gt;Helm 설치하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;빠른-설치&quot;&gt;빠른 설치&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하면 Kubernetes 클러스터에 Jenkins가 배포됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm install --name jenkins stable/jenkins
NAME:   jenkins
...
NOTES:
1. Get your 'admin' user password by running:
  printf $(kubectl get secret --namespace default jenkins -o jsonpath=&quot;{.data.jenkins-admin-password}&quot; | base64 --decode);echo
2. Get the Jenkins URL to visit by running these commands in the same shell:
  NOTE: It may take a few minutes for the LoadBalancer IP to be available.
        You can watch the status of by running 'kubectl get svc --namespace default -w jenkins'
  ...
  echo http://$SERVICE_IP:8080/login

3. Login with the password from step 1 and the username: admin

For more information on running Jenkins on Kubernetes, visit:
https://cloud.google.com/solutions/jenkins-on-container-engine
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정상적으로 설치가 완료되었다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOTES&lt;/code&gt;의 가이드를 참고하여 Jenkins 대시보드에 접속할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;참고 : 기본 설정을 사용하므로 클러스터 환경에 따라 설치 중 에러가 발생할 수 있습니다.
이런 경우 아래 가이드를 따라 사용자 설정 방식으로 배포 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사용자-정의-설치&quot;&gt;사용자 정의 설치&lt;/h2&gt;

&lt;h3 id=&quot;설정&quot;&gt;설정&lt;/h3&gt;

&lt;p&gt;사용자의 Kubernetes 클러스터 환경에 맞게 Jenkins의 서비스, 스토리지 등의 설정을 변경할 수 있습니다.
아래 가이드를 참고하여 사용자의 환경에 맞도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;values.yaml&lt;/code&gt; 파일을 작성합니다.&lt;/p&gt;

&lt;h4 id=&quot;jenkins-admin-사용자-암호&quot;&gt;Jenkins admin 사용자 암호&lt;/h4&gt;

&lt;p&gt;Jenkins admin의 초기 사용자 암호입니다. 기본 설정은 랜덤한 패스워드입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  AdminPassword: ExamplePassword
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;서비스&quot;&gt;서비스&lt;/h4&gt;

&lt;p&gt;서비스는 Jenkins 대시보드를 접속을 어떤 방식으로 제공할지에 대한 설정입니다.
기본 설정은 LoadBalancer 방식입니다. 사용자의 클러스터의 환경에 동적으로 제공되는 LoadBalancer 서비스가 있다면 사용 가능합니다.
LoadBalancer 서비스가 없다면 아래와 같이 NodePort 또는 Ingress 방식을 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;NodePort&lt;/p&gt;

    &lt;p&gt;NodePort를 사용하면 Worker Node의 Public IP를 통하여 서비스에 접근 할 수 있습니다.
ServiceType을 NodePort로 설정하고 NodePort에 30000~32767사이의 포트 번호를 입력합니다.
포트 번호를 입력하지 않으면 30000~32767사이의 숫자에서 랜덤하게 선택됩니다.&lt;/p&gt;

    &lt;p&gt;접속 URI 예시 : http://WORKER_NODE_PUBLIC_IP:3xxxx&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  ServiceType: NodePort
  NodePort: 30000-32767
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ingress&lt;/p&gt;

    &lt;p&gt;Ingress를 사용하면 Ingress Controller의 Public IP를 통하여 서비스에 접근 할 수 있습니다.
ServiceType을 ClusterIP로 설정하고 HostName에 원하는 도메인을 입력합니다.(이 때 도메인이 Ingress Controller의 Public IP와 연결되어야 합니다.)
SSL 접속을 지원하려면 TLS 설정의 secretName과 host명을 입력합니다.&lt;/p&gt;

    &lt;p&gt;Ingress TLS Secret 생성 방법은 아래 가이드를 참고하세요.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html&quot;&gt;Ingress TLS Secret 생성하기&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  ServiceType: ClusterIP
  HostName: jenkins.example.com
  Ingress:
    TLS:
      - secretName: example-tls
        hosts:
          - jenkins.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;스토리지&quot;&gt;스토리지&lt;/h4&gt;

&lt;p&gt;Jenkins는 영구적으로 저장해야 하는 데이터를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/jenkins_home&lt;/code&gt;에 저장합니다.
이 데이터를 영구적으로 저장하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/jenkins_home&lt;/code&gt; 폴더를 PV(Persistent Volume)에 mount 해야합니다.
사용자의 Cluster에서 동적으로 PV를 생성 및 관리해주는 기능이 있다면 별도의 설정이 필요없습니다.
GKE, AWS, AKS 등의 환경에서는 Storage Class를 정의하면 PV를 생성하고 관리합니다.
또한 미리 구성된 PVC(PersistentVolumeClaim)를 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Storage Class 사용&lt;/p&gt;

    &lt;p&gt;Storage Class를 사용하여 동적으로 PV를 생성합니다.
Storage Class 명은 아래와 같이 확인할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get storageclass
NAME                       PROVISIONER         AGE
default                    ibm.io/ibmc-file    41d
ibmc-block-bronze          ibm.io/ibmc-block   3d
ibmc-file-bronze           ibm.io/ibmc-file    26d
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;원하는 Storage Class 명을 입력합니다. Storage의 크기를 원하는 값으로 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Persistence:
  StorageClass: &quot;default&quot;
  Size: 8Gi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사전 구성된 PVC 사용&lt;/p&gt;

    &lt;p&gt;미리 구성된 PVC(PersistentVolumeClaim)를 사용합니다.
미리 구성된 PVC 명은 아래와 같이 확인할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pvc
NAME          STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS        AGE
jenkins-pvc   Bound     pvc-47aec304-5e4e-11e8-915d-82c09a00d8d2   20Gi       RWO            ibmc-block-bronze   3d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;미리 구성된 PVC 명을 입력합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Persistence:
  ExistingClaim: &quot;jenkins-pvc&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설치&quot;&gt;설치&lt;/h3&gt;

&lt;p&gt;이제 아래 명령을 실행하여 사용자 정의에 맞게 Jenkins를 설치합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm install --name jenkins -f values.yaml stable/jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Helm chart를 사용하여 Jenkins를 컨테이너로 배포하는 방법에 대해 설명합니다. 자세한 내용은 Jenkins Helm Chart에서 참고하세요.</summary></entry><entry><title type="html">Helm chart repository 호스팅</title><link href="http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository.html" rel="alternate" type="text/html" title="Helm chart repository 호스팅" /><published>2018-05-26T00:00:00+09:00</published><updated>2018-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository.html">&lt;p&gt;Helm chart를 개발한 후 외부에서 helm cli를 통해 다운로드 및 설치 하려면 Helm chart repository를 만들어야 합니다.&lt;/p&gt;

&lt;p&gt;kubernetes helm &lt;a href=&quot;https://github.com/kubernetes/helm/blob/master/docs/chart_repository.md&quot;&gt;가이드&lt;/a&gt;에서 지원하는 방식은 3가지 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Github Pages&lt;/li&gt;
  &lt;li&gt;Object Storage(GCS, AWS S3)&lt;/li&gt;
  &lt;li&gt;Ordinary Web Servers&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github-pages&quot;&gt;Github Pages&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Github에 Repository 생성 및 docs 폴더 생성&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/YunSangJun/sj-charts&quot;&gt;샘플 코드&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Chart Repository
     | ㅡ docs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Github Page 설정&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Repository -&amp;gt; Settings -&amp;gt; Github Pages&lt;/code&gt; 메뉴 클릭&lt;/p&gt;

    &lt;p&gt;Source를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/docs&lt;/code&gt; 로 지정. 지정 후 아래와 같은 site 주소 확인&lt;/p&gt;

    &lt;p&gt;https://yunsangjun.github.io/sj-charts&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm Package 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # helm create mychart
 # helm package mychart
 # mv mychart-0.1.0.tgz docs
 # helm repo index docs --url https://yunsangjun.github.io/sj-charts
 # git add --all
 # git commit -m 'init'
 # git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm repository에 추가&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # helm repo add mychart https://yunsangjun.github.io/sj-charts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>윤상준</name></author><summary type="html">Helm chart를 개발한 후 외부에서 helm cli를 통해 다운로드 및 설치 하려면 Helm chart repository를 만들어야 합니다.</summary></entry><entry><title type="html">Docker 이미지 레이어란?</title><link href="http://localhost:4000/blog/docker/2018/05/26/docker-image-layer.html" rel="alternate" type="text/html" title="Docker 이미지 레이어란?" /><published>2018-05-26T00:00:00+09:00</published><updated>2018-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/docker/2018/05/26/docker-image-layer</id><content type="html" xml:base="http://localhost:4000/blog/docker/2018/05/26/docker-image-layer.html">&lt;p&gt;Docker Image를 pull, push 하다보면 layer라는 용어가 나옵니다. Docker 에서 사용하는 layer 구조가 무엇이고 왜 사용할까요?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
2a72cbf407d6: Pulling fs layer
04b2d3302d48: Pulling fs layer
e7f619103861: Pulling fs layer
...
2a72cbf407d6: Pull complete
04b2d3302d48: Pull complete
e7f619103861: Pull complete
Digest: sha256:18156dcd747677b03968621b2729d46021ce83a5bc15118e5bcced925fb4ebb9
Status: Downloaded newer image for nginx:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;docker-image-layer-구조란&quot;&gt;Docker Image Layer 구조란?&lt;/h2&gt;

&lt;p&gt;Dockerfile을 build 하면 정의된 명령어에 따라 Docker 이미지가 생성됩니다. 하나의 이미지로 보이지만 내부적으로는 여러개의 이미지가 층층히 쌓여있는 layer 구조입니다. 좀 더 쉽게 예를 들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;아래 예제는 nginx image를 build하기 위한 Dockerfile입니다. step1~6까지 총 6개의 명령으로 이루어져 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;Dockerfile&amp;gt;
# step1. Base image
FROM ubuntu:latest

# step2. Install Nginx.
RUN \
  apt-get update &amp;amp;&amp;amp; \
  apt-get install -y nginx

# step3. Define mountable directories.
VOLUME [&quot;/etc/nginx/sites-enabled&quot;, &quot;/etc/nginx/certs&quot;, &quot;/etc/nginx/conf.d&quot;, &quot;/var/log/nginx&quot;, &quot;/var/www/html&quot;]

# step4. Define working directory.
WORKDIR /etc/nginx

# step5. Define default command.
CMD [&quot;nginx&quot;]

# step6. Expose port.
EXPOSE 80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 Dockerfile을 build 해보겠습니다. 아래와 같이 각 명령어 단계마다 이미지가 생성됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker build -t nginx .
Sending build context to Docker daemon  2.048kB
Step 1/6 : FROM ubuntu:latest
...
 ---&amp;gt; c9d990395902    # 1번 이미지
Step 2/6 : RUN   apt-get update &amp;amp;&amp;amp;   apt-get install -y nginx
...
 ---&amp;gt; 90100bc32c07    # 2번 이미지
Step 3/6 : VOLUME [&quot;/etc/nginx/sites-enabled&quot;, &quot;/etc/nginx/certs&quot;, &quot;/etc/nginx/conf.d&quot;, &quot;/var/log/nginx&quot;, &quot;/var/www/html&quot;]
...
 ---&amp;gt; 8ea7a4443b1e    # 3번 이미지
Step 4/6 : WORKDIR /etc/nginx
...
 ---&amp;gt; 37773795f83d    # 4번 이미지
Step 5/6 : CMD [&quot;nginx&quot;]
...
 ---&amp;gt; 4f8728cb93dc    # 5번 이미지
Step 6/6 : EXPOSE 80
...
 ---&amp;gt; bec972ccfa66    # 6번 이미지
Successfully built b5d127ff2140
Successfully tagged nginx:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;왜-사용할까요&quot;&gt;왜 사용할까요?&lt;/h2&gt;

&lt;p&gt;그렇다면 이런 Image layer 구조는 왜 사용할까?
Nginx 이미지를 기반으로 Web App을 만들었다고 가정해보자. App source를 수정할 때 마다 전체 이미지를 다시 다운로드 받는다면 매우 비효율적이라 생각된다. 하지만 Docker Image는 layer 구조로 되어있기 때문에 Base image인 nginx image layer는 다운로드 받지 않고 변경된 source layer만 받게 된다. 이런 이유로 Docker Image는 layer 구조로 설계되어 있다.&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">Docker Image를 pull, push 하다보면 layer라는 용어가 나옵니다. Docker 에서 사용하는 layer 구조가 무엇이고 왜 사용할까요?</summary></entry><entry><title type="html">Docker Private Registry로 부터 이미지 가져오기</title><link href="http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry.html" rel="alternate" type="text/html" title="Docker Private Registry로 부터 이미지 가져오기" /><published>2018-05-25T00:00:00+09:00</published><updated>2018-05-25T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry.html">&lt;p&gt;이 페이지는 Secret을 사용하여 Private Docker Registry에서 이미지를 가져오는 Pod를 만드는 방법을 보여줍니다.&lt;br /&gt;
상세한 내용은 아래 링크를 참고하세요.&lt;/p&gt;

&lt;p&gt;https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&lt;/p&gt;

&lt;h2 id=&quot;docker-private-registry에-로그인&quot;&gt;Docker Private Registry에 로그인&lt;/h2&gt;

&lt;p&gt;개인 이미지를 가져오려면 Registry로 인증해야합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker login YOUR_REPOSITORY_URI
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;config.json&lt;/code&gt; 파일을 조회합니다. 해당 Repository에 대한 인증 토큰 정보가 출력됩니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat ~/.docker/config.json
{
    &quot;auths&quot;: {
        &quot;YOUR_REPOSITORY_URI&quot;: {
            &quot;auth&quot;: &quot;c3R...zE2&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;인증-토큰을-사용하여-secret-생성하기&quot;&gt;인증 토큰을 사용하여 Secret 생성하기&lt;/h2&gt;

&lt;p&gt;Kubernetes 클러스터는 docker-registry 유형의 Secret을 사용하여 컨테이너 레지스트리로 인증하여 개인 이미지를 가져옵니다.&lt;/p&gt;

&lt;p&gt;이 Secret 만들어서 이름을 regcred로 지정하십시오.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create secret docker-registry regcred --docker-server=&amp;lt;your-registry-server&amp;gt; --docker-username=&amp;lt;your-name&amp;gt; --docker-password=&amp;lt;your-pword&amp;gt; --docker-email=&amp;lt;your-email&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;your-registry-server : Private Docker Registry FQDN.&lt;/li&gt;
  &lt;li&gt;your-name : Docker username.&lt;/li&gt;
  &lt;li&gt;your-pword : Docker password.&lt;/li&gt;
  &lt;li&gt;your-email : Docker email.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;secret-확인하기&quot;&gt;Secret 확인하기&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;regcred&lt;/code&gt; Secret 내용 조회&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get secret regcred --output=yaml
apiVersion: v1
data:
  .dockercfg: eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=
kind: Secret
metadata:
  ...
  name: regcred
  ...
type: kubernetes.io/dockercfg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.dockercfg&lt;/code&gt; 정보 Decode&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get secret regcred --output=&quot;jsonpath={.data.\.dockercfg}&quot; | base64 --decode
{&quot;auths&quot;:{&quot;yourprivateregistry.com&quot;:{&quot;username&quot;:&quot;janedoe&quot;,&quot;password&quot;:&quot;xxxxxxxxxxx&quot;,&quot;email&quot;:&quot;jdoe@example.com&quot;,&quot;auth&quot;:&quot;c3R...zE2&quot;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인증 토큰 조회&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo &quot;c3R...zE2&quot; | base64 -d
janedoe:xxxxxxxxxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;secret을-사용하여-pod-생성하기&quot;&gt;Secret을 사용하여 Pod 생성하기&lt;/h2&gt;

&lt;p&gt;Pod yaml 생성&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi my-private-reg-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: private-reg
spec:
  containers:
  - name: private-reg-container
    image: &amp;lt;your-private-image&amp;gt;
  imagePullSecrets:
  - name: regcred
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod 배포. 정상적으로 완료했다면 이미지를 Docker Private Registry로 부터 가져오고 Pod가 Running 상태로 변경됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create -f my-private-reg-pod.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Secret을 사용하여 Private Docker Registry에서 이미지를 가져오는 Pod를 만드는 방법을 보여줍니다. 상세한 내용은 아래 링크를 참고하세요.</summary></entry><entry><title type="html">KubeCon &amp;amp; CloudNativeCon Europe 2018</title><link href="http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018.html" rel="alternate" type="text/html" title="KubeCon &amp; CloudNativeCon Europe 2018" /><published>2018-05-25T00:00:00+09:00</published><updated>2018-05-25T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018.html">&lt;h2 id=&quot;jenkins-x-easy-cicd-for-kubernetes---james-strachan-cloudbees&quot;&gt;Jenkins X: Easy CI/CD for Kubernetes - James Strachan, CloudBees&lt;/h2&gt;

&lt;h3 id=&quot;link&quot;&gt;Link&lt;/h3&gt;
&lt;p&gt;https://www.youtube.com/watch?v=uHe7R_iZSLU&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;</content><author><name>윤상준</name></author><summary type="html">Jenkins X: Easy CI/CD for Kubernetes - James Strachan, CloudBees</summary></entry><entry><title type="html">CloudFoundry Summit in 2018 Boston</title><link href="http://localhost:4000/blog/cloudfoundry/2018/05/25/cloudfoundry-summit-2018-boston.html" rel="alternate" type="text/html" title="CloudFoundry Summit in 2018 Boston" /><published>2018-05-25T00:00:00+09:00</published><updated>2018-05-25T00:00:00+09:00</updated><id>http://localhost:4000/blog/cloudfoundry/2018/05/25/cloudfoundry-summit-2018-boston</id><content type="html" xml:base="http://localhost:4000/blog/cloudfoundry/2018/05/25/cloudfoundry-summit-2018-boston.html">&lt;h2 id=&quot;cf3---putting-a-kubernetes-behind-cf---julz-friedman-andrew-edgar--julian-skupnjak-ibm&quot;&gt;CF^3 - Putting a Kubernetes Behind CF - Julz Friedman, Andrew Edgar &amp;amp; Julian Skupnjak, IBM&lt;/h2&gt;

&lt;h3 id=&quot;link&quot;&gt;Link&lt;/h3&gt;
&lt;p&gt;https://www.youtube.com/watch?v=9l3GgW95GmQ&amp;amp;list=PLhuMOCWn4P9hJD3wsstF8gJIxOnJ_CTot&amp;amp;index=17&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CloudFoundry의 핵심 가치는 개발자의 경험이다.(e.g cf push, service broker)&lt;/li&gt;
  &lt;li&gt;Container Orchestrator(Diego + Garden)는 다양하게 지원하게 어떨까?(Kubernetes, Swarm, Mesos..)&lt;/li&gt;
  &lt;li&gt;이를 위해 아래와 같은 것들을 개발 중
  1. OPI(Orchecstrator Provider Interface) : 다양한 Orchestrator를 지원하도록 추상화
  2. Sync : CF로 배포한 앱을 Kubernetes에 맞게 변환. Staged app을 Docker image로 변환.
  3. Registry : CF droplet에 기반한 OCI(Open Container Initiative) registry?
  4. St8ge : Kubernetes에 staging 실행. Buildpack 탐색 및 다운로드. Droplet 업로드&lt;/li&gt;
&lt;/ul&gt;</content><author><name>윤상준</name></author><summary type="html">CF^3 - Putting a Kubernetes Behind CF - Julz Friedman, Andrew Edgar &amp;amp; Julian Skupnjak, IBM</summary></entry><entry><title type="html">OAuth Proxy를 활용한 애플리케이션 인증 및 인가</title><link href="http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy.html" rel="alternate" type="text/html" title="OAuth Proxy를 활용한 애플리케이션 인증 및 인가" /><published>2018-05-23T00:00:00+09:00</published><updated>2018-05-23T00:00:00+09:00</updated><id>http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy</id><content type="html" xml:base="http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy.html">&lt;p&gt;OIDC(OpenID Connect identity providers)와 연계하여 애플리케이션의 인증을 해야하는 경우가 있습니다. 자체 개발한 애플리케이션의 경우 OIDC와 연동하기 위한 인증 기능을 개발하면 됩니다. 하지만 오픈소스를 사용하는 경우 해당 오픈소스에서 OIDC와의 연동기능을 제공하지 않으면 오픈소스의 코드를 수정해야합니다(예 : Kibana). 하지만 오픈소스의 코드를 수정하면 업스트림과의 일관성을 유지해야하는 부분이 부담스러울수 있습니다. 이 경우 &lt;a href=&quot;https://github.com/kubernetes/charts/tree/master/incubator/keycloak-proxy&quot;&gt;Keycloak Proxy&lt;/a&gt;와 같은 OAuth Proxy를 사용하여 애플리케이션의 인증/인가를 처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 페이지에서는 Keycloak Proxy를 활용하여 애플리케이션의 인증을 처리하는 방법에 대해 설명합니다.
아래의 “데모 애플리케이션”과 “Keycloak Proxy” 배포 따라하기를 통해 Keycloak Proxy를 활용한 인증방법을 쉽게 이해할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;h3 id=&quot;kubernetes-cluster-준비&quot;&gt;Kubernetes Cluster 준비&lt;/h3&gt;

&lt;p&gt;이 데모 애플리케이션과 Keycloak Proxy는 Kubernetes 환경을 위해 만들어졌습니다.&lt;/p&gt;

&lt;p&gt;퍼블릭 클라우드에서 제공하는 Kubernetes(GKE, IKS, AKS, EKS 등)나 Private Kubernetes, Minikube 등의 환경을 준비합니다.&lt;/p&gt;

&lt;h3 id=&quot;keycloakopenid-connect-provider-환경-준비&quot;&gt;Keycloak(OpenID Connect Provider) 환경 준비&lt;/h3&gt;

&lt;p&gt;Keycloak Proxy는 OIDC인 Keycloak과의 연동을 위해 디자인 되었지만 다른 OIDC 와도 연동할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/charts/tree/master/incubator/keycloak&quot;&gt;Keycloak Helm Chart&lt;/a&gt;를 활용하여 Keycloak을 쉽게 설치할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또는 이미 설치되어 있는 Keycloak이나 다른 OIDC(OpenID Connect identity providers)를 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;realm-client-role-생성&quot;&gt;Realm, Client, Role 생성&lt;/h3&gt;

&lt;p&gt;Keycloak Proxy와 Keycloak을 연동하기 위해서는 Keycloak 관리자 대시보드에서 Realm, Client, Role을 미리 생성해야합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/YunSangJun/keycloak-proxy-demo/blob/master/keycloak-guide.md&quot;&gt;Keycloak 가이드&lt;/a&gt;를 참고하여 Realm, Client, Role을 생성합니다.&lt;/p&gt;

&lt;h2 id=&quot;데모-애플리케이션-배포하기&quot;&gt;데모 애플리케이션 배포하기&lt;/h2&gt;

&lt;h3 id=&quot;구조&quot;&gt;구조&lt;/h3&gt;

&lt;p&gt;전제 조건 : 이 데모 애플리케이션에서는 Keycloak Proxy가 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; endpoint에 대해서만 권한을 체크하도록 설정했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Keycloak Proxy는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/user&lt;/code&gt; endpoint에 대한 클라이언트 요청을 허용합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/oauth-proxy/keycloak_proxy_flow_user_allow.png&quot; alt=&quot;Keycloak Proxy Flow Allow&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Keycloak Proxy는 클라이언트가 admin 권한을 가지고 있지 않다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; endpoint에 대한 클라이언트 요청을 거부합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/oauth-proxy/keycloak_proxy_flow_admin_deny.png&quot; alt=&quot;Keycloak Proxy Flow Deny&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Keycloak Proxy는 클라이언트가 admin 권한을 가지고 있다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; endpoint에 대한 클라이언트 요청을 허용합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/oauth-proxy/keycloak_proxy_flow_admin_allow.png&quot; alt=&quot;Keycloak Proxy Flow Deny&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;다운로드&quot;&gt;다운로드&lt;/h3&gt;

&lt;p&gt;아래 github 저장소에서 데모 애플리케이션을 다운로드합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/YunSangJun/keycloak-proxy-demo
$ cd keycloak-proxy-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;배포&quot;&gt;배포&lt;/h3&gt;

&lt;p&gt;아래 명령을 실행하여 애플리케이션과 서비스를 배포합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl apply -f deployment.yaml
$ kubectl apply -f service.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;배포-확인&quot;&gt;배포 확인&lt;/h3&gt;

&lt;p&gt;아래 명령을 실행하여 정상적으로 배포되었는지 확인합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get po,svc
NAME                       READY     STATUS    RESTARTS   AGE
po/demo-85cdbcc8c7-6pkbv   1/1       Running   0          10s

NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
svc/demo-service   ClusterIP   172.21.189.11   &amp;lt;none&amp;gt;        80/TCP    10s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;접속-확인&quot;&gt;접속 확인&lt;/h3&gt;

&lt;p&gt;데모 애플리케이션에 접속 할 수 있도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;port-forward&lt;/code&gt; 설정을 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl port-forward demo-85cdbcc8c7-6pkbv 8080:8080
Forwarding from 127.0.0.1:8080 -&amp;gt; 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://127.0.0.1:8080/user&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://127.0.0.1:8080/admin&lt;/code&gt;엡 접속해봅니다.
“Hello User!”와 “Hello Admin!” 메세지를 볼 수 있습니다.
현재는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/user&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; endpoint에 별도의 인증없이 접속 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 과정에서는 Keycloak Proxy를 배포하고 이를 Keycloak과 연계하여 admin 권한을 가진 사용자만 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; endpoint에 접속할 수 있도록 설정해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;keycloak-proxy-배포하기&quot;&gt;Keycloak Proxy 배포하기&lt;/h2&gt;

&lt;p&gt;아래 가이드를 참고하여 Keycloak Proxy를 배포해보겠습니다.&lt;/p&gt;

&lt;p&gt;Keycloak Proxy에 대한 자세한 설명은 &lt;a href=&quot;https://github.com/kubernetes/charts/tree/master/incubator/keycloak-proxy&quot;&gt;Keycloak Proxy Helm Chart&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;values.yaml&lt;/code&gt; 작성하기&lt;/p&gt;

    &lt;p&gt;아래와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;values.yaml&lt;/code&gt;을 작성합니다.&lt;/p&gt;

    &lt;p&gt;참고: 사전 준비에서 Keycloak 관리자 대시보드에서 Realm, Client, Role을 생성했습니다. 이 정보를 아래 &lt;code class=&quot;highlighter-rouge&quot;&gt;configmap&lt;/code&gt; 속성에 작성해야합니다.
 이 페이지에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;NodePort&lt;/code&gt;를 사용해 서비스를 외부에 노출시켰습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadBalancer&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ingress&lt;/code&gt;를 사용할 수도 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; service:
   type: NodePort
   nodePort: 32589
   port: 80

 configmap:
   targetUrl: http://demo-service
   realm: demo
   realmPublicKey: &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsLa2YmPyakziINoUgRLrEHLCKcyz62LhLU4JQsbJXMa1Zj4u/bU5D4dau1WkF94ivKV1osvqJqtQ4jCJYfRYrhCYeYOZWB7YFxELj+zMyP72Gxqg/YfWXKrzVnI5MYdZNx52dWAvBVDsDrxiZzJ0Xc92qCdKnEbvpK50XCh15KjWSjucbcJPwGX6kclLCmX0V47ziSo83FjH3ddFP81Kmza3on569Xi0QAAx3g/ZgPgZOSuF9OWwh3aMTwkfx9DlGeU5pY7uqvjuM9v33g0tdpOEelRAqu0aH/HEFXk9Mn74U1GQU/drflQVWEbv+9YvnUJN4cGt0oqmwQYU+Ix4qwIDAQAB&quot;
   authServerUrl: http://url-to-keycloak.example.com/auth
   resource: demo
   secret: 2b2c17f0-245e-4978-a663-9a02a268a8f4
   pattern: /admin
   rolesAllowed: admin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Keycloak Proxy 배포하기&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 Keycloak Proxy를 배포합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ helm install --name keycloak-proxy -f values.yaml incubator/keycloak-proxy
 NAME:   keycloak-proxy
 LAST DEPLOYED: Wed May 16 01:17:25 2018
 STATUS: DEPLOYED

 RESOURCES:
 ==&amp;gt; v1beta1/Deployment
 NAME            DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
 keycloak-proxy  1        1        1           0          0s

 ==&amp;gt; v1/Pod(related)
 NAME                             READY  STATUS             RESTARTS  AGE
 keycloak-proxy-67df99bbd5-ckfx7  0/1    ContainerCreating  0         0s

 ==&amp;gt; v1/ConfigMap
 NAME                      DATA  AGE
 keycloak-proxy-configmap  1     0s

 ==&amp;gt; v1/Service
 NAME                    TYPE      CLUSTER-IP     EXTERNAL-IP  PORT(S)       AGE
 keycloak-proxy-service  NodePort  172.21.215.70  &amp;lt;none&amp;gt;       80:32589/TCP  0s


 NOTES:
 1. Keycloak Proxy can be accessed:

    * Within your cluster, at the following DNS name at port 80:

      keycloak-proxy.demo.svc.cluster.local

    * From outside the cluster, run these commands in the same shell:

      export NODE_PORT=$(kubectl get --namespace demo -o jsonpath=&quot;{.spec.ports[0].nodePort}&quot; services keycloak-proxy-service)
      export NODE_IP=$(kubectl get nodes --namespace demo -o jsonpath=&quot;{.items[0].status.addresses[0].address}&quot;)
      echo http://$NODE_IP:$NODE_PORT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;무엇이-일어났는지-확인하기&quot;&gt;무엇이 일어났는지 확인하기&lt;/h2&gt;

&lt;p&gt;이제 Keycloak Proxy에 접속하여 admin 권한을 가진 사용자만 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; endpoint에 접속할 수 있는지 확인해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://$NODE_IP:$NODE_PORT/user&lt;/code&gt; 접속&lt;/p&gt;

    &lt;p&gt;먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;/user&lt;/code&gt; endpoint에 접속해봅니다. 이전과 마찬가지로 인증없이 접근이 가능합니다.
 Keycloak Proxy 배포 시 &lt;code class=&quot;highlighter-rouge&quot;&gt;pattern&lt;/code&gt; 설정에 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; 패턴만 설정했기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;/user&lt;/code&gt; endpoint는 bypass 합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/oauth-proxy/page_user.png&quot; alt=&quot;Authentication and Authorization&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://$NODE_IP:$NODE_PORT/admin&lt;/code&gt; 접속&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;admin&lt;/code&gt; endpoint에 접속해봅니다. Keycloak Proxy는 클라이언트를 Keycloak 로그인 페이지로 redirect 시킵니다.
 Keycloak Proxy 배포 시 &lt;code class=&quot;highlighter-rouge&quot;&gt;pattern&lt;/code&gt; 설정에 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; 패턴을 체크하도록 설정했기 때문입니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/oauth-proxy/login1.png&quot; alt=&quot;Authentication and Authorization&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Keycloak 계정이 없다면 “Register” 버튼을 클릭하여 계정을 생성합니다.
 &lt;img src=&quot;/blog/assets/images/oauth-proxy/add_user.png&quot; alt=&quot;Authentication and Authorization&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Keycloak 계정으로 로그인합니다.
 &lt;img src=&quot;/blog/assets/images/oauth-proxy/login2.png&quot; alt=&quot;Authentication and Authorization&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;이제 로그인에 성공했다면 제어권이 다시 Keycloak Proxy로 넘어갑니다.
 만약 로그인한 계정이 admin 권한을 가지고 있지 않다면 “HTTP 403” 에러가 발생 할 수 있습니다.
 &lt;img src=&quot;/blog/assets/images/oauth-proxy/page_admin_error.png&quot; alt=&quot;Authentication and Authorization&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Keycloak 관리자 대시보드에 접속한 후 User 관리메뉴를 클릭합니다.
 로그인한 사용자 계정을 선택한 후 admin 권한을 사용자에게 부여합니다.
 &lt;img src=&quot;/blog/assets/images/oauth-proxy/role_mapping.png&quot; alt=&quot;Authentication and Authorization&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;이제 다시 접속해보면 아래와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; endpoint에 정상적으로 접근할 수 있습니다.
 &lt;img src=&quot;/blog/assets/images/oauth-proxy/page_admin_success.png&quot; alt=&quot;Authentication and Authorization&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>윤상준</name></author><summary type="html">OIDC(OpenID Connect identity providers)와 연계하여 애플리케이션의 인증을 해야하는 경우가 있습니다. 자체 개발한 애플리케이션의 경우 OIDC와 연동하기 위한 인증 기능을 개발하면 됩니다. 하지만 오픈소스를 사용하는 경우 해당 오픈소스에서 OIDC와의 연동기능을 제공하지 않으면 오픈소스의 코드를 수정해야합니다(예 : Kibana). 하지만 오픈소스의 코드를 수정하면 업스트림과의 일관성을 유지해야하는 부분이 부담스러울수 있습니다. 이 경우 Keycloak Proxy와 같은 OAuth Proxy를 사용하여 애플리케이션의 인증/인가를 처리할 수 있습니다.</summary></entry></feed>