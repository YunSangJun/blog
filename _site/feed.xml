<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.0">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2018-05-29T01:23:06+09:00</updated><id>http://localhost:4000/blog/</id><title type="html">윤상준의 기술 블로그</title><subtitle>Software &amp; Cloud Engineer 입니다. </subtitle><author><name>Yun SangJun</name></author><entry><title type="html">Helm 설치하기</title><link href="http://localhost:4000/blog/helm/2018/05/27/installing-helm.html" rel="alternate" type="text/html" title="Helm 설치하기" /><published>2018-05-27T00:00:00+09:00</published><updated>2018-05-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/27/installing-helm</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/27/installing-helm.html">&lt;p&gt;이 페이지는 Helm을 설치하는 방법에 대해 설명합니다.
자세한 내용은 &lt;a href=&quot;https://docs.helm.sh/using_helm/#installing-helm&quot;&gt;Installing Helm&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;helm-client-바이너리-다운로드&quot;&gt;Helm client 바이너리 다운로드&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/helm/releases&quot;&gt;Helm release&lt;/a&gt; 바이너리를 다운로드합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;바이너리 압축 해제합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  tar -zxvf helm-vX.X.X-OS_NAME-amd64.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Helm 바이너리를 원하는 위치로 이동시킵니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mv OS_NAME-amd64/helm /usr/local/bin/helm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tiller-설치&quot;&gt;Tiller 설치&lt;/h2&gt;

&lt;p&gt;Helm의 서버 부분 인 Tiller는 일반적으로 Kubernetes 클러스터 내부에서 실행됩니다. 그러나 개발을 위해 로컬로 실행될 수도 있고 원격 Kubernetes 클러스터와 통신하도록 구성 될 수도 있습니다.&lt;/p&gt;

&lt;p&gt;Tiller를 클러스터에 설치하는 가장 쉬운 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;helm init&lt;/code&gt;를 실행하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;helm init&lt;/code&gt; 실행 후 Tiller가 running 상태가 될 때까지 대기합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pods --namespace kube-system |grep tiller
tiller-deploy-7ccf99cd64-pd7c2        1/1       Running   0          3d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Helm client와 server의 버전을 확인합니다.
Server의 버전이 Client의 버전과 같거나 높아야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm version
Client: &amp;amp;version.Version{SemVer:&quot;v2.9.0&quot;, GitCommit:&quot;xxx&quot;, GitTreeState:&quot;clean&quot;}
Server: &amp;amp;version.Version{SemVer:&quot;v2.9.1&quot;, GitCommit:&quot;xxx&quot;, GitTreeState:&quot;clean&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Server를 제외한 Client만 설치하고 싶은 경우 아래와 같이 실행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm init --client-only
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 Helm을 활용해 chart를 Kubernetes에 배포할 수 있습니다.&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Helm을 설치하는 방법에 대해 설명합니다. 자세한 내용은 Installing Helm을 참고하세요.</summary></entry><entry><title type="html">Ingress TLS Secret 생성하기</title><link href="http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html" rel="alternate" type="text/html" title="Ingress TLS Secret 생성하기" /><published>2018-05-27T00:00:00+09:00</published><updated>2018-05-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html">&lt;p&gt;이 페이지에서는 Ingress에 TLS를 적용하기 위한 Secret을 생성하는 방법을 가이드합니다.&lt;/p&gt;

&lt;h2 id=&quot;tls-secret-생성&quot;&gt;TLS Secret 생성&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하여 TLS Secret을 생성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create secret tls example-tls --cert example.crt --key example.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 아래와 같이 yaml 파일 형태로 생성할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi secret.yaml
apiVersion: v1
data:
  tls.crt: base64 encoded cert
  tls.key: base64 encoded key
kind: Secret
metadata:
  name: example-tls
type: Opaque

$ kubectl create -f secret.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tls-secret을-ingress에-적용&quot;&gt;TLS Secret을 Ingress에 적용&lt;/h2&gt;

&lt;p&gt;아래와 같이 Ingress의 secretName 속성에 example-tls을 적용합니다.
이제 Ingress를 배포한 후 host로 접속하면 TLS가 적용된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: example-ingress
spec:
  rules:
  - host: example.com
    http:
      paths:
      - backend:
          serviceName: example
          servicePort: 80
  tls:
  - hosts:
    - example.com
    secretName: example-tls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지에서는 Ingress에 TLS를 적용하기 위한 Secret을 생성하는 방법을 가이드합니다.</summary></entry><entry><title type="html">Helm chart를 사용하여 Jenkins를 컨테이너로 배포하기</title><link href="http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart.html" rel="alternate" type="text/html" title="Helm chart를 사용하여 Jenkins를 컨테이너로 배포하기" /><published>2018-05-26T00:00:00+09:00</published><updated>2018-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart.html">&lt;p&gt;이 페이지는 Helm chart를 사용하여 Jenkins를 컨테이너로 배포하는 방법에 대해 설명합니다.
자세한 내용은 &lt;a href=&quot;https://github.com/kubernetes/charts/tree/master/stable/jenkins&quot;&gt;Jenkins Helm Chart&lt;/a&gt;에서 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;준비-사항&quot;&gt;준비 사항&lt;/h2&gt;

&lt;p&gt;아래 가이드를 참고하여 Helm Client를 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/helm/2018/05/27/installing-helm.html&quot;&gt;Helm 설치하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;빠른-설치&quot;&gt;빠른 설치&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하면 Kubernetes 클러스터에 Jenkins가 배포됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm install --name jenkins stable/jenkins
NAME:   jenkins
...
NOTES:
1. Get your 'admin' user password by running:
  printf $(kubectl get secret --namespace default jenkins -o jsonpath=&quot;{.data.jenkins-admin-password}&quot; | base64 --decode);echo
2. Get the Jenkins URL to visit by running these commands in the same shell:
  NOTE: It may take a few minutes for the LoadBalancer IP to be available.
        You can watch the status of by running 'kubectl get svc --namespace default -w jenkins'
  ...
  echo http://$SERVICE_IP:8080/login

3. Login with the password from step 1 and the username: admin

For more information on running Jenkins on Kubernetes, visit:
https://cloud.google.com/solutions/jenkins-on-container-engine
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정상적으로 설치가 완료되었다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOTES&lt;/code&gt;의 가이드를 참고하여 Jenkins 대시보드에 접속할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;참고 : 기본 설정을 사용하므로 클러스터 환경에 따라 설치 중 에러가 발생할 수 있습니다.
이런 경우 아래 가이드를 따라 사용자 설정 방식으로 배포 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사용자-정의-설치&quot;&gt;사용자 정의 설치&lt;/h2&gt;

&lt;h3 id=&quot;설정&quot;&gt;설정&lt;/h3&gt;

&lt;p&gt;사용자의 Kubernetes 클러스터 환경에 맞게 Jenkins의 서비스, 스토리지 등의 설정을 변경할 수 있습니다.
아래 가이드를 참고하여 사용자의 환경에 맞도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;values.yaml&lt;/code&gt; 파일을 작성합니다.&lt;/p&gt;

&lt;h4 id=&quot;jenkins-admin-사용자-암호&quot;&gt;Jenkins admin 사용자 암호&lt;/h4&gt;

&lt;p&gt;Jenkins admin의 초기 사용자 암호입니다. 기본 설정은 랜덤한 패스워드입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  AdminPassword: ExamplePassword
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;서비스&quot;&gt;서비스&lt;/h4&gt;

&lt;p&gt;서비스는 Jenkins 대시보드를 접속을 어떤 방식으로 제공할지에 대한 설정입니다.
기본 설정은 LoadBalancer 방식입니다. 사용자의 클러스터의 환경에 동적으로 제공되는 LoadBalancer 서비스가 있다면 사용 가능합니다.
LoadBalancer 서비스가 없다면 아래와 같이 NodePort 또는 Ingress 방식을 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;NodePort&lt;/p&gt;

    &lt;p&gt;NodePort를 사용하면 Worker Node의 Public IP를 통하여 서비스에 접근 할 수 있습니다.
ServiceType을 NodePort로 설정하고 NodePort에 30000~32767사이의 포트 번호를 입력합니다.
포트 번호를 입력하지 않으면 30000~32767사이의 숫자에서 랜덤하게 선택됩니다.&lt;/p&gt;

    &lt;p&gt;접속 URI 예시 : http://WORKER_NODE_PUBLIC_IP:3xxxx&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  ServiceType: NodePort
  NodePort: 30000-32767
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ingress&lt;/p&gt;

    &lt;p&gt;Ingress를 사용하면 Ingress Controller의 Public IP를 통하여 서비스에 접근 할 수 있습니다.
ServiceType을 ClusterIP로 설정하고 HostName에 원하는 도메인을 입력합니다.(이 때 도메인이 Ingress Controller의 Public IP와 연결되어야 합니다.)
SSL 접속을 지원하려면 TLS 설정의 secretName과 host명을 입력합니다.&lt;/p&gt;

    &lt;p&gt;Ingress TLS Secret 생성 방법은 아래 가이드를 참고하세요.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html&quot;&gt;Ingress TLS Secret 생성하기&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  ServiceType: ClusterIP
  HostName: jenkins.example.com
  Ingress:
    TLS:
      - secretName: example-tls
        hosts:
          - jenkins.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;스토리지&quot;&gt;스토리지&lt;/h4&gt;

&lt;p&gt;Jenkins는 영구적으로 저장해야 하는 데이터를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/jenkins_home&lt;/code&gt;에 저장합니다.
이 데이터를 영구적으로 저장하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/jenkins_home&lt;/code&gt; 폴더를 PV(Persistent Volume)에 mount 해야합니다.
사용자의 Cluster에서 동적으로 PV를 생성 및 관리해주는 기능이 있다면 별도의 설정이 필요없습니다.
GKE, AWS, AKS 등의 환경에서는 Storage Class를 정의하면 PV를 생성하고 관리합니다.
또한 미리 구성된 PVC(PersistentVolumeClaim)를 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Storage Class 사용&lt;/p&gt;

    &lt;p&gt;Storage Class를 사용하여 동적으로 PV를 생성합니다.
Storage Class 명은 아래와 같이 확인할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get storageclass
NAME                       PROVISIONER         AGE
default                    ibm.io/ibmc-file    41d
ibmc-block-bronze          ibm.io/ibmc-block   3d
ibmc-file-bronze           ibm.io/ibmc-file    26d
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;원하는 Storage Class 명을 입력합니다. Storage의 크기를 원하는 값으로 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Persistence:
  StorageClass: &quot;default&quot;
  Size: 8Gi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사전 구성된 PVC 사용&lt;/p&gt;

    &lt;p&gt;미리 구성된 PVC(PersistentVolumeClaim)를 사용합니다.
미리 구성된 PVC 명은 아래와 같이 확인할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pvc
NAME          STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS        AGE
jenkins-pvc   Bound     pvc-47aec304-5e4e-11e8-915d-82c09a00d8d2   20Gi       RWO            ibmc-block-bronze   3d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;미리 구성된 PVC 명을 입력합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Persistence:
  ExistingClaim: &quot;jenkins-pvc&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설치&quot;&gt;설치&lt;/h3&gt;

&lt;p&gt;이제 아래 명령을 실행하여 사용자 정의에 맞게 Jenkins를 설치합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm install --name jenkins -f values.yaml stable/jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Helm chart를 사용하여 Jenkins를 컨테이너로 배포하는 방법에 대해 설명합니다. 자세한 내용은 Jenkins Helm Chart에서 참고하세요.</summary></entry><entry><title type="html">Helm chart repository 호스팅</title><link href="http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository.html" rel="alternate" type="text/html" title="Helm chart repository 호스팅" /><published>2018-05-26T00:00:00+09:00</published><updated>2018-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository.html">&lt;p&gt;Helm chart를 개발한 후 외부에서 helm cli를 통해 다운로드 및 설치 하려면 Helm chart repository를 만들어야 합니다.&lt;/p&gt;

&lt;p&gt;kubernetes helm &lt;a href=&quot;https://github.com/kubernetes/helm/blob/master/docs/chart_repository.md&quot;&gt;가이드&lt;/a&gt;에서 지원하는 방식은 3가지 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Github Pages&lt;/li&gt;
  &lt;li&gt;Object Storage(GCS, AWS S3)&lt;/li&gt;
  &lt;li&gt;Ordinary Web Servers&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github-pages&quot;&gt;Github Pages&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Github에 Repository 생성 및 docs 폴더 생성&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/YunSangJun/sj-charts&quot;&gt;샘플 코드&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Chart Repository
     | ㅡ docs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Github Page 설정&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Repository -&amp;gt; Settings -&amp;gt; Github Pages&lt;/code&gt; 메뉴 클릭&lt;/p&gt;

    &lt;p&gt;Source를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/docs&lt;/code&gt; 로 지정. 지정 후 아래와 같은 site 주소 확인&lt;/p&gt;

    &lt;p&gt;https://yunsangjun.github.io/sj-charts&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm Package 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # helm create mychart
 # helm package mychart
 # mv mychart-0.1.0.tgz docs
 # helm repo index docs --url https://yunsangjun.github.io/sj-charts
 # git add --all
 # git commit -m 'init'
 # git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm repository에 추가&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # helm repo add mychart https://yunsangjun.github.io/sj-charts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>윤상준</name></author><summary type="html">Helm chart를 개발한 후 외부에서 helm cli를 통해 다운로드 및 설치 하려면 Helm chart repository를 만들어야 합니다.</summary></entry><entry><title type="html">Docker 이미지 레이어란?</title><link href="http://localhost:4000/blog/docker/2018/05/26/docker-image-layer.html" rel="alternate" type="text/html" title="Docker 이미지 레이어란?" /><published>2018-05-26T00:00:00+09:00</published><updated>2018-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/docker/2018/05/26/docker-image-layer</id><content type="html" xml:base="http://localhost:4000/blog/docker/2018/05/26/docker-image-layer.html">&lt;p&gt;Docker Image를 pull, push 하다보면 layer라는 용어가 나옵니다. Docker 에서 사용하는 layer 구조가 무엇이고 왜 사용할까요?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
2a72cbf407d6: Pulling fs layer
04b2d3302d48: Pulling fs layer
e7f619103861: Pulling fs layer
...
2a72cbf407d6: Pull complete
04b2d3302d48: Pull complete
e7f619103861: Pull complete
Digest: sha256:18156dcd747677b03968621b2729d46021ce83a5bc15118e5bcced925fb4ebb9
Status: Downloaded newer image for nginx:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;docker-image-layer-구조란&quot;&gt;Docker Image Layer 구조란?&lt;/h2&gt;

&lt;p&gt;Dockerfile을 build 하면 정의된 명령어에 따라 Docker 이미지가 생성됩니다. 하나의 이미지로 보이지만 내부적으로는 여러개의 이미지가 층층히 쌓여있는 layer 구조입니다. 좀 더 쉽게 예를 들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;아래 예제는 nginx image를 build하기 위한 Dockerfile입니다. step1~6까지 총 6개의 명령으로 이루어져 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;Dockerfile&amp;gt;
# step1. Base image
FROM ubuntu:latest

# step2. Install Nginx.
RUN \
  apt-get update &amp;amp;&amp;amp; \
  apt-get install -y nginx

# step3. Define mountable directories.
VOLUME [&quot;/etc/nginx/sites-enabled&quot;, &quot;/etc/nginx/certs&quot;, &quot;/etc/nginx/conf.d&quot;, &quot;/var/log/nginx&quot;, &quot;/var/www/html&quot;]

# step4. Define working directory.
WORKDIR /etc/nginx

# step5. Define default command.
CMD [&quot;nginx&quot;]

# step6. Expose port.
EXPOSE 80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 Dockerfile을 build 해보겠습니다. 아래와 같이 각 명령어 단계마다 이미지가 생성됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker build -t nginx .
Sending build context to Docker daemon  2.048kB
Step 1/6 : FROM ubuntu:latest
...
 ---&amp;gt; c9d990395902    # 1번 이미지
Step 2/6 : RUN   apt-get update &amp;amp;&amp;amp;   apt-get install -y nginx
...
 ---&amp;gt; 90100bc32c07    # 2번 이미지
Step 3/6 : VOLUME [&quot;/etc/nginx/sites-enabled&quot;, &quot;/etc/nginx/certs&quot;, &quot;/etc/nginx/conf.d&quot;, &quot;/var/log/nginx&quot;, &quot;/var/www/html&quot;]
...
 ---&amp;gt; 8ea7a4443b1e    # 3번 이미지
Step 4/6 : WORKDIR /etc/nginx
...
 ---&amp;gt; 37773795f83d    # 4번 이미지
Step 5/6 : CMD [&quot;nginx&quot;]
...
 ---&amp;gt; 4f8728cb93dc    # 5번 이미지
Step 6/6 : EXPOSE 80
...
 ---&amp;gt; bec972ccfa66    # 6번 이미지
Successfully built b5d127ff2140
Successfully tagged nginx:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;왜-사용할까요&quot;&gt;왜 사용할까요?&lt;/h2&gt;

&lt;p&gt;그렇다면 이런 Image layer 구조는 왜 사용할까?
Nginx 이미지를 기반으로 Web App을 만들었다고 가정해보자. App source를 수정할 때 마다 전체 이미지를 다시 다운로드 받는다면 매우 비효율적이라 생각된다. 하지만 Docker Image는 layer 구조로 되어있기 때문에 Base image인 nginx image layer는 다운로드 받지 않고 변경된 source layer만 받게 된다. 이런 이유로 Docker Image는 layer 구조로 설계되어 있다.&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">Docker Image를 pull, push 하다보면 layer라는 용어가 나옵니다. Docker 에서 사용하는 layer 구조가 무엇이고 왜 사용할까요?</summary></entry><entry><title type="html">Docker Private Registry로 부터 이미지 가져오기</title><link href="http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry.html" rel="alternate" type="text/html" title="Docker Private Registry로 부터 이미지 가져오기" /><published>2018-05-25T00:00:00+09:00</published><updated>2018-05-25T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry.html">&lt;p&gt;이 페이지는 Secret을 사용하여 Private Docker Registry에서 이미지를 가져오는 Pod를 만드는 방법을 보여줍니다.&lt;br /&gt;
상세한 내용은 아래 링크를 참고하세요.&lt;/p&gt;

&lt;p&gt;https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&lt;/p&gt;

&lt;h2 id=&quot;docker-private-registry에-로그인&quot;&gt;Docker Private Registry에 로그인&lt;/h2&gt;

&lt;p&gt;개인 이미지를 가져오려면 Registry로 인증해야합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker login YOUR_REPOSITORY_URI
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;config.json&lt;/code&gt; 파일을 조회합니다. 해당 Repository에 대한 인증 토큰 정보가 출력됩니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat ~/.docker/config.json
{
    &quot;auths&quot;: {
        &quot;YOUR_REPOSITORY_URI&quot;: {
            &quot;auth&quot;: &quot;c3R...zE2&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;인증-토큰을-사용하여-secret-생성하기&quot;&gt;인증 토큰을 사용하여 Secret 생성하기&lt;/h2&gt;

&lt;p&gt;Kubernetes 클러스터는 docker-registry 유형의 Secret을 사용하여 컨테이너 레지스트리로 인증하여 개인 이미지를 가져옵니다.&lt;/p&gt;

&lt;p&gt;이 Secret 만들어서 이름을 regcred로 지정하십시오.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create secret docker-registry regcred --docker-server=&amp;lt;your-registry-server&amp;gt; --docker-username=&amp;lt;your-name&amp;gt; --docker-password=&amp;lt;your-pword&amp;gt; --docker-email=&amp;lt;your-email&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;your-registry-server : Private Docker Registry FQDN.&lt;/li&gt;
  &lt;li&gt;your-name : Docker username.&lt;/li&gt;
  &lt;li&gt;your-pword : Docker password.&lt;/li&gt;
  &lt;li&gt;your-email : Docker email.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;secret-확인하기&quot;&gt;Secret 확인하기&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;regcred&lt;/code&gt; Secret 내용 조회&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get secret regcred --output=yaml
apiVersion: v1
data:
  .dockercfg: eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=
kind: Secret
metadata:
  ...
  name: regcred
  ...
type: kubernetes.io/dockercfg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.dockercfg&lt;/code&gt; 정보 Decode&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get secret regcred --output=&quot;jsonpath={.data.\.dockercfg}&quot; | base64 --decode
{&quot;auths&quot;:{&quot;yourprivateregistry.com&quot;:{&quot;username&quot;:&quot;janedoe&quot;,&quot;password&quot;:&quot;xxxxxxxxxxx&quot;,&quot;email&quot;:&quot;jdoe@example.com&quot;,&quot;auth&quot;:&quot;c3R...zE2&quot;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인증 토큰 조회&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo &quot;c3R...zE2&quot; | base64 -d
janedoe:xxxxxxxxxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;secret을-사용하여-pod-생성하기&quot;&gt;Secret을 사용하여 Pod 생성하기&lt;/h2&gt;

&lt;p&gt;Pod yaml 생성&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi my-private-reg-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: private-reg
spec:
  containers:
  - name: private-reg-container
    image: &amp;lt;your-private-image&amp;gt;
  imagePullSecrets:
  - name: regcred
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod 배포. 정상적으로 완료했다면 이미지를 Docker Private Registry로 부터 가져오고 Pod가 Running 상태로 변경됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create -f my-private-reg-pod.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Secret을 사용하여 Private Docker Registry에서 이미지를 가져오는 Pod를 만드는 방법을 보여줍니다. 상세한 내용은 아래 링크를 참고하세요.</summary></entry><entry><title type="html">KubeCon &amp;amp; CloudNativeCon Europe 2018</title><link href="http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018.html" rel="alternate" type="text/html" title="KubeCon &amp; CloudNativeCon Europe 2018" /><published>2018-05-25T00:00:00+09:00</published><updated>2018-05-25T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018.html">&lt;h2 id=&quot;jenkins-x-easy-cicd-for-kubernetes---james-strachan-cloudbees&quot;&gt;Jenkins X: Easy CI/CD for Kubernetes - James Strachan, CloudBees&lt;/h2&gt;

&lt;h3 id=&quot;link&quot;&gt;Link&lt;/h3&gt;
&lt;p&gt;https://www.youtube.com/watch?v=uHe7R_iZSLU&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;</content><author><name>윤상준</name></author><summary type="html">Jenkins X: Easy CI/CD for Kubernetes - James Strachan, CloudBees</summary></entry><entry><title type="html">CloudFoundry Summit in 2018 Boston</title><link href="http://localhost:4000/blog/cloudfoundry/2018/05/25/cloudfoundry-summit-2018-boston.html" rel="alternate" type="text/html" title="CloudFoundry Summit in 2018 Boston" /><published>2018-05-25T00:00:00+09:00</published><updated>2018-05-25T00:00:00+09:00</updated><id>http://localhost:4000/blog/cloudfoundry/2018/05/25/cloudfoundry-summit-2018-boston</id><content type="html" xml:base="http://localhost:4000/blog/cloudfoundry/2018/05/25/cloudfoundry-summit-2018-boston.html">&lt;h2 id=&quot;cf3---putting-a-kubernetes-behind-cf---julz-friedman-andrew-edgar--julian-skupnjak-ibm&quot;&gt;CF^3 - Putting a Kubernetes Behind CF - Julz Friedman, Andrew Edgar &amp;amp; Julian Skupnjak, IBM&lt;/h2&gt;

&lt;h3 id=&quot;link&quot;&gt;Link&lt;/h3&gt;
&lt;p&gt;https://www.youtube.com/watch?v=9l3GgW95GmQ&amp;amp;list=PLhuMOCWn4P9hJD3wsstF8gJIxOnJ_CTot&amp;amp;index=17&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CloudFoundry의 핵심 가치는 개발자의 경험이다.(e.g cf push, service broker)&lt;/li&gt;
  &lt;li&gt;Container Orchestrator(Diego + Garden)는 다양하게 지원하게 어떨까?(Kubernetes, Swarm, Mesos..)&lt;/li&gt;
  &lt;li&gt;이를 위해 아래와 같은 것들을 개발 중
  1. OPI(Orchecstrator Provider Interface) : 다양한 Orchestrator를 지원하도록 추상화
  2. Sync : CF로 배포한 앱을 Kubernetes에 맞게 변환. Staged app을 Docker image로 변환.
  3. Registry : CF droplet에 기반한 OCI(Open Container Initiative) registry?
  4. St8ge : Kubernetes에 staging 실행. Buildpack 탐색 및 다운로드. Droplet 업로드&lt;/li&gt;
&lt;/ul&gt;</content><author><name>윤상준</name></author><summary type="html">CF^3 - Putting a Kubernetes Behind CF - Julz Friedman, Andrew Edgar &amp;amp; Julian Skupnjak, IBM</summary></entry><entry><title type="html">OAuth Proxy를 활용한 애플리케이션 인증 및 인가</title><link href="http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy.html" rel="alternate" type="text/html" title="OAuth Proxy를 활용한 애플리케이션 인증 및 인가" /><published>2018-05-23T00:00:00+09:00</published><updated>2018-05-23T00:00:00+09:00</updated><id>http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy</id><content type="html" xml:base="http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy.html">&lt;p&gt;OpenID Connect Provider와 연계하여 애플리케이션의 인증을 해야하는 경우가 있습니다. 하지만 애플리케이션에서 OpenID Connect Provider와 연계하기 위한 플러그인을 제공하지 않거나 소스 코드를 수정할 수 없는 경우가 있습니다.(예 : Kibana). 이 경우 Keycloak Proxy와 같은 OAuth Proxy를 사용하여 이런 애플리케이션의 인증/인가를 처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 Keycloak Proxy를 활용하여 애플리케이션의 인증을 처리하는 방법에 대한 가이드를 제공합니다.
아래의 “데모 애플리케이션”과 “Keycloak Proxy” 배포 따라하기를 통해 Keycloak Proxy를 활용한 인증방법을 쉽게 이해할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;데모-애플리케이션-배포하기&quot;&gt;데모 애플리케이션 배포하기&lt;/h2&gt;

&lt;h3 id=&quot;구조&quot;&gt;구조&lt;/h3&gt;

&lt;h3 id=&quot;다운로드&quot;&gt;다운로드&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/YunSangJun/keycloak-proxy-demo
$ cd keycloak-proxy-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;배포&quot;&gt;배포&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl apply -f deployment.yaml
$ kubectl apply -f service.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;배포-확인&quot;&gt;배포 확인&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get po,svc
NAME                       READY     STATUS    RESTARTS   AGE
po/demo-85cdbcc8c7-6pkbv   1/1       Running   0          10s

NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
svc/demo-service   ClusterIP   172.21.189.11   &amp;lt;none&amp;gt;        80/TCP    10s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;접속-확인&quot;&gt;접속 확인&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://127.0.0.1:8080/user&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://127.0.0.1:8080/admin&lt;/code&gt;엡 접속해봅니다.
“Hello User!”와 “Hello Admin!” 메세지를 볼 수 있습니다.
현재는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/user&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; endpoint에 별도의 인증없이 접속 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 과정에서는 Keycloak(OpenID Connect Provider)을 통해 인증/인가를 거친 사용자만 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; endpoint에 접속할 수 있도록 설정해 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl port-forward demo-85cdbcc8c7-6pkbv 8080:8080
Forwarding from 127.0.0.1:8080 -&amp;gt; 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;keycloak-proxy-배포하기&quot;&gt;Keycloak Proxy 배포하기&lt;/h2&gt;</content><author><name>윤상준</name></author><summary type="html">OpenID Connect Provider와 연계하여 애플리케이션의 인증을 해야하는 경우가 있습니다. 하지만 애플리케이션에서 OpenID Connect Provider와 연계하기 위한 플러그인을 제공하지 않거나 소스 코드를 수정할 수 없는 경우가 있습니다.(예 : Kibana). 이 경우 Keycloak Proxy와 같은 OAuth Proxy를 사용하여 이런 애플리케이션의 인증/인가를 처리할 수 있습니다.</summary></entry><entry><title type="html">MountVolume.SetUp failed for volume pvc-xxx</title><link href="http://localhost:4000/blog/kubernetes/2018/05/16/volume-mount-failed.html" rel="alternate" type="text/html" title="MountVolume.SetUp failed for volume pvc-xxx" /><published>2018-05-16T00:00:00+09:00</published><updated>2018-05-16T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/16/volume-mount-failed</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/16/volume-mount-failed.html">&lt;h2 id=&quot;issue&quot;&gt;Issue&lt;/h2&gt;

&lt;p&gt;Pod가 STATUS가 ContainerCreating 상태임.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pod xxx
NAME   READY    STATUS              RESTARTS   AGE       IP        
xxx    0/1      ContainerCreating   0          1m        &amp;lt;none&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Describe 명령어로 상태를 확인.
Pod가 mount 하려는 pvc의 device가 이미 mount 되어 있음. Pod를 비정상 종료되면서 umount가 안된것으로 보임.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl describe pod xxx
...
Events:
  Type     Reason                 Age   From                     Message
  ----     ------                 ----  ----                     -------
  Normal   Scheduled              1m    default-scheduler        Successfully assigned xxx to 10.178.218.181
  Normal   SuccessfulMountVolume  1m    kubelet, 10.178.218.181  MountVolume.SetUp succeeded for volume &quot;default-token-z84t8&quot;
  Warning  FailedMount            13s   kubelet, 10.178.218.181  MountVolume.SetUp failed for volume &quot;pvc-xxx&quot; : mount command failed, status: Failure, reason: Error while mounting the volume &amp;amp;errors.errorString{s:&quot;RWO check has failed. DevicePath /var/lib/kubelet/plugins/kubernetes.io/flexvolume/ibm/ibmc-block/mounts/pvc-xxx is already mounted on mountpath /var/lib/kubelet/pods/496dc423-4da7-11e8-915d-82c09a00d8d2/volumes/ibm~ibmc-block/pvc-xxx &quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;해당 Pod가 실행중인 Node에 접속&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get pod xxx -o wide
 NAME  READY     STATUS              RESTARTS   AGE       IP        NODE
 xxx   0/1       ContainerCreating   0          1m        &amp;lt;none&amp;gt;    10.178.218.181

 $ ssh user@10.178.218.181
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해당 Pod가 mount 하려는 device를 찾아서 umount&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ df -h |grep xxx
 /dev/mapper/xxx  20G  232M  19G  2%   /var/lib/kubelet/plugins/kubernetes.io/flexvolume/ibm/ibmc-block/mounts/pvc-xxx

 $ umount -v /dev/mapper/xxx
 /dev/mapper/xxx umounted...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해당 Pod 삭제해 재시작하면 정상적으로 mount 됨&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl delete pod xxx

 $ kubectl describe pod xxx
 ...
 Events:
   Type    Reason                 Age   From                     Message
   ----    ------                 ----  ----                     -------
   Normal  Scheduled              43m   default-scheduler        Successfully assigned xxx to 10.178.218.181
   Normal  SuccessfulMountVolume  43m   kubelet, 10.178.218.181  MountVolume.SetUp succeeded for volume &quot;default-token-z84t8&quot;
   Normal  SuccessfulMountVolume  43m   kubelet, 10.178.218.181  MountVolume.SetUp succeeded for volume &quot;pvc-xxx&quot;
   ...
   Normal  Created                42m   kubelet, 10.178.218.181  Created container
   Normal  Started                42m   kubelet, 10.178.218.181  Started container

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>윤상준</name></author><summary type="html">Issue</summary></entry></feed>