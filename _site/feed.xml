<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.0">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2018-05-26T02:54:57+09:00</updated><id>http://localhost:4000/blog/</id><title type="html">SJ Tech Blog</title><subtitle>Software &amp; Cloud Engineer</subtitle><author><name>Yun SangJun</name></author><entry><title type="html">Helm chart repository 호스팅</title><link href="http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository.html" rel="alternate" type="text/html" title="Helm chart repository 호스팅" /><published>2018-05-26T02:44:00+09:00</published><updated>2018-05-26T02:44:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository.html">&lt;p&gt;Helm chart를 개발한 후 외부에서 helm cli를 통해 다운로드 및 설치 하려면 Helm chart repository를 만들어야 합니다.&lt;/p&gt;

&lt;p&gt;kubernetes helm &lt;a href=&quot;https://github.com/kubernetes/helm/blob/master/docs/chart_repository.md&quot;&gt;가이드&lt;/a&gt;에서 지원하는 방식은 3가지 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Github Pages&lt;/li&gt;
  &lt;li&gt;Object Storage(GCS, AWS S3)&lt;/li&gt;
  &lt;li&gt;Ordinary Web Servers&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github-pages&quot;&gt;Github Pages&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Github에 Repository 생성 및 docs 폴더 생성&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/YunSangJun/sj-charts&quot;&gt;샘플 코드&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Chart Repository
     | ㅡ docs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Github Page 설정&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Repository -&amp;gt; Settings -&amp;gt; Github Pages&lt;/code&gt; 메뉴 클릭&lt;/p&gt;

    &lt;p&gt;Source를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/docs&lt;/code&gt; 로 지정. 지정 후 아래와 같은 site 주소 확인&lt;/p&gt;

    &lt;p&gt;https://yunsangjun.github.io/sj-charts&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm Package 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # helm create mychart
 # helm package mychart
 # mv mychart-0.1.0.tgz docs
 # helm repo index docs --url https://yunsangjun.github.io/sj-charts
 # git add --all
 # git commit -m 'init'
 # git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm repository에 추가&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # helm repo add mychart https://yunsangjun.github.io/sj-charts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>윤상준</name></author><summary type="html">Helm chart를 개발한 후 외부에서 helm cli를 통해 다운로드 및 설치 하려면 Helm chart repository를 만들어야 합니다.</summary></entry><entry><title type="html">Docker Private Registry로 부터 이미지 가져오기</title><link href="http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry.html" rel="alternate" type="text/html" title="Docker Private Registry로 부터 이미지 가져오기" /><published>2018-05-25T18:41:05+09:00</published><updated>2018-05-25T18:41:05+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/25/pull-image-from-private-registry.html">&lt;p&gt;이 페이지는 Secret을 사용하여 Private Docker Registry에서 이미지를 가져오는 Pod를 만드는 방법을 보여줍니다.&lt;br /&gt;
상세한 내용은 아래 링크를 참고하세요.&lt;/p&gt;

&lt;p&gt;https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&lt;/p&gt;

&lt;h2 id=&quot;docker-private-registry에-로그인&quot;&gt;Docker Private Registry에 로그인&lt;/h2&gt;

&lt;p&gt;개인 이미지를 가져오려면 Registry로 인증해야합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker login YOUR_REPOSITORY_URI
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;config.json&lt;/code&gt; 파일을 조회합니다. 해당 Repository에 대한 인증 토큰 정보가 출력됩니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat ~/.docker/config.json
{
    &quot;auths&quot;: {
        &quot;YOUR_REPOSITORY_URI&quot;: {
            &quot;auth&quot;: &quot;c3R...zE2&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;인증-토큰을-사용하여-secret-생성하기&quot;&gt;인증 토큰을 사용하여 Secret 생성하기&lt;/h2&gt;

&lt;p&gt;Kubernetes 클러스터는 docker-registry 유형의 Secret을 사용하여 컨테이너 레지스트리로 인증하여 개인 이미지를 가져옵니다.&lt;/p&gt;

&lt;p&gt;이 Secret 만들어서 이름을 regcred로 지정하십시오.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create secret docker-registry regcred --docker-server=&amp;lt;your-registry-server&amp;gt; --docker-username=&amp;lt;your-name&amp;gt; --docker-password=&amp;lt;your-pword&amp;gt; --docker-email=&amp;lt;your-email&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;your-registry-server : Private Docker Registry FQDN.&lt;/li&gt;
  &lt;li&gt;your-name : Docker username.&lt;/li&gt;
  &lt;li&gt;your-pword : Docker password.&lt;/li&gt;
  &lt;li&gt;your-email : Docker email.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;secret-확인하기&quot;&gt;Secret 확인하기&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;regcred&lt;/code&gt; Secret 내용 조회&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get secret regcred --output=yaml
apiVersion: v1
data:
  .dockercfg: eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=
kind: Secret
metadata:
  ...
  name: regcred
  ...
type: kubernetes.io/dockercfg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.dockercfg&lt;/code&gt; 정보 Decode&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get secret regcred --output=&quot;jsonpath={.data.\.dockercfg}&quot; | base64 --decode
{&quot;auths&quot;:{&quot;yourprivateregistry.com&quot;:{&quot;username&quot;:&quot;janedoe&quot;,&quot;password&quot;:&quot;xxxxxxxxxxx&quot;,&quot;email&quot;:&quot;jdoe@example.com&quot;,&quot;auth&quot;:&quot;c3R...zE2&quot;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인증 토큰 조회&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo &quot;c3R...zE2&quot; | base64 -d
janedoe:xxxxxxxxxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;secret을-사용하여-pod-생성하기&quot;&gt;Secret을 사용하여 Pod 생성하기&lt;/h2&gt;

&lt;p&gt;Pod yaml 생성&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi my-private-reg-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: private-reg
spec:
  containers:
  - name: private-reg-container
    image: &amp;lt;your-private-image&amp;gt;
  imagePullSecrets:
  - name: regcred
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod 배포. 정상적으로 완료했다면 이미지를 Docker Private Registry로 부터 가져오고 Pod가 Running 상태로 변경됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create -f my-private-reg-pod.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Secret을 사용하여 Private Docker Registry에서 이미지를 가져오는 Pod를 만드는 방법을 보여줍니다. 상세한 내용은 아래 링크를 참고하세요.</summary></entry><entry><title type="html">KubeCon &amp;amp; CloudNativeCon Europe 2018</title><link href="http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018.html" rel="alternate" type="text/html" title="KubeCon &amp; CloudNativeCon Europe 2018" /><published>2018-05-25T01:45:05+09:00</published><updated>2018-05-25T01:45:05+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/25/kubecon-2018.html">&lt;h2 id=&quot;jenkins-x-easy-cicd-for-kubernetes---james-strachan-cloudbees&quot;&gt;Jenkins X: Easy CI/CD for Kubernetes - James Strachan, CloudBees&lt;/h2&gt;

&lt;h3 id=&quot;link&quot;&gt;Link&lt;/h3&gt;
&lt;p&gt;https://www.youtube.com/watch?v=uHe7R_iZSLU&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;</content><author><name>윤상준</name></author><summary type="html">Jenkins X: Easy CI/CD for Kubernetes - James Strachan, CloudBees</summary></entry><entry><title type="html">CloudFoundry Summit in 2018 Boston</title><link href="http://localhost:4000/blog/cloudfoundry/2018/05/25/cloudfoundry-summit-2018-boston.html" rel="alternate" type="text/html" title="CloudFoundry Summit in 2018 Boston" /><published>2018-05-25T01:45:05+09:00</published><updated>2018-05-25T01:45:05+09:00</updated><id>http://localhost:4000/blog/cloudfoundry/2018/05/25/cloudfoundry-summit-2018-boston</id><content type="html" xml:base="http://localhost:4000/blog/cloudfoundry/2018/05/25/cloudfoundry-summit-2018-boston.html">&lt;h2 id=&quot;cf3---putting-a-kubernetes-behind-cf---julz-friedman-andrew-edgar--julian-skupnjak-ibm&quot;&gt;CF^3 - Putting a Kubernetes Behind CF - Julz Friedman, Andrew Edgar &amp;amp; Julian Skupnjak, IBM&lt;/h2&gt;

&lt;h3 id=&quot;link&quot;&gt;Link&lt;/h3&gt;
&lt;p&gt;https://www.youtube.com/watch?v=9l3GgW95GmQ&amp;amp;list=PLhuMOCWn4P9hJD3wsstF8gJIxOnJ_CTot&amp;amp;index=17&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CloudFoundry의 핵심 가치는 개발자의 경험이다.(e.g cf push, service broker)&lt;/li&gt;
  &lt;li&gt;Container Orchestrator(Diego + Garden)는 다양하게 지원하게 어떨까?(Kubernetes, Swarm, Mesos..)&lt;/li&gt;
  &lt;li&gt;이를 위해 아래와 같은 것들을 개발 중
  1. OPI(Orchecstrator Provider Interface) : 다양한 Orchestrator를 지원하도록 추상화
  2. Sync : CF로 배포한 앱을 Kubernetes에 맞게 변환. Staged app을 Docker image로 변환.
  3. Registry : CF droplet에 기반한 OCI(Open Container Initiative) registry?
  4. St8ge : Kubernetes에 staging 실행. Buildpack 탐색 및 다운로드. Droplet 업로드&lt;/li&gt;
&lt;/ul&gt;</content><author><name>윤상준</name></author><summary type="html">CF^3 - Putting a Kubernetes Behind CF - Julz Friedman, Andrew Edgar &amp;amp; Julian Skupnjak, IBM</summary></entry><entry><title type="html">OAuth Proxy를 활용한 애플리케이션 인증 및 인가</title><link href="http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy.html" rel="alternate" type="text/html" title="OAuth Proxy를 활용한 애플리케이션 인증 및 인가" /><published>2018-05-23T02:01:05+09:00</published><updated>2018-05-23T02:01:05+09:00</updated><id>http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy</id><content type="html" xml:base="http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy.html">&lt;p&gt;OpenID Connect Provider와 연계하여 애플리케이션의 인증을 해야하는 경우가 있습니다. 하지만 애플리케이션에서 OpenID Connect Provider와 연계하기 위한 플러그인을 제공하지 않거나 소스 코드를 수정할 수 없는 경우가 있습니다.(예 : Kibana). 이 경우 Keycloak Proxy와 같은 OAuth Proxy를 사용하여 이런 애플리케이션의 인증/인가를 처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 Keycloak Proxy를 활용하여 애플리케이션의 인증을 처리하는 방법에 대한 가이드를 제공합니다.
아래의 “데모 애플리케이션”과 “Keycloak Proxy” 배포 따라하기를 통해 Keycloak Proxy를 활용한 인증방법을 쉽게 이해할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;데모-애플리케이션-배포하기&quot;&gt;데모 애플리케이션 배포하기&lt;/h2&gt;

&lt;h3 id=&quot;구조&quot;&gt;구조&lt;/h3&gt;

&lt;h3 id=&quot;다운로드&quot;&gt;다운로드&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/YunSangJun/keycloak-proxy-demo
$ cd keycloak-proxy-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;배포&quot;&gt;배포&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl apply -f deployment.yaml
$ kubectl apply -f service.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;배포-확인&quot;&gt;배포 확인&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get po,svc
NAME                       READY     STATUS    RESTARTS   AGE
po/demo-85cdbcc8c7-6pkbv   1/1       Running   0          10s

NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
svc/demo-service   ClusterIP   172.21.189.11   &amp;lt;none&amp;gt;        80/TCP    10s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;접속-확인&quot;&gt;접속 확인&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://127.0.0.1:8080/user&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://127.0.0.1:8080/admin&lt;/code&gt;엡 접속해봅니다.
“Hello User!”와 “Hello Admin!” 메세지를 볼 수 있습니다.
현재는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/user&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; endpoint에 별도의 인증없이 접속 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 과정에서는 Keycloak(OpenID Connect Provider)을 통해 인증/인가를 거친 사용자만 &lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt; endpoint에 접속할 수 있도록 설정해 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl port-forward demo-85cdbcc8c7-6pkbv 8080:8080
Forwarding from 127.0.0.1:8080 -&amp;gt; 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;keycloak-proxy-배포하기&quot;&gt;Keycloak Proxy 배포하기&lt;/h2&gt;</content><author><name>윤상준</name></author><summary type="html">OpenID Connect Provider와 연계하여 애플리케이션의 인증을 해야하는 경우가 있습니다. 하지만 애플리케이션에서 OpenID Connect Provider와 연계하기 위한 플러그인을 제공하지 않거나 소스 코드를 수정할 수 없는 경우가 있습니다.(예 : Kibana). 이 경우 Keycloak Proxy와 같은 OAuth Proxy를 사용하여 이런 애플리케이션의 인증/인가를 처리할 수 있습니다.</summary></entry><entry><title type="html">MountVolume.SetUp failed for volume pvc-xxx</title><link href="http://localhost:4000/blog/kubernetes/2018/05/16/volume-mount-failed.html" rel="alternate" type="text/html" title="MountVolume.SetUp failed for volume pvc-xxx" /><published>2018-05-16T21:20:05+09:00</published><updated>2018-05-16T21:20:05+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/16/volume-mount-failed</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/16/volume-mount-failed.html">&lt;h2 id=&quot;issue&quot;&gt;Issue&lt;/h2&gt;

&lt;p&gt;Pod가 STATUS가 ContainerCreating 상태임.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pod xxx
NAME   READY    STATUS              RESTARTS   AGE       IP        
xxx    0/1      ContainerCreating   0          1m        &amp;lt;none&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Describe 명령어로 상태를 확인.
Pod가 mount 하려는 pvc의 device가 이미 mount 되어 있음. Pod를 비정상 종료되면서 umount가 안된것으로 보임.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl describe pod xxx
...
Events:
  Type     Reason                 Age   From                     Message
  ----     ------                 ----  ----                     -------
  Normal   Scheduled              1m    default-scheduler        Successfully assigned xxx to 10.178.218.181
  Normal   SuccessfulMountVolume  1m    kubelet, 10.178.218.181  MountVolume.SetUp succeeded for volume &quot;default-token-z84t8&quot;
  Warning  FailedMount            13s   kubelet, 10.178.218.181  MountVolume.SetUp failed for volume &quot;pvc-xxx&quot; : mount command failed, status: Failure, reason: Error while mounting the volume &amp;amp;errors.errorString{s:&quot;RWO check has failed. DevicePath /var/lib/kubelet/plugins/kubernetes.io/flexvolume/ibm/ibmc-block/mounts/pvc-xxx is already mounted on mountpath /var/lib/kubelet/pods/496dc423-4da7-11e8-915d-82c09a00d8d2/volumes/ibm~ibmc-block/pvc-xxx &quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;해당 Pod가 실행중인 Node에 접속&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get pod xxx -o wide
 NAME  READY     STATUS              RESTARTS   AGE       IP        NODE
 xxx   0/1       ContainerCreating   0          1m        &amp;lt;none&amp;gt;    10.178.218.181

 $ ssh user@10.178.218.181
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해당 Pod가 mount 하려는 device를 찾아서 umount&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ df -h |grep xxx
 /dev/mapper/xxx  20G  232M  19G  2%   /var/lib/kubelet/plugins/kubernetes.io/flexvolume/ibm/ibmc-block/mounts/pvc-xxx

 $ umount -v /dev/mapper/xxx
 /dev/mapper/xxx umounted...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해당 Pod 삭제해 재시작하면 정상적으로 mount 됨&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl delete pod xxx

 $ kubectl describe pod xxx
 ...
 Events:
   Type    Reason                 Age   From                     Message
   ----    ------                 ----  ----                     -------
   Normal  Scheduled              43m   default-scheduler        Successfully assigned xxx to 10.178.218.181
   Normal  SuccessfulMountVolume  43m   kubelet, 10.178.218.181  MountVolume.SetUp succeeded for volume &quot;default-token-z84t8&quot;
   Normal  SuccessfulMountVolume  43m   kubelet, 10.178.218.181  MountVolume.SetUp succeeded for volume &quot;pvc-xxx&quot;
   ...
   Normal  Created                42m   kubelet, 10.178.218.181  Created container
   Normal  Started                42m   kubelet, 10.178.218.181  Started container

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>윤상준</name></author><summary type="html">Issue</summary></entry><entry><title type="html">Istio Intelligent Routing #3 가중치 기반 라우팅</title><link href="http://localhost:4000/blog/istio/2018/05/07/istio-intelligent-routing-3.html" rel="alternate" type="text/html" title="Istio Intelligent Routing #3 가중치 기반 라우팅" /><published>2018-05-07T15:20:05+09:00</published><updated>2018-05-07T15:20:05+09:00</updated><id>http://localhost:4000/blog/istio/2018/05/07/istio-intelligent-routing-3</id><content type="html" xml:base="http://localhost:4000/blog/istio/2018/05/07/istio-intelligent-routing-3.html">&lt;p&gt;이 문서는 서비스의 이전 버전에서 새 버전으로 트래픽을 점진적으로 마이그레이션하는 방법을 보여줍니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Kubernetes에 Istio 설치하기&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/istio/2018/04/26/deploying-istio-on-kubernetes.html&quot;&gt;Kubernetes에 Istio 설치하기&lt;/a&gt;를 참고하여 Kubernetes에 Istio 설치합니다.&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;마이크로서비스 샘플앱(BookInfo) 배포하기&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/istio/2018/04/26/deploying-bookinfo-on-kubernetes.html&quot;&gt;마이크로서비스 샘플앱(BookInfo) 배포하기&lt;/a&gt;를 참고하여 Kubernetes에 BookInfo 애플리케이션을 배포합니다.&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;가중치-기반-라우팅&quot;&gt;가중치 기반 라우팅&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;모든 마이크로서비스 대해 기본 버전을 v1으로 적용합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl create -f samples/bookinfo/kube/route-rule-all-v1.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;아래 명령어를 통해 route rule을 조회할 수 있습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl get routerules -o yaml
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: details-default
   namespace: default
   ...
 spec:
   destination:
     name: details
   precedence: 1
   route:
   - labels:
       version: v1
 ---
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: productpage-default
   namespace: default
   ...
 spec:
   destination:
     name: productpage
   precedence: 1
   route:
   - labels:
       version: v1
 ---
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: ratings-default
   namespace: default
   ...
 spec:
   destination:
     name: ratings
   precedence: 1
   route:
   - labels:
       version: v1
 ---
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: reviews-default
   namespace: default
   ...
 spec:
   destination:
     name: reviews
   precedence: 1
   route:
   - labels:
       version: v1
 ---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;브라우저에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://$GATEWAY_ADDRESS/productpage&lt;/code&gt; 페이지를 열어 v1이 reviews 서비스의 기본 버전인지 확인합니다.&lt;/p&gt;

    &lt;p&gt;Bookinfo 애플리케이션의 productpage가 표시되어야합니다. v1은 ratings 서비스에 액세스하지 않으므로 productpage에 별표가 표시되지 않습니다.&lt;/p&gt;

    &lt;p&gt;참고 : 이전에 콘텐츠 기반 라우팅 작업을 실행 한 경우 테스트 사용자 &lt;code class=&quot;highlighter-rouge&quot;&gt;jason&lt;/code&gt;으로 로그 아웃하거나 생성 된 테스트 규칙을 삭제해야 합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl delete routerule reviews-test-v2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;먼저 트래픽을 reviews:v1과 reviews:v3에 50:50 비율로 전송합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl replace -f samples/bookinfo/kube/route-rule-reviews-50-v3.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;아래 명령어를 통해 route rule을 조회할 수 있습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl get routerule reviews-default -o yaml
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: reviews-default
   namespace: default
 spec:
   destination:
     name: reviews
   precedence: 1
   route:
   - labels:
       version: v1
     weight: 50
   - labels:
       version: v3
     weight: 50
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;브라우저에서 productpage를 새로 고침하면 빨간색 별표가 약 50%의 비율로 표시됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/istio_intel_routing_contents_red_rating.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이번에는 트래픽을 reviews:v1과 reviews:v3에 20:80 비율로 전송합니다.&lt;/p&gt;

    &lt;p&gt;아래와 같이 route rule을 수정합니다.&lt;/p&gt;

    &lt;p&gt;참고 : istioctl CLI에는 edit 명령어가 없으므로 kubectl 명령어를 사용합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl edit routerule reviews-default
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: reviews-default
   namespace: default
 spec:
   destination:
     name: reviews
   precedence: 1
   route:
   - labels:
       version: v1
     weight: 20
   - labels:
       version: v3
     weight: 80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;브라우저에서 productpage를 새로 고침하면 빨간색 별표가 약 80%의 비율로 표시됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;reviews 마이크로서비스의 버전 v3가 안정적이라고 판단되면 트래픽의 100%를 reviews:v3에 라우팅 할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl replace -f samples/bookinfo/kube/route-rule-reviews-v3.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;이제 아무 사용자로 제품 페이지에 로그인 할 수 있으며 항상 빨간색 별표가 표시됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;이해하기&quot;&gt;이해하기&lt;/h2&gt;
&lt;p&gt;이 예제에서는 Istio의 가중치 기반 라우팅 기능을 사용하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews&lt;/code&gt; 서비스로의 트래픽을 이전 버전에서 새 버전으로 마이그레이션했습니다. 이는 인스턴스 scaling을 사용하여 트래픽을 관리하는 컨테이너 오케스트레이션 플랫폼의 배포 기능을 사용하는 버전 마이그레이션과 매우 다릅니다. Istio를 사용하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews&lt;/code&gt; 서비스의 두 버전간의 트래픽 분산에 영향을 미치지 않고 독립적으로 확장 및 축소 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;p&gt;https://istio.io/docs/tasks/traffic-management/traffic-shifting.html&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">이 문서는 서비스의 이전 버전에서 새 버전으로 트래픽을 점진적으로 마이그레이션하는 방법을 보여줍니다.</summary></entry><entry><title type="html">Istio Intelligent Routing #2 오류 주입</title><link href="http://localhost:4000/blog/istio/2018/05/02/istio-intelligent-routing-2.html" rel="alternate" type="text/html" title="Istio Intelligent Routing #2 오류 주입" /><published>2018-05-02T20:11:20+09:00</published><updated>2018-05-02T20:11:20+09:00</updated><id>http://localhost:4000/blog/istio/2018/05/02/istio-intelligent-routing-2</id><content type="html" xml:base="http://localhost:4000/blog/istio/2018/05/02/istio-intelligent-routing-2.html">&lt;p&gt;이 문서는 지연을 주입하고 애플리케이션의 복원력을 테스트하는 방법을 보여줍니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Kubernetes에 Istio 설치하기&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/istio/2018/04/26/deploying-istio-on-kubernetes.html&quot;&gt;Kubernetes에 Istio 설치하기&lt;/a&gt;를 참고하여 Kubernetes에 Istio 설치합니다.&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;마이크로서비스 샘플앱(BookInfo) 배포하기&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/istio/2018/04/26/deploying-bookinfo-on-kubernetes.html&quot;&gt;마이크로서비스 샘플앱(BookInfo) 배포하기&lt;/a&gt;를 참고하여 Kubernetes에 BookInfo 애플리케이션을 배포합니다.&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션의 버전 라우팅 초기화하기&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 버전 라우팅을 초기화합니다. 이미 생성한 라우팅이 있으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;create&lt;/code&gt; 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;replace&lt;/code&gt; 명령을 사용합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; istioctl create -f samples/bookinfo/kube/route-rule-all-v1.yaml
 istioctl create -f samples/bookinfo/kube/route-rule-reviews-test-v2.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;http-지연을-사용한-오류-주입&quot;&gt;HTTP 지연을 사용한 오류 주입&lt;/h2&gt;
&lt;p&gt;Bookinfo 마이크로서비스의 복원력을 테스트하기 위해, &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews:v2&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;ratings&lt;/code&gt; 마이크로서비스 사이에 7s의 지연을 주입합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews:v2&lt;/code&gt; 서비스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ratings&lt;/code&gt; 서비스로의 요청에 대해 10s의 timeout을 갖기 때문에, 그 요청에 에러가 발생하지 않을 것으로 예상할 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;사용자 &lt;code class=&quot;highlighter-rouge&quot;&gt;jason&lt;/code&gt;의 트래픽을 지연시키는 오류 주입 규칙을 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl create -f samples/bookinfo/kube/route-rule-ratings-test-delay.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;생성한 규칙 확인&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl get routerule ratings-test-delay -o yaml
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: ratings-test-delay
   namespace: default
   ...
 spec:
   destination:
     name: ratings
   httpFault:
     delay:
       fixedDelay: 7.000s
       percent: 100
   match:
     request:
       headers:
         cookie:
           regex: ^(.*?;)?(user=jason)(;.*)?$
   precedence: 2
   route:
   - labels:
       version: v1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;모든 pods에 규칙이 전파되도록 몇 초간 대기합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션의 동작 확인&lt;/p&gt;

    &lt;p&gt;사용자 &lt;code class=&quot;highlighter-rouge&quot;&gt;jason&lt;/code&gt;으로 로그인합니다. 애플리케이션의 프론트 페이지가 지연을 올바르게 처리하도록 설정되어 있으면, 약 7초 내로 로드될 것으로 예상됩니다.
 웹 페이지 응답 시간을 보려면, IE, Chrome 또는 Firefox (일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl + Shift + I&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Alt + Cmd + I&lt;/code&gt; 키 조합)의 개발자 도구 메뉴를 열고 네트워크 탭을 클릭 한 다음 &lt;code class=&quot;highlighter-rouge&quot;&gt;productpage&lt;/code&gt;를 다시 로드하십시오.&lt;br /&gt;
 약 6 초 후에 웹 페이지가 로드됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews&lt;/code&gt; 섹션에 &lt;b&gt;“죄송합니다. 현재 이 책에 대한 제품 리뷰를 사용할 수 없습니다.”&lt;/b&gt;라고 표시 될 것입니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/istio_fault_injection_delay_error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;이해하기&quot;&gt;이해하기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reviews&lt;/code&gt; 서비스에 에러가 난 이유는 Bookinfo 애플리케이션에 버그가 있기 때문입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;productpage&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews&lt;/code&gt; 서비스 간의 timeout(3s + 1 retry = 6s total)은 &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;ratings&lt;/code&gt; 서비스 사이의 timeout(10s)보다 작습니다. 이런 버그는 서로 다른 팀이 마이크로서비스를 독립적으로 개발하는 환경에서 발생할 수 있습니다. Istio의 &lt;b&gt;오류 주입&lt;/b&gt; 규칙은 사용자에게 영향을 주지 않고 이런 예외를 식별하는 데 도움을 줍니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 예제에서는 에러가 사용자 &lt;code class=&quot;highlighter-rouge&quot;&gt;jason&lt;/code&gt;에게만 영향을 주도록 제한하고 있습니다. 다른 사용자로 로그인하면 지연이 발생하지 않습니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;버그 수정: 일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;productpage&lt;/code&gt; timeout 늘리거나 &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;ratings&lt;/code&gt; 서비스 간의 timeout을 줄여 문제를 해결합니다.&lt;br /&gt;
아래와 같이 지연을 2.8초로 변경하여 문제가 해결되는지 확인합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl edit routerule ratings-test-delay
apiVersion: config.istio.io/v1alpha2
kind: RouteRule
metadata:
  creationTimestamp: null
  name: ratings-test-delay
  ...
spec:
  destination:
    name: ratings
  httpFault:
    delay:
      fixedDelay: 2.800s
      percent: 100
  match:
    request:
      headers:
        cookie:
          regex: ^(.*?;)?(user=jason)(;.*)?$
  precedence: 2
  route:
  - labels:
      version: v1
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/istio_fault_injection_delay_fixed.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;http-중단을-사용한-오류-주입&quot;&gt;HTTP 중단을 사용한 오류 주입&lt;/h2&gt;
&lt;p&gt;다른 복원력 테스트 방법으로써 HTTP 중단을 소개합니다. 지연을 통한 방법과 달리 페이지가 즉시 로드되고 ‘ratings 서비스 사용할 수 없음’이라는 메시지가 표시됩니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;지연을 사용한 오류 주입 규칙을 삭제합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl delete -f samples/bookinfo/kube/route-rule-ratings-test-delay.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용자 &lt;code class=&quot;highlighter-rouge&quot;&gt;jason&lt;/code&gt;에게 HTTP 중단을 보내기 위한 오류 주입 규칙을 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl create -f samples/bookinfo/kube/route-rule-ratings-test-abort.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;생성한 규칙 확인&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl get routerules ratings-test-abort -o yaml
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: ratings-test-abort
   namespace: default
   ...
 spec:
   destination:
     name: ratings
   httpFault:
     abort:
       httpStatus: 500
       percent: 100
   match:
     request:
       headers:
         cookie:
           regex: ^(.*?;)?(user=jason)(;.*)?$
   precedence: 2
   route:
   - labels:
       version: v1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션의 동작 확인
사용자 &lt;code class=&quot;highlighter-rouge&quot;&gt;jason&lt;/code&gt;으로 로그인합니다. 규칙이 모든 pods에 전파되면 “ratings 서비스 사용할 수 없음”이라는 메시지와 함께 페이지가 표시됩니다. 사용자 &lt;code class=&quot;highlighter-rouge&quot;&gt;jason&lt;/code&gt;에서 로그 아웃하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;productpage&lt;/code&gt; 페이지에 ratings v1이 정상적으로 표시됩니다.&lt;/p&gt;

    &lt;p&gt;HTTP 중단을 사용한 오류 주입 상태
 &lt;img src=&quot;/blog/assets/images/istio_fault_injection_aborted.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;ratings v1이 정상적으로 표시 상태
 &lt;img src=&quot;/blog/assets/images/istio_fault_injection_not_aborted.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;p&gt;https://istio.io/docs/tasks/traffic-management/fault-injection.html&lt;/p&gt;

&lt;h2 id=&quot;다음-포스트&quot;&gt;다음 포스트&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/blog/istio/2018/05/07/istio-intelligent-routing-3.html&quot;&gt;Istio Intelligent Routing #3 가중치 기반 라우팅&lt;/a&gt;&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">이 문서는 지연을 주입하고 애플리케이션의 복원력을 테스트하는 방법을 보여줍니다.</summary></entry><entry><title type="html">Istio Intelligent Routing #1 콘텐츠 기반 라우팅</title><link href="http://localhost:4000/blog/istio/2018/04/26/istio-intelligent-routing-1.html" rel="alternate" type="text/html" title="Istio Intelligent Routing #1 콘텐츠 기반 라우팅" /><published>2018-04-26T20:46:39+09:00</published><updated>2018-04-26T20:46:39+09:00</updated><id>http://localhost:4000/blog/istio/2018/04/26/istio-intelligent-routing-1</id><content type="html" xml:base="http://localhost:4000/blog/istio/2018/04/26/istio-intelligent-routing-1.html">&lt;p&gt;이 문서는 가중치 및 HTTP 헤더를 기반으로 동적 요청 라우팅을 구성하는 방법을 보여줍니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Kubernetes에 Istio 설치하기&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/istio/2018/04/26/deploying-istio-on-kubernetes.html&quot;&gt;Kubernetes에 Istio 설치하기&lt;/a&gt;를 참고하여 Kubernetes에 Istio 설치합니다.&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;마이크로서비스 샘플앱(BookInfo) 배포하기&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/istio/2018/04/26/deploying-bookinfo-on-kubernetes.html&quot;&gt;마이크로서비스 샘플앱(BookInfo) 배포하기&lt;/a&gt;를 참고하여 Kubernetes에 BookInfo 애플리케이션을 배포합니다.&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;콘텐츠-기반-라우팅&quot;&gt;콘텐츠 기반 라우팅&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;모든 마이크로서비스에 대해 기본버전을 v1으로 적용합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl create -f samples/bookinfo/kube/route-rule-all-v1.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;참고: istioctl은 kubectl로 대체할 수 있습니다. 하지만 kubectl은 현재 유효성 검사를 하지 않습니다.&lt;/p&gt;

    &lt;p&gt;아래 명령어를 통해 route rule을 조회할 수 있습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl get routerules -o yaml
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: details-default
   namespace: default
   ...
 spec:
   destination:
     name: details
   precedence: 1
   route:
   - labels:
       version: v1
 ---
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: productpage-default
   namespace: default
   ...
 spec:
   destination:
     name: productpage
   precedence: 1
   route:
   - labels:
       version: v1
 ---
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: ratings-default
   namespace: default
   ...
 spec:
   destination:
     name: ratings
   precedence: 1
   route:
   - labels:
       version: v1
 ---
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   name: reviews-default
   namespace: default
   ...
 spec:
   destination:
     name: reviews
   precedence: 1
   route:
   - labels:
       version: v1
 ---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BookInfo app 접속&lt;/p&gt;

    &lt;p&gt;http://$GATEWAY_ADDRESS/productpage &lt;br /&gt;
 Bookinfo application의 &lt;code class=&quot;highlighter-rouge&quot;&gt;productpage&lt;/code&gt;를 볼수 있습니다.&lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews:v1&lt;/code&gt; 인스턴스 에는 rating stars가 없으므로 표시되지 않습니다.&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/istio_intel_routing_contents_norating.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;특정 user로 접속&lt;/p&gt;

    &lt;p&gt;아래 명령어를 실행하면 user &lt;code class=&quot;highlighter-rouge&quot;&gt;jason&lt;/code&gt;이 &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews:v2&lt;/code&gt; 인스턴스로 접속되도록 설정할 수 있습니다.&lt;br /&gt;&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl create -f samples/bookinfo/kube/route-rule-reviews-test-v2.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;설정 확인&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ istioctl get routerule reviews-test-v2 -o yaml
 apiVersion: config.istio.io/v1alpha2
 kind: RouteRule
 metadata:
   creationTimestamp: null
   name: reviews-test-v2
   namespace: bookinfo
   resourceVersion: &quot;517883&quot;
 spec:
   destination:
     name: reviews
   match:
     request:
       headers:
         cookie:
           regex: ^(.*?;)?(user=jason)(;.*)?$
   precedence: 2
   route:
   - labels:
       version: v2
 ---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;productpage web page에서 user &lt;code class=&quot;highlighter-rouge&quot;&gt;jason&lt;/code&gt;으로 접속&lt;/p&gt;

    &lt;p&gt;이제 ratings (1-5 stars)를 볼 수 있습니다. 로그인하지 않으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews:v1&lt;/code&gt; 인스턴스로 접속됩니다.&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/istio_intel_routing_contents_rating.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;p&gt;https://istio.io/docs/tasks/traffic-management/request-routing.html&lt;/p&gt;

&lt;h2 id=&quot;다음-포스트&quot;&gt;다음 포스트&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/blog/istio/2018/05/02/istio-intelligent-routing-2.html&quot;&gt;Istio Intelligent Routing #2 오류 주입&lt;/a&gt;&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">이 문서는 가중치 및 HTTP 헤더를 기반으로 동적 요청 라우팅을 구성하는 방법을 보여줍니다.</summary></entry><entry><title type="html">마이크로서비스 샘플앱(BookInfo) 배포하기</title><link href="http://localhost:4000/blog/istio/2018/04/26/deploying-bookinfo-on-kubernetes.html" rel="alternate" type="text/html" title="마이크로서비스 샘플앱(BookInfo) 배포하기" /><published>2018-04-26T20:20:39+09:00</published><updated>2018-04-26T20:20:39+09:00</updated><id>http://localhost:4000/blog/istio/2018/04/26/deploying-bookinfo-on-kubernetes</id><content type="html" xml:base="http://localhost:4000/blog/istio/2018/04/26/deploying-bookinfo-on-kubernetes.html">&lt;p&gt;이 문서에서는 Istio 서비스 매시의 다양한 기능을 시연하는데 사용할 4개의 마이크로서비스 샘플 애플리케이션을 배포합니다.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;p&gt;이 가이드에서는 온라인 서점의 카탈로그 항목과 비슷한 책에 대한 정보를 표시하는 간단한 애플리케이션을 배포합니다. 이 페이지에는 책에 대한 설명, 책 세부 정보 (ISBN, 페이지 수 등) 및 몇 권의 서평이 표시됩니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Bookinfo 애플리케이션은 4개의 마이크로서비스로 나뉩니다.&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;productpage : 세부 사항을 호출하고 마이크로서비스를 검토하여 페이지를 채웁니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;details : 도서 정보가 들어 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;reviews : 서평이 포함되어 있습니다. 또한 ratings 마이크로서비스를 호출합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ratings : 서평을 수반하는 서적 순위 정보가 포함됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;reviews 마이크로서비스에는 3가지 버전이 있습니다.&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버전 v1은 ratings 서비스를 호출하지 않습니다.&lt;/li&gt;
  &lt;li&gt;버전 v2는 ratings 서비스를 호출하고 각 순위를 1 - 5 개의 검은 별로 표시합니다.&lt;/li&gt;
  &lt;li&gt;버전 v3는 ratings 서비스를 호출하고 각 순위를 1 ~ 5 개의 빨간색 별로 표시합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;애플리케이션의 end-to-end 아키텍처는 아래와 같습니다. 이 애플리케이션은 다양한 프로그래밍 언어로 작성되었습니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/bookinfo_noistio.svg&quot; alt=&quot;BookInfo Application Without Istio&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Kubernetes에 Istio 설치하기&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/istio/2018/04/26/deploying-istio-on-kubernetes.html&quot;&gt;Kubernetes에 Istio 설치하기&lt;/a&gt;를 참고하여 Kubernetes에 Istio 설치합니다.&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;bookinfo-애플리케이션&quot;&gt;BookInfo 애플리케이션&lt;/h2&gt;
&lt;p&gt;Istio와 함께 샘플을 실행하기 위해 애플리케이션을 변경할 필요는 없습니다. 대신, Istio가 활성화 된 환경에서 서비스를 구성하고 실행하면 각각의 서비스에 Envoy 사이드카가 주입됩니다. 필요한 명령과 구성은 런타임 환경에 따라 다르지만 모든 경우의 결과는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/bookinfo_withistio.svg&quot; alt=&quot;BookInfo Application With Istio&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모든 마이크로서비스는 Envoy 사이드카와 함께 패키지화되어 수신 및 발신 요청을 가로챕니다. Istio control plane, 라우팅, 원격 측정 수집 및 애플리케이션 전체에 대한 정책 적용을 통해 외부 제어에 필요한 후크를 제공합니다.&lt;/p&gt;

&lt;h2 id=&quot;kubernetes에서-bookinfo-애플리케이션-실행&quot;&gt;Kubernetes에서 BookInfo 애플리케이션 실행&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;BookInfo 애플리케이션 실행&lt;/p&gt;

    &lt;p&gt;수동으로 사이트카 주입을 하는 경우 아래 명령어를 실행합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl apply -f &amp;lt;(istioctl kube-inject -f samples/bookinfo/kube/bookinfo.yaml)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;자동 사이드카 주입 기능이 활성화되어 있는 경우 아래 명령어를 실행합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl apply -f samples/bookinfo/kube/bookinfo.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;istioctl kube-inject 명령은 애플리케이션을 배포하기 전에 bookinfo.yaml 파일을 수동으로 수정하는 데 사용됩니다.
 이 명령은 다이어그램에서 설명한 것처럼 네 개의 마이크로서비스를 시작하고 게이트웨이 ingress 자원을 생성합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;reviews&lt;/code&gt; 서비스 v1, v2 및 v3의 3 가지 버전이 모두 시작됩니다.&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BookInfo svc 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get svc
 NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
 details       ClusterIP   172.21.67.160    &amp;lt;none&amp;gt;        9080/TCP   20h
 productpage   ClusterIP   172.21.39.218    &amp;lt;none&amp;gt;        9080/TCP   20h
 ratings       ClusterIP   172.21.201.191   &amp;lt;none&amp;gt;        9080/TCP   20h
 reviews       ClusterIP   172.21.154.60    &amp;lt;none&amp;gt;        9080/TCP   20h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BookInfo pod 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get pods
 NAME                              READY     STATUS    RESTARTS   AGE
 details-v1-55496dcd64-qjqmb       2/2       Running   0          20h
 productpage-v1-586897968d-j2kwf   2/2       Running   0          20h
 ratings-v1-6d9f5df564-4kzlt       2/2       Running   0          20h
 reviews-v1-5985df7dd4-x22zl       2/2       Running   0          20h
 reviews-v2-856d5b976-vtlct        2/2       Running   0          20h
 reviews-v3-c4fbb98d8-5bv9j        2/2       Running   0          20h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BookInfo ingress 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $  kubectl get ingress
 NAME      HOSTS     ADDRESS         PORTS     AGE
 gateway   *         169.x.x.x       80        20h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BookInfo 접속&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; export GATEWAY_ADDRESS=169.x.x.x
 http://$GATEWAY_ADDRESS/productpage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/istio_intel_routing_contents_norating.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;p&gt;https://istio.io/docs/guides/bookinfo.html&lt;/p&gt;

&lt;h2 id=&quot;다음-포스트&quot;&gt;다음 포스트&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/blog/istio/2018/04/26/istio-intelligent-routing-1.html&quot;&gt;Istio Intelligent Routing #1 콘텐츠 기반 라우팅&lt;/a&gt;&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">이 문서에서는 Istio 서비스 매시의 다양한 기능을 시연하는데 사용할 4개의 마이크로서비스 샘플 애플리케이션을 배포합니다.</summary></entry></feed>