<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-03-23T01:18:00+09:00</updated><id>http://localhost:4000/</id><title type="html">개발 노트</title><subtitle>iOS를 시작으로 개발자의 길로 들어서 모바일 프레임워크와 애플리케이션을 개발했고 이후, 웹 개발자로 커리어를 전환해 웹 프레임워크, IDE를 개발했습니다. 최근에는 Kubernetes 및 Cloud 환경에서 애플리케션을 개발하고 빌드, 배포, 모니터링하는 운영 단계를 자동화하는 DevOps 엔지니어링을 하고 있습니다.</subtitle><author><name>Yun SangJun</name></author><entry><title type="html">Ansible 활용 #1 서버 계정 생성 자동화</title><link href="http://localhost:4000/automation/2019/10/15/ansible-create-account.html" rel="alternate" type="text/html" title="Ansible 활용 #1 서버 계정 생성 자동화" /><published>2019-10-15T00:00:00+09:00</published><updated>2019-10-15T00:00:00+09:00</updated><id>http://localhost:4000/automation/2019/10/15/ansible-create-account</id><content type="html" xml:base="http://localhost:4000/automation/2019/10/15/ansible-create-account.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;서버에 무언가 필요한 것들을 설치하기 전에 가장 먼저 하는 일이 사용자 계정을 생성하고 권한을 할당하는 일입니다.&lt;/p&gt;

&lt;p&gt;개인적인 스터디로 사용하는 서버라면 root 계정을 사용해도 무방하겠지만 
운영용 서버라면 root 계정은 서버 관리자만 알고 일반 사용자는 계정과 필요한 권한만 할당 받는 것이 일반적입니다.&lt;/p&gt;

&lt;p&gt;Ansible의 처음 접하는 분이라면 
&lt;a href=&quot;/automation/2019/10/13/ansible-start.html&quot;&gt;Ansible 시작하기&lt;/a&gt;에서 
기본적인 개념과 사용 방법에 대해 살펴보는것이 좋습니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
이 가이드의 Ansible host(Ansible을 설치하고 있는 서버)에서 사용하는 계정은 sudo 권한이 없는 일반 사용자입니다.
(sudo: 일반 사용자가 root 권한을 일시적으로 획득하여 특정 명령을 실행 할 수 있도록 하는 명령)
&lt;/p&gt;

&lt;h2 id=&quot;1-계정-추가하기&quot;&gt;1. 계정 추가하기&lt;/h2&gt;

&lt;p&gt;Remote host에 계정을 추가하는 명령을 실행해보겠습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;host 명: 전체 host 그룹인 “all” 입력&lt;/li&gt;
  &lt;li&gt;모듈 명: “-m” 옵션에 “user” 모듈 입력&lt;/li&gt;
  &lt;li&gt;모듈 파라미터: user 모듈의 name 파라미터에 “example-user” 입력&lt;/li&gt;
  &lt;li&gt;become: 명령을 실행하는 사용자 계정의 권한을 승격. “–become” 또는 “-b” 입력&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ ansible all -m user -a &quot;name=example-user&quot; -b
host01.example.com | CHANGED =&amp;gt; {
    &quot;ansible_facts&quot;: {
        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;
    },
    &quot;changed&quot;: true,
    &quot;comment&quot;: &quot;&quot;,
    &quot;create_home&quot;: true,
    &quot;group&quot;: 1003,
    &quot;home&quot;: &quot;/home/example-user&quot;,
    &quot;name&quot;: &quot;example-user&quot;,
    &quot;shell&quot;: &quot;&quot;,
    &quot;state&quot;: &quot;present&quot;,
    &quot;system&quot;: false,
    &quot;uid&quot;: 1002
}
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령을 실행하면 &lt;a href=&quot;https://docs.ansible.com/ansible/latest/modules/user_module.html&quot;&gt;user 모듈&lt;/a&gt;을 사용해서 “example-user”라는 이름의 계정을 생성합니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;만약 &quot;-b&quot; 옵션을 추가하지 않는다면 &quot;useradd&quot; 명령을 실행할 권한이 없다는 에러가 발생할 것입니다.&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;이 에러가 발생하는 이유는 ansible을 실행하는 사용자 계정에 sudo 권한이 없기 때문입니다.
(위에서 언급한 것과 같이 제가 테스트하는 계정도 sudo 권한이 없습니다. 만약 root 계정으로 ansible을 실행한다면 정상적으로 동작할 것입니다.)&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;하지만 일반적으로 root 계정을 사용하지 않습니다. 따라서 &quot;-b&quot; 옵션을 추가해 명령 실행해 필요한 권한을 할당 받아 사용하는 것입니다.&lt;/p&gt;

&lt;p&gt;이번에는 Remote host에 실제로 계정이 생성되었는지 확인해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;host 명: 전체 host 그룹인 “all” 입력&lt;/li&gt;
  &lt;li&gt;모듈 명: “-m” 옵션에 “shell” 모듈 입력&lt;/li&gt;
  &lt;li&gt;모듈 파라미터: shell 모듈의 파라미터에 “cat /etc/passwd” 명령 입력&lt;/li&gt;
  &lt;li&gt;출력 옵션: “-o” 옵션을 추가해 결과를 한줄로 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ ansible all -m shell -a &quot;cat /etc/passwd |grep 'example-user'&quot; -o
host01.example.com | CHANGED | rc=0 | (stdout) example-user:x:1002:1003::/home/example-user:
host02.example.com | CHANGED | rc=0 | (stdout) example-user:x:1002:1003::/home/example-user:
host03.example.com | CHANGED | rc=0 | (stdout) example-user:x:1002:1003::/home/example-user:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령을 실행하면 remote host의 계정 정보를 가져옵니다.
결과를 확인해보면 “example-user”가 추가된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;2-패스워드-추가하기&quot;&gt;2. 패스워드 추가하기&lt;/h2&gt;

&lt;p&gt;위에서 생성한 계정에 패스워드를 추가하는 명령을 실행해보겠습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;host 명: 전체 host 그룹인 “all” 입력&lt;/li&gt;
  &lt;li&gt;모듈 명: “-m” 옵션에 “user” 모듈 입력&lt;/li&gt;
  &lt;li&gt;모듈 파라미터
    &lt;ul&gt;
      &lt;li&gt;name: 위에서 생성한 계정인 “example-user” 입력&lt;/li&gt;
      &lt;li&gt;update_password: “always” 입력(입력한 암호가 기존 패스워드와 다른 경우 업데이트)&lt;/li&gt;
      &lt;li&gt;password: 암호 “example-password”를 hash한 값을 입력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ ansible all -m user -a &quot;name=example-user update_password=always password=example-password&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령을 실행하면 “example-user”라는 이름의 계정에 “example-password” 암호가 설정됩니다.&lt;/p&gt;

&lt;p&gt;암호가 정상적으로 설정되었는지 확인하기 위해 remote host에서 신규 생성한 계정으로 로그인을 해보겠습니다.
패스워드 입력 프롬포트가 나타나면 위에서 설정한 패스워드 “example-password”를 입력합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ su - example-user 
Password:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“example-user” 계정으로 정상 로그인되었습니다.
로그인을 확인했으니 다음 과정을 위해 로그아웃하고 원래 계정으로 돌아가겠습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;example-user@ansible-host:~$ exit

default-user@ansible-host:~$ 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-sudo-명령어-사용-권한-추가하기&quot;&gt;3. sudo 명령어 사용 권한 추가하기&lt;/h2&gt;

&lt;p&gt;마지막으로 신규 생성한 계정에 sudo 명령어를 사용할 수 있는 권한을 추가해보겠습니다.&lt;/p&gt;

&lt;p&gt;계정에 권한을 추가하는 방법은 1)”/etc/sudoers” 파일을 직접 수정하는 방법과 
2)”/etc/sudoers.d/” 디렉토리에 파일을 추가하는 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;어느 방법을 선택해도 무관하지만 좀 더 안전한 방법인 2번째 방법으로 진행해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;host 명: 전체 host 그룹인 “all” 입력&lt;/li&gt;
  &lt;li&gt;모듈 명: “-m” 옵션에 복사 기능을 수행하는 “copy” 모듈 입력&lt;/li&gt;
  &lt;li&gt;모듈 파라미터
    &lt;ul&gt;
      &lt;li&gt;content: 복사할 문자열 입력. “example-user ALL=(ALL) NOPASSWD:ALL”&lt;/li&gt;
      &lt;li&gt;dest: 복사할 목적지로 remote host의 절대 경로 입력. “/etc/sudoers.d/example-user”&lt;/li&gt;
      &lt;li&gt;mode: 복사할 목적지의 파일/디렉토리 권한 입력. “0664”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;become: 명령을 실행하는 사용자 계정의 권한을 승격. “–become” 또는 “-b” 입력&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ ansible all -m copy -a &quot;content='example-user ALL=(ALL) NOPASSWD:ALL' dest=/etc/sudoers.d/example-user mode=0644&quot; -b
host01.example.com | CHANGED =&amp;gt; {
    &quot;ansible_facts&quot;: {
        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;
    },
    &quot;changed&quot;: true,
    &quot;checksum&quot;: &quot;211b02ac91fd0734b04f766226aaa7bc8fb0aec8&quot;,
    &quot;dest&quot;: &quot;/etc/sudoers.d/example-user&quot;,
    &quot;gid&quot;: 0,
    &quot;group&quot;: &quot;root&quot;,
    &quot;md5sum&quot;: &quot;c10df13e1e8647a0a77e2a8343678fe5&quot;,
    &quot;mode&quot;: &quot;0644&quot;,
    &quot;owner&quot;: &quot;root&quot;,
    &quot;size&quot;: 35,
    &quot;src&quot;: &quot;/home/sangjunyun_1984/.ansible/tmp/ansible-tmp-1584880181.3114061-33928614051676/source&quot;,
    &quot;state&quot;: &quot;file&quot;,
    &quot;uid&quot;: 0
}
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령을 실행하면 remote host에 “/etc/sudoers.d/example-user” 파일이 생성되고
해당 파일에 “example-user ALL=(ALL) NOPASSWD:ALL” 내용이 추가됩니다.
이 내용은 “example-user”에게 패스워드 없이 sudo를 실행할 수 있는 권한을 부여한다는 의미입니다.&lt;/p&gt;

&lt;p&gt;이제 sudo 권한을 확인해보겠습니다. 먼저 “example-user”로 다시 로그인합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ su - example-user 
Password: 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 “root” 계정으로 로그인하는 sudo 명령을 실행해보겠습니다.
패스워드 없이 root 계정으로 로그인된 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;example-user@ansible-host:~$ sudo su - root

root@ansible-host:~$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;맺음말&quot;&gt;맺음말&lt;/h2&gt;

&lt;p&gt;지금까지 Ansible 명령을 사용하여 계정 생성 작업을 자동화하는 방법을 알아봤습니다.&lt;/p&gt;

&lt;p&gt;Ansible 명령으로 간단한 작업들을 수행하는 것은 편리합니다.
하지만 여러 가지 작업들을 수행해야하는 경우 Ansible 명령만으로 부족한 부분이 있습니다.&lt;/p&gt;

&lt;p&gt;이런 경우에 Ansible Playbook을 활용할 수 있습니다.
이후에 Ansible Playbook이 무엇이고 어떻게 사용하는지에 대해서도 한번 살펴 보겠습니다.&lt;/p&gt;</content><author><name>sj</name></author><category term="ansible" /><category term="ansibleplaybook" /><category term="automation" /><category term="devops" /><summary type="html">Overview</summary></entry><entry><title type="html">Ansible 시작하기</title><link href="http://localhost:4000/automation/2019/10/13/ansible-start.html" rel="alternate" type="text/html" title="Ansible 시작하기" /><published>2019-10-13T00:00:00+09:00</published><updated>2019-10-13T00:00:00+09:00</updated><id>http://localhost:4000/automation/2019/10/13/ansible-start</id><content type="html" xml:base="http://localhost:4000/automation/2019/10/13/ansible-start.html">&lt;h2 id=&quot;ansible-이란&quot;&gt;Ansible 이란?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ansible/ansible&quot;&gt;Ansible&lt;/a&gt;은 소프트웨어 프로비저닝, 구성 관리를 지원하는 자동화 도구입니다.
“Michael DeHaan”에 의해 개발되었으며 이후 레드햇에 인수되었다고 합니다.&lt;/p&gt;

&lt;p&gt;저 같은 경우 이직 후 새로운 개발/운영 환경에서 업무를 하게되면서 Ansible을 처음 접하게 되었습니다.
새로운 개발/운영 환경이란 것이 On-premise(온프레미스) 환경을 말하는데 서버마다 일일히 설정/구성 해줘야하는 작업이 있습니다.&lt;/p&gt;

&lt;p&gt;오픈소스 소프트웨어를 물리적인 서버에 구성하기 위해 서버에 계정, 네트워크 등의 설정을 해야하는 경우가 있었는데
한 두대도 아니고 수십~수백대의 서버에 동일한 설정을 반복해야한다고 생각하니 너무 귀찮고 번거로운 일이었습니다.&lt;/p&gt;

&lt;p&gt;이렇게 많은 물리 서버의 구성을 해본 경험이 없어서 처음에는 쉘 스크립트로 자동화를 해야겠다고 생각하던 차에
Ansible이라는 자동화 도구를 접하게 되었습니다.&lt;/p&gt;

&lt;p&gt;여러가지 활용 사례를 찾아보니 제가 개발하고자 하는 방향에 적합했고 
쉘 스크립트로 구현해야하는 많은 부분들을 이미 기능으로 제공하고 있어 장점이 많다고 생각합니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
이 가이드의 Ansible host(Ansible을 설치하고 있는 서버)에서 사용하는 계정은 sudo 권한이 없는 일반 사용자입니다.
(sudo: 일반 사용자가 root 권한을 일시적으로 획득하여 특정 명령을 실행 할 수 있도록 하는 명령)
&lt;/p&gt;

&lt;h2 id=&quot;1python-설치&quot;&gt;1.Python 설치&lt;/h2&gt;

&lt;p&gt;Ansible을 설치하기 위해서는 먼저 python을 설치해야합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.python.org/downloads/&quot;&gt;Python&lt;/a&gt; 사이트에서 자신의 환경에 맞는 버전을 다운로드 및 설치합니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
이 가이드는 Python 3.7 버전을 기준으로 작성했습니다.
&lt;/p&gt;

&lt;h2 id=&quot;2ansible-설치하기&quot;&gt;2.Ansible 설치하기&lt;/h2&gt;

&lt;p&gt;이제 Ansible을 설치해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#latest-releases-via-pip&quot;&gt;Ansible&lt;/a&gt;
사이트의 설치 가이드를 보면 다양한 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;이 가이드에서는 OS 환경에 종속성이 없는 
&lt;a href=&quot;https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#latest-releases-via-pip&quot;&gt;pip&lt;/a&gt;
을 통해 설치해보겠습니다.&lt;/p&gt;

&lt;p&gt;아래 명령을 실행해 ansible을 설치합니다. “–user” 옵션으로 설치를 권장합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//for local
default-user@ansible-host:~$ pip install --user ansible

//for global
default-user@ansible-host:~$ pip install ansible
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
&quot;--user&quot; 옵션으로 설치한 경우 아래와 같이 환경 변수를 설정해야 합니다.
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ PATH=$PATH:$HOME/.local/bin
default-user@ansible-host:~$ export PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치가 완료되면 버전을 확인합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ ansible --version
default-user@ansible-host:~$ ansible 2.9.2
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3getting-started&quot;&gt;3.Getting Started&lt;/h2&gt;

&lt;p&gt;이제 설치를 했으니 간단한 ansible 명령어를 실행해보겠습니다.&lt;/p&gt;

&lt;p&gt;Loopback(ansible host)을 호출하고 응답이 오는지 확인하는 명령을 실행합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;host 명: loopback 주소인 “localhost” 입력&lt;/li&gt;
  &lt;li&gt;모듈 명: “-m” 옵션에 “ping” 모듈 입력&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“pong” 이라는 응답이 오면 정상적으로 동작한 것입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ ansible localhost -m ping
...
localhost | SUCCESS =&amp;gt; {
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에서 &lt;a href=&quot;https://docs.ansible.com/ansible/latest/user_guide/modules_intro.html&quot;&gt;모듈&lt;/a&gt;이란 개념이 나왔는데 간략히 살펴보고 지나가겠습니다. 모듈은 일종의 플러그인입니다. Ansible은 모듈을 remote host에서 실행하고 return 값을 수집합니다.&lt;/p&gt;

&lt;p&gt;사실 모듈을 사용하지 않고 쉘 스크립트를 사용해서 원하는 명령을 실행할 수도 있습니다.
예를 들어 remote host의 특정 파일을 복사하는 명령을 실행한다고 가정해보겟습니다.&lt;/p&gt;

&lt;p&gt;아래 명령은 쉘 스크립트를 사용해 remote host의 파일을 복사하는 명령을 실행합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ ansible all -m shell -a &quot;cp ~/.profile ~/.profile.bak&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;같은 명령을 “copy” 모듈을 사용할 수도 있습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ ansible all -m copy -a &quot;src=~/.profile dest=~/.profile.bak&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;모듈을 사용하면 몇 가지 장점이 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;멱등성을 보장합니다. 즉 실행 결과를 저장해 다시 실행 시 변경된 부분만 실행할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;OS에 대한 호환성이 있습니다. 다른 OS에서 실행할 때 명령어를 다시 작성할 필요가 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;어떤 방법을 사용하는지는 개인의 선택이지만 유지보수 측면을 고려한다면 모듈을 사용하는 것이 효율적입니다.&lt;/p&gt;

&lt;h2 id=&quot;4host-파일-구성하기&quot;&gt;4.Host 파일 구성하기&lt;/h2&gt;

&lt;p&gt;Ansible host에서 여러대의 remote host를 호출해야 할 경우 “/etc/ansible/hosts” 파일에 등록해서 사용합니다.&lt;/p&gt;

&lt;p&gt;“/etc/ansible/hosts” 파일을 생성하고 remote host를 입력합니다.
“[example]”는 remote host들의 그룹 이름입니다. 딱히 정해진 이름은 없으니 자유롭게 정하면됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ vi /etc/ansible/hosts
[example]
host01.example.com
host02.example.com
host03.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
Ansible host에서 remote host로 ssh 클라이언트를 통해 접속 가능한 상태이어야합니다.
일반적으로 ssh key를 통해 접속합니다.
&lt;/p&gt;

&lt;h2 id=&quot;5-remote-host에-ping-명령-호출하기&quot;&gt;5. Remote host에 ping 명령 호출하기&lt;/h2&gt;

&lt;p&gt;이제 등록한 remote host에 ping 명령을 호출해보겠습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;host 명: 그룹명 “example” 입력&lt;/li&gt;
  &lt;li&gt;모듈 명: “-m” 옵션에 “ping” 모듈 입력&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ ansible example -m ping
host01.example.com | SUCCESS =&amp;gt; {
    &quot;ansible_facts&quot;: {
        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;
    },
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}
host02.example.com | SUCCESS =&amp;gt; {
    &quot;ansible_facts&quot;: {
        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;
    },
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}
host03.example.com | SUCCESS =&amp;gt; {
    &quot;ansible_facts&quot;: {
        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;
    },
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그룹명 대신 “all”을 입력해도 동일한 결과가 출력됩니다.
“/etc/ansible/hosts” 파일에 여러개의 host 그룹을 등록할 수 있는데
전체 그룹에 대해 호출하고 싶은 경우 “all”을 사용하면됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default-user@ansible-host:~$ vi /etc/ansible/hosts
[example01]
host01.example.com

[example02]
host02.example.com

[example03]
host03.example.com

default-user@ansible-host:~$ ansible all -m ping
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;맺음말&quot;&gt;맺음말&lt;/h2&gt;

&lt;p&gt;지금까지 Ansible이 무엇인지 알아보고 간단한 사용 방법에 대해 알아봤습니다.&lt;/p&gt;

&lt;p&gt;서버를 구성 할 때 필수적으로 하는 작업(그리고 가장 번거로운)이 있습니다. 서버의 계정을 생성하는 작업인데 이 작업을 
&lt;a href=&quot;/automation/2019/10/15/ansible-create-account.html&quot;&gt;Ansible을 활용해 자동화&lt;/a&gt;하는 방법에 대해 알아보겠습니다.&lt;/p&gt;</content><author><name>sj</name></author><category term="ansible" /><category term="ansibleplaybook" /><category term="automation" /><category term="devops" /><summary type="html">Ansible 이란?</summary></entry><entry><title type="html">Virtual Kubelet을 활용해 Kubernetes를 서버리스 컨테이너로 확장하기</title><link href="http://localhost:4000/kubernetes/2019/08/25/virtual-kublet.html" rel="alternate" type="text/html" title="Virtual Kubelet을 활용해 Kubernetes를 서버리스 컨테이너로 확장하기" /><published>2019-08-25T00:00:00+09:00</published><updated>2019-08-25T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/2019/08/25/virtual-kublet</id><content type="html" xml:base="http://localhost:4000/kubernetes/2019/08/25/virtual-kublet.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;p&gt;Private 환경에서 kubernetes cluster를 운영하고 있다면 workload를 bursting 하는 관점에서 
Public cloud와 연계하는 방안을 한번쯤은 고민해봤을 것이라 생각합니다.&lt;/p&gt;

&lt;p&gt;이와 관련해 CNCF(Cloud Native Computing Foundation)에 
&lt;a href=&quot;https://github.com/virtual-kubelet/virtual-kubelet&quot;&gt;Virtual Kubelet&lt;/a&gt;이라는
흥미로운 프로젝트가 있어 활용 사례 및 Hands-on을 남겨봅니다.&lt;/p&gt;

&lt;p&gt;Virtual Kubelet에 대한 설명을 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Kubernete를 다른 API와 연동하기 위한 Kubelet 구현체&lt;/code&gt;라고 정의되어 있습니다.
이 설명만 들으면 활용 방법이나 프로젝트에서 추구하는 목적이 크게 와닿지가 않습니다.&lt;/p&gt;

&lt;p&gt;이해를 돕기 위해 활용 사례를 들어보겠습니다.
아래 그림과 같이 운영중인 Kubernetes cluster에 Public Cloud의 서버리스 컨테이너 서비스
(예 - AWS ECS Fargate, Azure Container Instance 등)를 확장해 마치 하나의 cluster 처럼 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/virtual-kubelet/virtual-kubelet-architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 통해 컨테이너 서비스 별로 서로 다른 사용 방식을 고려할 필요 없이 Kubernetes stack으로 통일하여 개발 및 운영을 할 수 있는 장점이 있습니다.
또한 Public cloud에는 Kubernetes cluster를 추가로 운영할 필요없이 컨테이너에 대한 비용만 지불하면 되므로 비용 효율적인 측면이 있습니다.&lt;/p&gt;

&lt;p&gt;물론 제약 사항도 있습니다. 아래 현재 지원하는 feature를 보면 kubernetes의 모든 기능을 사용할 수 있는 것은 아닙니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;create, delete and update pods&lt;/li&gt;
  &lt;li&gt;container logs, exec, and metrics&lt;/li&gt;
  &lt;li&gt;get pod, pods and pod status&lt;/li&gt;
  &lt;li&gt;capacity&lt;/li&gt;
  &lt;li&gt;node addresses, node capacity, node daemon endpoints&lt;/li&gt;
  &lt;li&gt;operating system&lt;/li&gt;
  &lt;li&gt;bring your own virtual network&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또한 Virtual Kubelet에서 사용할 virtual network를 지정할 수 있지만 
해당 network가 Kubernetes cluster의 pod에서 사용하는 network과 연결성이 없다면 
pod간 private 통신도 불가능합니다.&lt;/p&gt;

&lt;p&gt;추가로 프로젝트 설명에 Multi Kubernetes cluster를 federation 하기 위한 용도가 아니라고 명시되어 있으니
사용에 참고가 필요할 거 같습니다.&lt;/p&gt;

&lt;p&gt;마지막으로 프로젝트 현황을 살펴보면 CNCF의 Sandbox 프로젝트라고 합니다.
일반적으로 Sandbox =&amp;gt; Incubation =&amp;gt; Graduate 순으로 발전된다고 합니다.&lt;/p&gt;

&lt;p&gt;최근 1.0 버전이 릴리스되어 프로젝트가 안정화되어 가는거 같고 
실용적인 활용 사례와 컨셉이 명확해 앞으로 기대가 되는 프로젝트입니다.&lt;/p&gt;

&lt;p&gt;아래 hands-on을 한번 따라해보시면 프로젝트 컨셉과 활용 방법에 대해 좀 더 쉽게 이해할 수 있으리라 생각됩니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비하기&quot;&gt;사전 준비하기&lt;/h2&gt;

&lt;p&gt;이 문서에서는 누구나 따라할 수 있도록 Public cloud의 무료 체험이 가능한 환경 기준으로 작성했습니다.&lt;/p&gt;

&lt;p&gt;Kubernetes cluster는 GKE(Google Kubernetes Engine), 컨테이너 서비스는 ACI(Azure Container Instance)를 사용했습니다.&lt;/p&gt;

&lt;p&gt;Hands-on을 위해서 아래와 같은 준비사항이 필요합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Kubernetes cluster&lt;/p&gt;

    &lt;p&gt;기존의 보유하고 있는 cluster를 사용하거나 새로 생성합니다.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/quickstart?hl=ko&quot;&gt;GKE(Google Kubernetes Engine)&lt;/a&gt;,
 &lt;a href=&quot;https://azure.microsoft.com/ko-kr/services/kubernetes-service/&quot;&gt;AKS(Azure Kubernetes Service)&lt;/a&gt;, 
 &lt;a href=&quot;https://aws.amazon.com/ko/eks/&quot;&gt;EKS(Elastic Kubernetes Service)&lt;/a&gt; 
 등 관리형 Kubernetes 서비스를 활용하여 쉽고 빠르게 생성할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;이 문서에서는 GKE 환경을 사용했습니다. 구글 계정을 가지고 있다면 Credit을 받아 일정기간 무료로 사용할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Azure 계정&lt;/p&gt;

    &lt;p&gt;ACI(Azure Container Instance)를 사용하기 위해 Azure 계정을 준비합니다.&lt;/p&gt;

    &lt;p&gt;Azure 계정이 없다면 &lt;a href=&quot;https://azure.microsoft.com/ko-kr/free/&quot;&gt;Azure 체험 계정 만들기&lt;/a&gt;를 통하여 
 계정을 생성하고 Credit을 받아 일정기간 무료로 사용할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Azure CLI.&lt;/p&gt;

    &lt;p&gt;Azure CLI를 설치합니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;OSX&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  brew install azure-cli
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Linux(Ubuntu 64-bit)&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ echo &quot;deb [arch=amd64] https://packages.microsoft.com/repos/azure-cli/ wheezy main&quot; | \
  sudo tee /etc/apt/sources.list.d/azure-cli.list
 
  $ sudo apt-key adv --keyserver packages.microsoft.com --recv-keys 52E16F86FEE04B979B07E28DB02C46DF417A0893
  $ sudo apt-get install apt-transport-https
  $ sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install azure-cli
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kubernetes CLI&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/tasks/tools/install-kubectl/&quot;&gt;Kubernetes CLI&lt;/a&gt;를 설치합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm CLI.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/helm/2018/05/27/installing-helm.html&quot;&gt;Helm CLI&lt;/a&gt;를 설치합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;azure-계정-설정하기&quot;&gt;Azure 계정 설정하기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Azure에 로그인합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; az login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Azure subscription 조회 및 복사합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ az account list -o table
 Name       CloudName    SubscriptionId                        State    IsDefault
 ---------  -----------  ------------------------------------  -------  -----------
 무료 체험    AzureCloud   &amp;lt;SubscriptionId&amp;gt;                      Enabled  True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Subscription ID에 위에서 복사한 ID를 저장합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; export AZURE_SUBSCRIPTION_ID=&quot;&amp;lt;SubscriptionId&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ACI(Azure Container Instance)를 활성화합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; az provider register -n Microsoft.ContainerInstance
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;aci-resource-group-생성하기&quot;&gt;ACI Resource Group 생성하기&lt;/h2&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
현재 Azure 한국 리전에서는 ACI 서비스가 없습니다. 
서비스 중인 가장 가까운 리전은 japaneast 입니다.(japanwest도 없음)
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ACI_REGION=japaneast
az group create --name aci-group --location &quot;$ACI_REGION&quot;
export AZURE_RG=aci-group
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;azure-service-principal-생성하기&quot;&gt;Azure Service principal 생성하기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;RBAC과 함께 SP(Service principal)를 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ az ad sp create-for-rbac --name virtual-kubelet-quickstart -o table
 ...
 AppId       DisplayName        Name                Password                  Tenant
 -----------------------------------------------------------------------------------------------  
 &amp;lt;AppId&amp;gt;     ...                ...                 &amp;lt;Password&amp;gt;                &amp;lt;Tenant&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 결과를 변수로 저장합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; export AZURE_TENANT_ID=&amp;lt;Tenant&amp;gt;
 export AZURE_CLIENT_ID=&amp;lt;AppId&amp;gt;
 export AZURE_CLIENT_SECRET=&amp;lt;Password&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;virtual-kubelet-배포하기&quot;&gt;Virtual Kubelet 배포하기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Cluster의 Master Endpoint 확인 및 복사합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl cluster-info
 Kubernetes master is running at &amp;lt;Kubernetes Master&amp;gt;
 ...

 $ export MASTER_URI=&amp;lt;Kubernetes Master&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm을 통하여 Virtual Kubelet 설치합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; VK_RELEASE=virtual-kubelet-latest
 RELEASE_NAME=virtual-kubelet
 NODE_NAME=virtual-kubelet
 CHART_URL=https://github.com/virtual-kubelet/virtual-kubelet/raw/master/charts/$VK_RELEASE.tgz

 helm install &quot;$CHART_URL&quot; --name &quot;$RELEASE_NAME&quot; \
 --set provider=azure \
 --set rbac.install=true \
 --set providers.azure.targetAKS=false \
 --set providers.azure.aciResourceGroup=$AZURE_RG \
 --set providers.azure.aciRegion=$ACI_REGION \
 --set providers.azure.tenantId=$AZURE_TENANT_ID \
 --set providers.azure.subscriptionId=$AZURE_SUBSCRIPTION_ID \
 --set providers.azure.clientId=$AZURE_CLIENT_ID \
 --set providers.azure.clientKey=$AZURE_CLIENT_SECRET \
 --set providers.azure.masterUri=$MASTER_URI
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정상 설치 확인하기&lt;/p&gt;

    &lt;p&gt;virtual-kubelet이 cluster에 Pod로 배포되었고, Running 중인지 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl --namespace=default get pods -l &quot;app=virtual-kubelet&quot;
 NAME                                               READY   STATUS    RESTARTS   AGE
 virtual-kubelet-virtual-kubelet-7c9fbc55c4-r2j57   1/1     Running   0          23s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Cluster의 node를 조회해 virtual-kubelet node가 조회되는지 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get nodes
 NAME                                                STATUS   ROLES    AGE   VERSION
 gke-standard-cluster-1-default-pool-cc858c9e-9sf8   Ready    &amp;lt;none&amp;gt;   39m   v1.12.8-gke.10
 gke-standard-cluster-1-default-pool-cc858c9e-bm01   Ready    &amp;lt;none&amp;gt;   39m   v1.12.8-gke.10
 virtual-kubelet                                     Ready    agent    44s   v1.13.1-vk-v0.9.0-1-g7b92d1ee-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sample-app-배포하기&quot;&gt;Sample App 배포하기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;virtual-node.yaml 파일을 생성합니다.
ACI(Azure Container Instance)에 배포하기 위해 nodeSelector와 toleration을 추가합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: aci-helloworld
spec:
  replicas: 1
  selector:
 matchLabels:
   app: aci-helloworld
  template:
 metadata:
   labels:
     app: aci-helloworld
 spec:
   containers:
   - name: aci-helloworld
     image: microsoft/aci-helloworld
     ports:
     - containerPort: 80
   nodeSelector:
     kubernetes.io/role: agent
     beta.kubernetes.io/os: linux
     type: virtual-kubelet
   tolerations:
   - key: virtual-kubelet.io/provider
     operator: Exists
   - key: azure.com/aci
     effect: NoSchedule
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;aci-helloworld pod를 배포합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl apply -f virtual-node.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 후 Pod를 조회해보면 aci-helloworld app은 virtual-kubelt node에 배포된 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get po -o wide
 NAME                 READY STATUS    RESTARTS   AGE    IP              NODE              NOMINATED NODE
 aci-helloworld-...   1/1   Running   0          54s    [IP_ADDRESS]    virtual-kubelet   &amp;lt;none&amp;gt;
 sample-app-...       1/1   Running   0          4m17s  10.0.0.7        gke-standard...   &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;aci-helloworld pod의 IP를 보면 azure의 public ip를 할당받은것을 확인할 수 있습니다.
 Virtual Kubelet 배포 시 별도의 vitual network 설정을 하지 않았기 때문입니다.&lt;/p&gt;

    &lt;p&gt;aci-helloworld pod의 [IP_ADDRESS]를 정보를 복사한 후 웹브라우저에서 접속하면 
 &lt;code class=&quot;highlighter-rouge&quot;&gt;Welcome to Azure Container Instances!&lt;/code&gt; 메세지를 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;마지막으로 Azure Port에 접속해 ACI resource group에서 aci-helloworld 앱이 배포된것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/virtual-kubelet/virtual-kubelet-aci.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>sj</name></author><category term="kubernetes" /><category term="virtualkubelet" /><category term="cloud" /><category term="container" /><summary type="html">Overview Private 환경에서 kubernetes cluster를 운영하고 있다면 workload를 bursting 하는 관점에서 Public cloud와 연계하는 방안을 한번쯤은 고민해봤을 것이라 생각합니다.</summary></entry><entry><title type="html">Istio를 활용해 Multi Cluster 환경에 Service Mesh 구성하기</title><link href="http://localhost:4000/istio/2019/08/11/istio-multi-cluster-mesh.html" rel="alternate" type="text/html" title="Istio를 활용해 Multi Cluster 환경에 Service Mesh 구성하기" /><published>2019-08-11T00:00:00+09:00</published><updated>2019-08-11T00:00:00+09:00</updated><id>http://localhost:4000/istio/2019/08/11/istio-multi-cluster-mesh</id><content type="html" xml:base="http://localhost:4000/istio/2019/08/11/istio-multi-cluster-mesh.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Istio를 활용하여 여러개의 Kubernetes Cluster 환경에 Service Mesh를 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;인프라 및 Kubernetes Cluster 환경에 따라 3가지 구성 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 1번 방법을 활용하여 Service Mesh를 구성해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://istio.io/docs/setup/kubernetes/install/multicluster/shared-gateways/&quot;&gt;Shared control plane (multi-network)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;이 방법은 여러개의 Cluster가 하나의 Istio Control Plane을 공유합니다.
 Istio Gateway를 통해 Cluster간 통신하므로 각 Cluster의 네트워크가 분리되어 있고 VPN 또는 Direct 네트워크로 연결되어 있지 않아도 됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/istio/istio-shared-multi.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://istio.io/docs/setup/kubernetes/install/multicluster/shared-vpn/&quot;&gt;Shared control plane (single-network)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;1번과 마찬가지로 여러개의 Cluster가 하나의 Istio Control Plane을 공유합니다.
 별도의 Gateway가 없기 때문에 각 Cluster의 네트워크가 VPN 등을 통해 연결성이 있어야합니다.
 각 Cluster의 네트워크에서 Pod와 Service의 CIDR은 중복되서는 안되고 서로간의 라우팅이 가능해야합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/istio/istio-shared-single.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://istio.io/docs/setup/kubernetes/install/multicluster/gateways/&quot;&gt;Multiple control planes&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;1번과 마찬가지로 Istio Gateway를 통해 Cluster간 통신을 하지만 Istio Control Plance을 공유하지 않고 각각의 Cluster에 설치합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/istio/istio-multiple-multi.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;준비하기&quot;&gt;준비하기&lt;/h2&gt;

&lt;h3 id=&quot;kubernetes-cluster-준비&quot;&gt;Kubernetes Cluster 준비&lt;/h3&gt;

&lt;p&gt;1.12, 1.13, 1.14 버전의 Kubernetes Cluster를 2개 이상 준비합니다.
이 문서에서는 1.12 버전의 2개의 Cluster를 활용하겠습니다.&lt;/p&gt;

&lt;p&gt;편의상 2개의 Cluster를 아래와 같이 환경 변수로 설정합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl config get-contexts
CURRENT   NAME       CLUSTER    AUTHINFO       NAMESPACE
*         cluster1   cluster1   user@foo.com   default
          cluster2   cluster2   user@foo.com   default

$ export CTX_CLUSTER1=$(kubectl config view -o jsonpath='{.contexts[0].name}')
$ export CTX_CLUSTER2=$(kubectl config view -o jsonpath='{.contexts[1].name}')
$ echo CTX_CLUSTER1 = ${CTX_CLUSTER1}, CTX_CLUSTER2 = ${CTX_CLUSTER2}
CTX_CLUSTER1 = cluster1, CTX_CLUSTER2 = cluster2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;istio-다운로드&quot;&gt;Istio 다운로드&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/istio/istio/releases&quot;&gt;Istio Release&lt;/a&gt; 페이지에서 원하는 버전을 다운로드합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -L https://git.io/getLatestIstio | ISTIO_VERSION=x.x.x sh -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;platform-설정&quot;&gt;Platform 설정&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://istio.io/docs/setup/kubernetes/platform-setup/&quot;&gt;platform-specific setup&lt;/a&gt; 페이지를 참고하여 각 클라우드별로
필요한 설정을합니다.&lt;/p&gt;

&lt;h3 id=&quot;helm-설치&quot;&gt;Helm 설치&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/helm/2018/05/27/installing-helm.html&quot;&gt;Helm 설치하기&lt;/a&gt; 문서를 참고하여 Helm Client를 설치합니다.&lt;/p&gt;

&lt;h2 id=&quot;multi-cluster에-service-mesh-구성하기&quot;&gt;Multi Cluster에 Service Mesh 구성하기&lt;/h2&gt;

&lt;h3 id=&quot;primary-cluster-설정&quot;&gt;Primary Cluster 설정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster의 Istio deployment yaml 생성합니다.&lt;/p&gt;

    &lt;p&gt;위에서 다운로드 받은 Istio 디렉토리로 이동합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ cd istio-x.x.x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;helm template 기능을 사용하여 istio deployment yaml 파일을 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ helm template --name=istio --namespace=istio-system \
 --set global.mtls.enabled=true \
 --set security.selfSigned=false \
 --set global.controlPlaneSecurityEnabled=true \
 --set global.proxy.accessLogFile=&quot;/dev/stdout&quot; \
 --set global.meshExpansion.enabled=true \
 --set 'global.meshNetworks.network1.endpoints[0].fromRegistry'=Kubernetes \
 --set 'global.meshNetworks.network1.gateways[0].address'=0.0.0.0 \
 --set 'global.meshNetworks.network1.gateways[0].port'=443 \
 --set gateways.istio-ingressgateway.env.ISTIO_META_NETWORK=&quot;network1&quot; \
 --set global.network=&quot;network1&quot; \
 --set 'global.meshNetworks.network2.endpoints[0].fromRegistry'=n2-k8s-config \
 --set 'global.meshNetworks.network2.gateways[0].address'=0.0.0.0 \
 --set 'global.meshNetworks.network2.gateways[0].port'=443 \
 install/kubernetes/helm/istio &amp;gt; istio-auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster에 Istio를 설치합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER1 ns istio-system
 $ kubectl create --context=$CTX_CLUSTER1 secret generic cacerts -n istio-system --from-file=samples/certs/ca-cert.pem --from-file=samples/certs/ca-key.pem --from-file=samples/certs/root-cert.pem --from-file=samples/certs/cert-chain.pem
 $ for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply --context=$CTX_CLUSTER1 -f $i; done
 $ kubectl apply --context=$CTX_CLUSTER1 -f istio-auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;아래와 같이 모든 Pod의 Running 상태가 될 때까지 기다립니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get pods --context=$CTX_CLUSTER1 -n istio-system
 NAME                                      READY   STATUS      RESTARTS   AGE
 istio-citadel-9bbf9b4c8-nnmbt             1/1     Running     0          2m8s
 istio-cleanup-secrets-1.1.0-x9crw         0/1     Completed   0          2m12s
 istio-galley-868c5fff5d-9ph6l             1/1     Running     0          2m9s
 istio-ingressgateway-6c756547b-dwc78      1/1     Running     0          2m8s
 istio-pilot-54fcf8db8-sn9cn               2/2     Running     0          2m8s
 istio-policy-5fcbd55d8b-xhbpz             2/2     Running     2          2m8s
 istio-security-post-install-1.1.0-ww5zz   0/1     Completed   0          2m12s
 istio-sidecar-injector-6dcc9d5c64-7hnnl   1/1     Running     0          2m8s
 istio-telemetry-57875ffb6d-n2vmf          2/2     Running     3          2m8s
 prometheus-66c9f5694-8pccr                1/1     Running     0          2m8s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ingress Gateway를 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl apply --context=$CTX_CLUSTER1 -f - &amp;lt;&amp;lt;EOF
 apiVersion: networking.istio.io/v1alpha3
 kind: Gateway
 metadata:
 name: cluster-aware-gateway
 namespace: istio-system
 spec:
 selector:
     istio: ingressgateway
 servers:
 - port:
     number: 443
     name: tls
     protocol: TLS
     tls:
     mode: AUTO_PASSTHROUGH
     hosts:
     - &quot;*.local&quot;
 EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster의 Ingress IP와 Port를 확인합니다.&lt;/p&gt;

    &lt;p&gt;Primary Cluster에서 Ingress Gateway의 Service를 조회합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl config use-context $CTX_CLUSTER1
 $ kubectl get svc istio-ingressgateway -n istio-system
 NAME                   TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)                                      AGE
 istio-ingressgateway   LoadBalancer   172.x.x.1        130.x.x.1       80:31380/TCP,443:31390/TCP,31400:31400/TCP   17h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Ingress의 Host 주소와 Secure port를 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ export INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
 $ export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==&quot;https&quot;)].port}')
 $ echo The ingress gateway of cluster1: address=$INGRESS_HOST, port=$SECURE_INGRESS_PORT
 130.x.x.1, 443
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Istio Configmap의 mesh nework 설정에서 gateway 주소를 위에서 조회한 Ingress 정보로 변경합니다.&lt;/p&gt;

    &lt;p&gt;data.mesh.meshNetworks.networks.network1.address를 0.0.0.0에서 INGRESS_HOST로 변경합니다.
 data.mesh.meshNetworks.networks.network1.port를 443에서 SECURE_INGRESS_PORT 변경합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl edit cm -n istio-system --context=$CTX_CLUSTER1 istio
 apiVersion: v1
 data:
     mesh:
     ...
         meshNetworks: &quot;networks:\n  network1:\n    endpoints:\n    - fromRegistry: Kubernetes\n
     \   gateways:\n    - address: 0.0.0.0\n      port: 443\n  ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;second-cluster-설정&quot;&gt;Second Cluster 설정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster의 Ingress Gateway 주소를 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ export LOCAL_GW_ADDR=$(kubectl get --context=$CTX_CLUSTER1 svc --selector=app=istio-ingressgateway \
 -n istio-system -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}') &amp;amp;&amp;amp; echo ${LOCAL_GW_ADDR}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Second Cluster의 Istio deployment yaml 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ helm template --name istio-remote --namespace=istio-system \
 --values install/kubernetes/helm/istio/values-istio-remote.yaml \
 --set global.mtls.enabled=true \
 --set gateways.enabled=true \
 --set security.selfSigned=false \
 --set global.controlPlaneSecurityEnabled=true \
 --set global.createRemoteSvcEndpoints=true \
 --set global.remotePilotCreateSvcEndpoint=true \
 --set global.remotePilotAddress=${LOCAL_GW_ADDR} \
 --set global.remotePolicyAddress=${LOCAL_GW_ADDR} \
 --set global.remoteTelemetryAddress=${LOCAL_GW_ADDR} \
 --set gateways.istio-ingressgateway.env.ISTIO_META_NETWORK=&quot;network2&quot; \
 --set global.network=&quot;network2&quot; \
 install/kubernetes/helm/istio &amp;gt; istio-remote-auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Second Cluster에 Istio를 설치합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER2 ns istio-system
 $ kubectl create --context=$CTX_CLUSTER2 secret generic cacerts -n istio-system --from-file=samples/certs/ca-cert.pem --from-file=samples/certs/ca-key.pem --from-file=samples/certs/root-cert.pem --from-file=samples/certs/cert-chain.pem
 $ kubectl apply --context=$CTX_CLUSTER2 -f istio-remote-auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Istio의 모든 Pod가 Running 상태가 될때까지 기다립니다. 
 Primary Cluster와 다르게 일부 컴포넌트만 설치됩니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get pods --context=$CTX_CLUSTER2 -n istio-system -l istio!=ingressgateway
 NAME                                     READY   STATUS      RESTARTS   AGE
 istio-citadel-75c8fcbfcf-9njn6           1/1     Running     0          12s
 istio-cleanup-secrets-1.1.0-vtp62        0/1     Completed   0          14s
 istio-sidecar-injector-cdb5d4dd5-rhks9   1/1     Running     0          12s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Second Cluster의 Ingress IP와 Port를 확인합니다.&lt;/p&gt;

    &lt;p&gt;Second Cluster에서 Ingress Gateway의 Service를 조회합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl config use-context $CTX_CLUSTER2
 $ kubectl get svc istio-ingressgateway -n istio-system
 NAME                   TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)                                      AGE
 istio-ingressgateway   LoadBalancer   172.x.x.2        130.x.x.2       80:31380/TCP,443:31390/TCP,31400:31400/TCP   17h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Ingress의 Host 주소와 Secure port를 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ export INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
 $ export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==&quot;https&quot;)].port}')
 $ echo The ingress gateway of cluster2: address=$INGRESS_HOST, port=$SECURE_INGRESS_PORT
 130.x.x.2, 443
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Istio Configmap의 mesh nework 설정에서 gateway 주소를 위에서 조회한 Ingress 정보로 변경합니다.&lt;/p&gt;

    &lt;p&gt;data.mesh.meshNetworks.networks.network2.address를 0.0.0.0에서 INGRESS_HOST로 변경합니다.
 data.mesh.meshNetworks.networks.network2.port를 443에서 SECURE_INGRESS_PORT 변경합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl edit cm -n istio-system --context=$CTX_CLUSTER2 istio
 apiVersion: v1
 data:
     mesh:
     ...
     meshNetworks: &quot;networks:\n  network1:\n    endpoints:\n    - fromRegistry: Kubernetes\n
         \   gateways:\n    - address: 0.0.0.0\n      port: 443\n  network2:\n    endpoints:\n
         \   - fromRegistry: n2-k8s-config\n    gateways:\n    - address: 0.0.0.0\n
         \     port: 443\n  &quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;n2-k8s-config 설정 파일을 생성하기 위한 환경 변수를 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ CLUSTER_NAME=$(kubectl --context=$CTX_CLUSTER2 config view --minify=true -o jsonpath='{.clusters[].name}')
 $ SERVER=$(kubectl --context=$CTX_CLUSTER2 config view --minify=true -o jsonpath='{.clusters[].cluster.server}')
 $ SECRET_NAME=$(kubectl --context=$CTX_CLUSTER2 get sa istio-multi -n istio-system -o jsonpath='{.secrets[].name}')
 $ CA_DATA=$(kubectl get --context=$CTX_CLUSTER2 secret ${SECRET_NAME} -n istio-system -o jsonpath=&quot;{.data['ca\.crt']}&quot;)
 $ TOKEN=$(kubectl get --context=$CTX_CLUSTER2 secret ${SECRET_NAME} -n istio-system -o jsonpath=&quot;{.data['token']}&quot; | base64 --decode)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;n2-k8s-config 파일을 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ cat &amp;lt;&amp;lt;EOF &amp;gt; n2-k8s-config
 apiVersion: v1
 kind: Config
 clusters:
 - cluster:
     certificate-authority-data: ${CA_DATA}
     server: ${SERVER}
     name: ${CLUSTER_NAME}
 contexts:
 - context:
     cluster: ${CLUSTER_NAME}
     user: ${CLUSTER_NAME}
     name: ${CLUSTER_NAME}
 current-context: ${CLUSTER_NAME}
 users:
 - name: ${CLUSTER_NAME}
     user:
     token: ${TOKEN}
 EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;primary-cluster와-second-cluster-동기화&quot;&gt;Primary Cluster와 Second Cluster 동기화&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster에서 Second Cluster를 동기화합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER1 secret generic n2-k8s-secret --from-file n2-k8s-config -n istio-system
 $ kubectl label --context=$CTX_CLUSTER1 secret n2-k8s-secret istio/multiCluster=true -n istio-system
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Second Cluster의 Ingress Gateway가 Running 상태가 될때까지 기다립니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get pods --context=$CTX_CLUSTER2 -n istio-system -l istio=ingressgateway
 NAME                                    READY     STATUS    RESTARTS   AGE
 istio-ingressgateway-5c667f4f84-bscff   1/1       Running   0          16m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 Primary Cluster와 Seconde Cluster가 Service Mesh로 구성되었습니다.&lt;/p&gt;

&lt;p&gt;다음으로 샘플 서비스를 배포하여 2개의 Cluster에서 Service Mesh가 어떻게 동작하는지 확인해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;샘플-서비스-배포하기&quot;&gt;샘플 서비스 배포하기&lt;/h2&gt;

&lt;p&gt;Overview의 구성도와 같이 helloworld 애플리케이션을 Primary와 Second 클러스터에 각각 배포할것입니다.&lt;/p&gt;

&lt;p&gt;각각의 인스턴스는 동일한 애플리케이션이지만 이미지의 버전이 v1, v2로 다릅니다.&lt;/p&gt;

&lt;h3 id=&quot;second-cluster에-helloworld-v2-버전-배포&quot;&gt;Second Cluster에 helloworld v2 버전 배포&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sample namespace를 생성하고 istio proxy가 자동으로 injection 되도록 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER2 ns sample
 $ kubectl label --context=$CTX_CLUSTER2 namespace sample istio-injection=enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;helloworld v2를 배포합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER2 -f samples/helloworld/helloworld.yaml -l app=helloworld -n sample
 $ kubectl create --context=$CTX_CLUSTER2 -f samples/helloworld/helloworld.yaml -l version=v2 -n sample
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;helloworld v2가 Running 상태가 될때까지 기다립니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get po --context=$CTX_CLUSTER2 -n sample
 NAME                             READY     STATUS    RESTARTS   AGE
 helloworld-v2-7dd57c44c4-f56gq   2/2       Running   0          35s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;primary-cluster에-helloworld-v1-버전-배포&quot;&gt;Primary Cluster에 helloworld v1 버전 배포&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sample namespace를 생성하고 istio proxy가 자동으로 injection 되도록 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER1 ns sample
 $ kubectl label --context=$CTX_CLUSTER1 namespace sample istio-injection=enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;helloworld v1을 배포합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl create --context=$CTX_CLUSTER1 -f samples/helloworld/helloworld.yaml -l app=helloworld -n sample
 $ kubectl create --context=$CTX_CLUSTER1 -f samples/helloworld/helloworld.yaml -l version=v1 -n sample
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;helloworld v1이 Running 상태가 될때까지 기다립니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl get po --context=$CTX_CLUSTER1 -n sample
 NAME                            READY     STATUS    RESTARTS   AGE
 helloworld-v1-d4557d97b-pv2hr   2/2       Running   0          40s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;cluster간-트래픽-흐름-확인&quot;&gt;Cluster간 트래픽 흐름 확인&lt;/h3&gt;

&lt;p&gt;2개의 Cluster에서 트래픽을 확인하기 위해 sleep 애플리케이션에서 helloworld 애플리케이션을 호출해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sleep 애플리케이션을 2개의 Cluster에 배포하고 Running 상태가 될때까지 기다립니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl apply --context=$CTX_CLUSTER1 -f samples/sleep/sleep.yaml -n sample
 $ kubectl apply --context=$CTX_CLUSTER2 -f samples/sleep/sleep.yaml -n sample
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Primary Cluster에서 helloworld를 여러번 호출합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl exec --context=$CTX_CLUSTER1 -it -n sample -c sleep $(kubectl get pod --context=$CTX_CLUSTER1 -n sample -l app=sleep -o jsonpath='{.items[0].metadata.name}') -- curl helloworld.sample:5000/hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;각 클러스터의 v1, v2 버전이 번갈아가면서 호출되는 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Hello version: v2, instance: helloworld-v2-758dd55874-6x4t8
 Hello version: v1, instance: helloworld-v1-86f77cd7bd-cpxhv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Primary Cluster의 sleep pod의 istio-proxy 컨테이너의 로그를 조회해봅니다.
 한번은 Second Cluster의 Gateway를 통하여 Second Cluster에 있는 helloworld v2가 호출되었고
 다른 한번은 같은 Cluster의 helloworld v1이 호출되었습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ kubectl logs --context=$CTX_CLUSTER1 -n sample $(kubectl get pod --context=$CTX_CLUSTER1 -n sample -l app=sleep -o jsonpath='{.items[0].metadata.name}') istio-proxy
 [2018-11-25T12:37:52.077Z] &quot;GET /hello HTTP/1.1&quot; 200 - 0 60 190 189 &quot;-&quot; &quot;curl/7.60.0&quot; &quot;6e096efe-f550-4dfa-8c8c-ba164baf4679&quot; &quot;helloworld.sample:5000&quot; &quot;130.x.x.2:15443&quot; outbound|5000||helloworld.sample.svc.cluster.local - 10.20.194.146:5000 10.10.0.89:59496 -
 [2018-11-25T12:38:06.745Z] &quot;GET /hello HTTP/1.1&quot; 200 - 0 60 171 170 &quot;-&quot; &quot;curl/7.60.0&quot; &quot;6f93c9cc-d32a-4878-b56a-086a740045d2&quot; &quot;helloworld.sample:5000&quot; &quot;10.10.0.90:5000&quot; outbound|5000||helloworld.sample.svc.cluster.local - 10.20.194.146:5000 10.10.0.89:59646 -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;지금까지 살펴본 내용을 보면 Istio의 Service Mesh 구성을 통해 서로 다른 네트워크에 구성한 Cluster에서 실행중인 서비스간의 통신이
가능하다는 것을 확인할 수 있었습니다.&lt;/p&gt;</content><author><name>sj</name></author><category term="istio" /><category term="servicemesh" /><category term="multicluster" /><category term="kubernetes" /><summary type="html">Overview</summary></entry><entry><title type="html">Jenkins CI를 활용한 지속적인 소스코드 통합 환경 구성하기</title><link href="http://localhost:4000/cicd/2019/08/04/jenkinsci.html" rel="alternate" type="text/html" title="Jenkins CI를 활용한 지속적인 소스코드 통합 환경 구성하기" /><published>2019-08-04T00:00:00+09:00</published><updated>2019-08-04T00:00:00+09:00</updated><id>http://localhost:4000/cicd/2019/08/04/jenkinsci</id><content type="html" xml:base="http://localhost:4000/cicd/2019/08/04/jenkinsci.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;소스코드를 지속적으로 통합하기 위해서 TravisCI, CircleCI, Jenkins 등 다양한 툴을 활용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 Jenkins CI를 활용하여 소스코드를 지속적으로 통합하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;Jenkins CI와 아래 서비스를 통합하여 CI 환경을 구성해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소스코드 저장소: Github&lt;/li&gt;
  &lt;li&gt;이미지 저장소: Docker Hub&lt;/li&gt;
  &lt;li&gt;통합(CI): Jenkins&lt;/li&gt;
  &lt;li&gt;애플리케이션 서버: Kubernetes&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;h3 id=&quot;소스코드-다운로드&quot;&gt;소스코드 다운로드&lt;/h3&gt;

&lt;p&gt;이 문서에서 사용할 &lt;a href=&quot;https://github.com/YunSangJun/jenkinsci-demo.git&quot;&gt;jenkinsci-demo&lt;/a&gt; 프로젝트를 복사합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/YunSangJun/jenkinsci-demo.git
cd jenkinsci-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;소스코드-저장소&quot;&gt;소스코드 저장소&lt;/h3&gt;

&lt;p&gt;Github에 sample-app 저장소를 생성합니다.&lt;/p&gt;

&lt;h3 id=&quot;이미지-저장소-준비&quot;&gt;이미지 저장소 준비&lt;/h3&gt;

&lt;p&gt;Docker Hub에 sample-app 저장소를 생성합니다.&lt;/p&gt;

&lt;h3 id=&quot;kubernetes-클러스터-구성&quot;&gt;Kubernetes 클러스터 구성&lt;/h3&gt;

&lt;p&gt;애플리케이션 서버로 사용할 Kubernetes 클러스터를 준비합니다.&lt;/p&gt;

&lt;h3 id=&quot;jenkins-설치&quot;&gt;Jenkins 설치&lt;/h3&gt;

&lt;p&gt;Jenkins를 설치할 namespace를 생성합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create namespace jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에서 다운로드한 jenkinsci-demo 디렉토리로 이동합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd jenkinsci-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jenkins Helm chart를 설치합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm install --name jenkins-release --namespace jenkins \
-f jenkins/values.yaml stable/jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Maven Build Cache 용도의 pvc를 생성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create -f jenkins/maven-cache-pvc.yaml -n jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jenkins에 대한 자세한 내용은 &lt;a href=&quot;/cicd/2018/05/26/installing-jenkins.html&quot;&gt;Jenkins 설치하기&lt;/a&gt; 문서를 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;jenkins-ui-접속&quot;&gt;Jenkins UI 접속&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkins UI에 접속하기 위해 포트포워딩을 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; export POD_NAME=$(kubectl get pods --namespace jenkins -l &quot;app.kubernetes.io/component=jenkins-master&quot; -l &quot;app.kubernetes.io/instance=jenkins-release&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
 kubectl --namespace jenkins port-forward $POD_NAME 8080:8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkins admin 계정의 암호를 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; printf $(kubectl get secret --namespace jenkins jenkins-release -o jsonpath=&quot;{.data.jenkins-admin-password}&quot; | base64 --decode);echo
 xxxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제 웹 브라우저에서 localhost:8080 로 접속해서 admin 계정으로 로그인합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkins 관리 &amp;gt; 시스템 설정 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;# of executors&lt;/code&gt;의 값을 10으로 변경하고 저장합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;credential-생성하기&quot;&gt;Credential 생성하기&lt;/h2&gt;

&lt;p&gt;DockerHub에 접속하기 위한 credential을 생성해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkins UI에서 왼쪽 메뉴의 Credentials을 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;목록에서 Jenkins를 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Global credentials을 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;왼쪽 메뉴의 Add Credentials을 클릭합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DockerHub의 Username, Password를 입력하고 ID에 docker_credential을 입력합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OK 버튼을 선택해 저장합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;jenkins-pipeline-생성하기&quot;&gt;Jenkins Pipeline 생성하기&lt;/h2&gt;

&lt;p&gt;소스코드를 빌드하고 DockerHub에 저장하는 Pipeline을 생성해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;왼쪽 메뉴의 New Item을 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Item 이름을 sample-app으로 입력하고 Multibranch Pipeline을 선택합니다.
그리고 OK 버튼을 선택해 다음 화면으로 이동합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;화면 상단의 General으로 이동합니다.
Display Name에 sample-app을 입력합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Branch Sources로 이동합니다.
Add source &amp;gt; Git을 선택합니다. Project Repository에 앞에서 생성한 sample-app 저장소 주소를 입력합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scan Multibranch Pipeline Triggers로 이동합니다.
Periodically if not otherwise run를 체크하고 Interval을 1 minute로 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Save 버튼을 선택해 설정을 저장합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sample-app-저장소에-소스코드-업로드&quot;&gt;sample-app 저장소에 소스코드 업로드&lt;/h2&gt;

&lt;p&gt;위에서 미리 생성한 sample-app 저장소에 소스코드를 업로드하겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sample-app 디렉토리를 생성하고 jenkinsci-demo/sample-app의 소스코드를 복사합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; mkdir sample-app
 cd sample-app
 cp -r ../jenkinsci-demo/sample-app/. ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkinsfile을 수정합니다.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DOCKER_REPOSITORY&lt;/code&gt;를 위에서 생성한 DockerHub 저장소명으로 변경합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; def dockerCredential = &quot;docker_credential&quot;
 def imageTag = &quot;DOCKER_REPOSITORY:${env.BRANCH_NAME}.${env.BUILD_NUMBER}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;소스코드를 저장소에 업로드합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; git init
 git add --all
 git commit -m &quot;first commit&quot;
 git remote add origin https://github.com/REPOSITORY_NAME/sample-app.git
 git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkins Pipeline 확인&lt;/p&gt;

    &lt;p&gt;소스코드가 업로드되면 Jenkins에서 master branch의 변경사항을 감지하고 Pipeline에 정의된 build job을 수행합니다.&lt;/p&gt;

    &lt;p&gt;Job이 성공적으로 수행되면 아래와 같은 화면을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/jenkins/jenkinsci-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Docker build 확인&lt;/p&gt;

    &lt;p&gt;Jenkins Pipeline 수행이 완료되면 Docker 이미지 저장소에서 빌드된 이미지를 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;이미지의 태그명은 &lt;code class=&quot;highlighter-rouge&quot;&gt;BRANCH_NAME.BUILD_NUMBER&lt;/code&gt;과 같이 정의됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/jenkins/jenkinsci-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 확인&lt;/p&gt;

    &lt;p&gt;빌드한 Docker 이미지를 활용하여 애플리케이션을 실행해보겠습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; docker run -p 8080:8080 DOCKER_REPOSITORY_NAME/sample-app:BRANCH_NAME.BUILD_NUMBER
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;애플리케이션이 실행되면 버전을 확인해봅니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ curl localhost:8080/version
 0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;branch-추가&quot;&gt;Branch 추가&lt;/h2&gt;

&lt;p&gt;이번에는 새로운 branch를 만들어 신규 기능을 추가해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;new_feature&lt;/code&gt; branch를 추가합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; git checkout -b new_feature
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Application version을 0.2로 변경합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ vi src/main/resources/application.yaml
 application:
     version: 0.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변경사항을 Git 저장소에 반영합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; git add --all
 git commit -m &quot;Add new feature and Update version as 0.2&quot;
 git push origin new_feature
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkins Pipeline 확인&lt;/p&gt;

    &lt;p&gt;소스코드가 업로드되면 Jenkins에서 new_feature branch의 변경사항을 감지하고 Pipeline에 정의된 build job을 수행합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/jenkins/jenkinsci-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Job이 성공적으로 수행되면 아래와 같은 화면을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/jenkins/jenkinsci-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Docker build 확인&lt;/p&gt;

    &lt;p&gt;Jenkins Pipeline 수행이 완료되면 Docker 이미지 저장소에서 빌드된 이미지를 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;이미지의 태그명은 &lt;code class=&quot;highlighter-rouge&quot;&gt;BRANCH_NAME.BUILD_NUMBER&lt;/code&gt;와 같이 정의됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/jenkins/jenkinsci-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 확인&lt;/p&gt;

    &lt;p&gt;빌드한 Docker 이미지를 활용하여 애플리케이션을 실행해보겠습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; docker run -p 8080:8080 DOCKER_REPOSITORY_NAME/sample-app:BRANCH_NAME.BUILD_NUMBER
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;애플리케이션이 실행되면 버전을 확인해봅니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ curl localhost:8080/version
 0.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;compare--pull-request&quot;&gt;Compare &amp;amp; Pull request&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;new_feature&lt;/code&gt; branch의 신규 기능을 Pull request 해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;새로운 branch가 추가되면 Compare &amp;amp; Pull request 알림이 나타납니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Compare &amp;amp; Pull request&lt;/code&gt; 버튼을 선택합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/jenkins/jenkinsci-06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Merge하는 내용을 비교하고 이상이 없으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Create pull request&lt;/code&gt; 버튼을 선택합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/jenkins/jenkinsci-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;merge-pull-request&quot;&gt;Merge pull request&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Pull request 목록에 방금 요청한 항목이 나타납니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/jenkins/jenkinsci-08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;요청 항목에 문제가 없으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Merge pull request&lt;/code&gt; 버튼을 선택합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/jenkins/jenkinsci-09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;master branch에 new_feature 코드가 병합됩니다.
그리고 Jenkins Pipeline이 master branch의 변경사항을 감지하고 애플리케이션을 다시 빌드합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>sj</name></author><category term="jenkinsci" /><category term="cicd" /><category term="devops" /><category term="kubernetes" /><summary type="html">Overview</summary></entry><entry><title type="html">Argo CD 설치하기</title><link href="http://localhost:4000/cicd/2019/08/04/installing-argocd.html" rel="alternate" type="text/html" title="Argo CD 설치하기" /><published>2019-08-04T00:00:00+09:00</published><updated>2019-08-04T00:00:00+09:00</updated><id>http://localhost:4000/cicd/2019/08/04/installing-argocd</id><content type="html" xml:base="http://localhost:4000/cicd/2019/08/04/installing-argocd.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Argo CD는 지속적인 배포 환경을 구성하기 위한 툴입니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 Argo CD를 Kubernetes 환경에 구성하는 방법에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;h3 id=&quot;kubernetes-클러스터-구성&quot;&gt;Kubernetes 클러스터 구성&lt;/h3&gt;

&lt;p&gt;Argo CD를 설치할 Kubernetes 클러스터 환경을 준비합니다.&lt;/p&gt;

&lt;h3 id=&quot;kubectl-cli-설치&quot;&gt;Kubectl CLI 설치&lt;/h3&gt;

&lt;p&gt;Argo CD를 설치하기 위해 kubectl cli를 설치합니다.&lt;/p&gt;

&lt;h2 id=&quot;argo-cd-설치&quot;&gt;Argo CD 설치&lt;/h2&gt;

&lt;p&gt;argocd namespace를 생성하고 kubectl 명령을 통해 argocd를 kubernetes cluster에 배포합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정상적으로 배포되었는지 조회해봅니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get po -n argocd
NAME                                             READY   STATUS    RESTARTS   AGE
argocd-application-controller-5576758b85-r45zq   1/1     Running   2          26m
argocd-dex-server-c87ff4c6-kgrcp                 1/1     Running   1          26m
argocd-redis-6f4db95c5-r5zbp                     1/1     Running   0          26m
argocd-repo-server-7dc5cc9b47-4m6ng              1/1     Running   0          26m
argocd-server-67c6bd95bc-7qdbl                   1/1     Running   0          26m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;argo-cd-cli-설치&quot;&gt;Argo CD CLI 설치&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/argoproj/argo-cd/releases&quot;&gt;Argo CD Release&lt;/a&gt; 페이지에서 CLI 바이너리를 다운로드합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//OSX
curl -LO https://github.com/argoproj/argo-cd/releases/download/[VERSION]/argocd-darwin-amd64
chmod u+x argocd-darwin-amd64
mv argocd-darwin-amd64 /usr/local/bin/argocd

//Linux
curl -LO https://github.com/argoproj/argo-cd/releases/download/[VERSION]/argocd-linux-amd64
chmod u+x argocd-linux-amd64
mv argocd-linux-amd64 /usr/local/bin/argocd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;argo-cd-api-서버에-접속하기&quot;&gt;Argo CD API 서버에 접속하기&lt;/h2&gt;

&lt;p&gt;Argo CD 설치 시 기본 설정은 API 서버를 외부 주소로 노출시키지 않습니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 세 가지 방법으로 API 서버를 외부에서 접속할 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Service Type을 Load Balancer로 설정&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 Service Type을 Load Balancer로 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl patch svc argocd-server -n argocd -p '{&quot;spec&quot;: {&quot;type&quot;: &quot;LoadBalancer&quot;}}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ingress 설정&lt;/p&gt;

    &lt;p&gt;아래 가이드를 참고하여 Ingress를 설정합니다.&lt;/p&gt;

    &lt;p&gt;https://argoproj.github.io/argo-cd/operator-manual/ingress/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Port Forwarding 설정&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 Port Forwarding을 설정합니다.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8080&lt;/code&gt;으로 서버에 접속할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl port-forward svc/argocd-server -n argocd 8080:443
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;로그인&quot;&gt;로그인&lt;/h2&gt;

&lt;p&gt;Argo CD의 admin 계정 암호는 argocd-server pod 이름으로 자동 설정됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server -o name | cut -d'/' -f 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 암호를 사용하여 admin으로 로그입합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;argocd login [SERVER_ADDRESS]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 명령을 실행하여 패스워드를 변경합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;argocd account update-password
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;웹 브라우저를 통해서도 서버에 접속할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/argocd/installing-argocd-login.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;샘플-애플리케이션-배포&quot;&gt;샘플 애플리케이션 배포&lt;/h2&gt;

&lt;p&gt;이제 Argo CD를 활용하여 샘플 애플리케이션을 배포해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;cli-사용&quot;&gt;CLI 사용&lt;/h3&gt;

&lt;p&gt;Argo CD CLI를 사용하여 샘플 애플리케이션을 배포합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;아래 명령을 실행하여 샘플 애플리케이션을 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; argocd app create sample-app \
 --repo https://github.com/argoproj/argocd-example-apps.git \
 --path guestbook \
 --dest-server https://kubernetes.default.svc \
 --dest-namespace default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;생성한 sample-app을 조회해보면 STATUS가 OutOfSync입니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ argocd app get sample-app
 Name:               guestbook
 Server:             https://kubernetes.default.svc
 Namespace:          default
 ...
 GROUP  KIND        NAMESPACE  NAME          STATUS     HEALTH
 apps   Deployment  default    guestbook-ui  OutOfSync  Missing
     Service     default    guestbook-ui  OutOfSync  Missing
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아래 명령을 실행하여 sample-app을 동기화합니다.
동기화하면 kubectl apply 명령을 실행해 애플리케이션을 클러스터에 배포합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; argocd app sync guestbook
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;ui-활용&quot;&gt;UI 활용&lt;/h3&gt;

&lt;p&gt;웹 브라우저에서 Argo CD UI를 통해 샘플 애플리케이션을 배포해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Create Application 버튼을 선택합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/argocd/installing-argocd-deploy-00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Application Name에 sample-app, Project는 default를 선택합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/argocd/installing-argocd-deploy-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Repository URL에 https://github.com/argoproj/argocd-example-apps.git 를 입력합니다.
Revision은 Head, Path는 guestbook을 입력합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/argocd/installing-argocd-deploy-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cluster URL은 https://kubernetes.default.svc, Namespace는 default를 선택합니다.
그리고 화면 상단의 Create 버튼을 선택해 애플리케이션을 생성합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/argocd/installing-argocd-deploy-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;처음 배포하면 Status가 OutOfSync 상태입니다. Sync 버튼을 선택해 동기화합니다.
동기화하면 kubectl apply 명령을 실행해 애플리케이션을 클러스터에 배포합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/argocd/installing-argocd-deploy-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포가 완료되면 아래와 같은 모습니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes/argocd/installing-argocd-deploy-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>sj</name></author><category term="argocd" /><category term="cicd" /><category term="devops" /><category term="kubernetes" /><summary type="html">Overview</summary></entry><entry><title type="html">CircleCI를 활용한 코드 통합, 빌드, 배포 파이프라인 구성하기</title><link href="http://localhost:4000/cicd/2019/07/03/circleci.html" rel="alternate" type="text/html" title="CircleCI를 활용한 코드 통합, 빌드, 배포 파이프라인 구성하기" /><published>2019-07-03T00:00:00+09:00</published><updated>2019-07-03T00:00:00+09:00</updated><id>http://localhost:4000/cicd/2019/07/03/circleci</id><content type="html" xml:base="http://localhost:4000/cicd/2019/07/03/circleci.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;CircleCI는 소스코드를 통합하고 빌드, 배포를 자동화하는 파이프라인을 구성하기 위한 툴입니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 아래와 같은 서비스를 통합하여 CI/CD 환경을 구성해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;형상 관리: Github&lt;/li&gt;
  &lt;li&gt;빌드, 배포, 파이프라인: Circle CI&lt;/li&gt;
  &lt;li&gt;이미지 저장소: AWS ECR(Elastic Container Registry)&lt;/li&gt;
  &lt;li&gt;애플리케이션 서버: AWS ECS(Elastic Container Service) Fargate&lt;/li&gt;
  &lt;li&gt;알림: Slack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/cloud/circleci/circleci_architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;h3 id=&quot;샘플-코드-준비하기&quot;&gt;샘플 코드 준비하기&lt;/h3&gt;

&lt;p&gt;이 문서에서는 &lt;a href=&quot;https://github.com/YunSangJun/circleci-demo&quot;&gt;circleci-demo&lt;/a&gt; 프로젝트를 활용하겠습니다.&lt;/p&gt;

&lt;p&gt;위 프로젝트를 자신의 Github 계정으로 fork합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/cloud/circleci/circleci-prep-code.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;aws-ecrelastic-container-registry-구성&quot;&gt;AWS ECR(Elastic Container Registry) 구성&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/cloud/2019/06/21/aws-cicd03.html&quot;&gt;AWS에서 CI/CD 환경 구성 #3 - 코드 빌드, CodeBuild&lt;/a&gt;
문서의 &lt;code class=&quot;highlighter-rouge&quot;&gt;사전 준비 &amp;gt; ECR(Elastic Container Registry) 생성&lt;/code&gt; 섹션을 참고하여 ECR을 생성하겠습니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
ECR 이름은 `circleci-demo`로 생성하겠습니다.
&lt;/p&gt;

&lt;h3 id=&quot;ecr에-샘플-코드-이미지-저장&quot;&gt;ECR에 샘플 코드 이미지 저장&lt;/h3&gt;

&lt;p&gt;위에서 fork한 프로젝트를 로컬로 복제합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone REPOSITORY_URL
$ cd circleci-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Maven 빌드 명령을 실행해 jar 파일을 생성합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mvn clean package
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Docker 빌드 명령을 실행해 Docker 이미지를 생성합니다. 
AWS_ACCOUNT_ID, AWS_DEFAULT_REGION는 자신의 AWS 환경 정보를 입력합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export ECR_REPOSITORY_NAME=&quot;circleci-demo&quot;
$ export AWS_ACCOUNT_ID=&quot;xxx&quot;
$ export AWS_DEFAULT_REGION=&quot;xxx&quot;
$ export FULL_IMAGE_NAME=&quot;${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY_NAME}:latest&quot;
$ docker build -t $FULL_IMAGE_NAME .
$ docker images
REPOSITORY                                    TAG                 IMAGE ID            CREATED             SIZE
xxx.dkr.ecr.xxx.amazonaws.com/circleci-demo   latest              d692168175e6        2 minutes ago       122MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ECR에 로그인하고 Docker 이미지를 ECR에 저장합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ eval $(aws ecr get-login --region $AWS_DEFAULT_REGION --no-include-email)
$ docker push $FULL_IMAGE_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ECR Console에 접속해서 circleci-demo 저장소로 이동해 위에서 저장한 이미지의 주소를 복사해둡니다.
이 주소는 아래 ECS Task 구성시 사용하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xxx.dkr.ecr.xxx.amazonaws.com/circleci-demo:latest&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;aws-ecs-cluster-구성&quot;&gt;AWS ECS Cluster 구성&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/cloud/2019/06/23/aws-ecs-01.html&quot;&gt;AWS ECS 구성 및 활용하기 #1 - 사전 준비 및 클러스터 생성하기&lt;/a&gt; 
문서의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ECS Cluster 생성&lt;/code&gt; 섹션을 참고하여 클러스터를 생성하겠습니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
클러스터 이름은 `circleci-demo`로 생성하겠습니다.
&lt;/p&gt;

&lt;h3 id=&quot;aws-ecs-task-구성&quot;&gt;AWS ECS Task 구성&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/cloud/2019/06/23/aws-ecs-02.html&quot;&gt;AWS ECS 구성 및 활용하기 #2 - 작업 정의 구성하기(ECS Task)&lt;/a&gt;
문서를 참고하여 작업 정의를 생성하겠습니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
작업 정의 이름은 `circleci-demo`로 생성하겠습니다.&lt;br /&gt;
컨테이너 이미지 주소는 `ECR에 샘플 코드 이미지 저장` 섹션에서 복사해둔 주소를 입력하겠습니다.
&lt;/p&gt;

&lt;h3 id=&quot;aws-ecs-service-구성&quot;&gt;AWS ECS Service 구성&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/cloud/2019/06/23/aws-ecs-03.html&quot;&gt;AWS ECS 구성 및 활용하기 #3 - 서비스(ECS Service) 구성하기&lt;/a&gt;
문서를 참고하여 ECS 서비스를 구성하겠습니다.&lt;/p&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
서비스 이름은 `circleci-demo`로 생성하겠습니다.
&lt;/p&gt;

&lt;h2 id=&quot;circleci에-빌드-및-배포-구성하기&quot;&gt;CircleCI에 빌드 및 배포 구성하기&lt;/h2&gt;

&lt;h3 id=&quot;circleci에-접속하기&quot;&gt;CircleCI에 접속하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://circleci.com&quot;&gt;CircleCI 콘솔&lt;/a&gt;에 접속합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;화면 상단 오른쪽의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Log In&lt;/code&gt; 버튼을 선택합니다.
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-login-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Log In with GitHub&lt;/code&gt; 버튼을 선택해 자신의 Github 계정으로 로그인하겠습니다. 
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-login-02.png&quot; alt=&quot;&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;github-프로젝트-연동하기&quot;&gt;Github 프로젝트 연동하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CircleCI Console에 접속 &amp;gt; 왼쪽 메뉴의 Add Project 선택&lt;/li&gt;
  &lt;li&gt;Project 리스트 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;circleci-demo&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Set Up Project&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-add-project-01.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로젝트-설정하기&quot;&gt;프로젝트 설정하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Settings &amp;gt; Organization &amp;gt; Projects &amp;gt; Followed projects &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;circleci-demo&lt;/code&gt; &amp;gt; 설정 버튼(톱니바퀴 아이콘) 선택
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-setup.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Permissions &amp;gt; AWS Permissions &amp;gt; Access Key ID, Secret Access Key 입력
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-aws-permission.png&quot; alt=&quot;&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Permissions &amp;gt; Build Settings &amp;gt; Environment Variables &amp;gt; 아래 환경 변수 입력&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/circleci/circleci-env.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;이름&lt;/td&gt;
          &lt;td&gt;값&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;AWS_ACCOUNT_ID&lt;/td&gt;
          &lt;td&gt;계정 아이디&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;AWS_DEFAULT_REGION&lt;/td&gt;
          &lt;td&gt;리전 이름&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;AWS_RESOURCE_NAME_PREFIX&lt;/td&gt;
          &lt;td&gt;circleci-demo&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;빌드-및-배포-설정하기&quot;&gt;빌드 및 배포 설정하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;circleci-demo&lt;/code&gt; 프로젝트 root에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.circleci&lt;/code&gt; 디렉토리를 생성합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir .circleci
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.circleci&lt;/code&gt; 디렉토리 하위에 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.yml&lt;/code&gt; 파일을 생성하고 단계별로 설정해보겠습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi .circleci/config.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;먼저 Version을 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: 2.1
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;다음으로 Orbs를 설정합니다. Orbs는 CircleCI 플랫폼을 빠르게 사용할 수 있도록 도와주는 패키지입니다. 
&lt;code class=&quot;highlighter-rouge&quot;&gt;aws-cli&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;aws-ecs&lt;/code&gt; 패키지를 설정하겠습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
orbs:
  aws-cli: circleci/aws-cli@0.1.4
  aws-ecs: circleci/aws-ecs@0.0.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;working directory를 Home의 circleci-demo 디렉토리로 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    working_directory: ~/circleci-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드 서버로 사용할 컨테이너의 base image를 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    docker:
    - image: circleci/openjdk:8-jdk-browsers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;소스코드를 체크아웃하겠습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      - checkout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Remote에 있는 Docker 데몬을 사용하도록 설정하겠습니다. 
빌드 서버로 사용할 컨테이너에는 Docker 클라이언트 툴만 설치하고 실제 빌드는 Remote에 있는 Docker 데몬을 사용합나디.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - setup_remote_docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;저장된 프로젝트 의존성 라이브러리의 캐시가 있는 경우 복구합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - restore_cache:
          key: circleci-demo-        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;프로젝트 의존성 라이브러리를 다운로드합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run: mvn dependency:go-offline  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;다운로드한 프로젝트 의존성 라이브러리를 캐싱합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - save_cache:
          paths:
            - ~/.m2
          key: circleci-demo-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;소스코드를 Maven 빌드해 JAR 파일을 생성합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run: mvn package
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드 테스트 결과를 저장할 경로를 지정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - store_test_results:
          path: target/surefire-reports
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드 결과물인 JAR 파일의 저장 경로를 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - store_artifacts:
          path: target/circleci-demo-0.0.1-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;ECR의 이미지 경로를 환경 변수로 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run:
          name: Setup common environment variables
          command: |
            echo 'export ECR_REPOSITORY_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export FULL_IMAGE_NAME=&quot;${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY_NAME}:${CIRCLE_SHA1}&quot;' &amp;gt;&amp;gt; $BASH_ENV
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드한 JAR 파일을 구동할 Docker 이미지를 빌드합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run:
          name: Build image
          command: |
            docker build -t $FULL_IMAGE_NAME .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드한 Docker 이미지가 정상 동작하는지 테스트합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run:
          name: Test image
          command: |
            docker run -d -p 8080:8080 --name built-image $FULL_IMAGE_NAME
            sleep 10
            docker run --network container:built-image appropriate/curl --retry 10 --retry-connrefused http://localhost:8080 | grep &quot;Hello World&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드한 Docker 이미지를 아카이브(TAR) 파일로 저장합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - run:
          name: Save image to an archive
          command: |
            mkdir docker-image
            docker save -o docker-image/image.tar $FULL_IMAGE_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Workflow의 다음 단계에서 사용할 임시 파일을 영구적으로 저장하기 위한 설정을합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
    steps:
      ...
      - persist_to_workspace:
          root: .
          paths:
            - docker-image
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;다음으로 배포(deploy) 설정을 하겠습니다. 
배포 서버로 사용할 컨테이너 이미지를 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:  
    docker:
      - image: circleci/python:3.6.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;AWS 클라이언트 툴 사용 시 결과 출력의 포맷을 JSON으로 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy: 
    ...
    environment:
      AWS_DEFAULT_OUTPUT: json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;소스코드를 체크아웃하겠습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      - checkout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Remote에 있는 Docker 데몬을 사용하도록 설정하겠습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - setup_remote_docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;워크플로우의 workspace를 배포 서버로 사용하는 컨테이너에 연결합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - attach_workspace:
          at: workspace
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;컨테이너에 AWS CLI(Command Line Interface)를 설치합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - aws-cli/install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;AWS CLI를 사용하기 위해 Access key와 Region 정보를 설정합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - aws-cli/configure:
          aws-access-key-id: &quot;$AWS_ACCESS_KEY_ID&quot;
          aws-region: &quot;$AWS_DEFAULT_REGION&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;빌드 과정에서 저장한 Docker 이미지를 로드합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - run:
          name: Load image
          command: |
            docker load --input workspace/docker-image/image.tar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;ECS 및 이미지 환경 변수를 설정합니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;AWS_RESOURCE_NAME_PREFIX&lt;/code&gt;와 같은 변수는 앞의 프로젝트 설정에서 저장한 값이 주입됩니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - run:
          name: Setup common environment variables
          command: |
            echo 'export ECS_CLUSTER_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export ECS_SERVICE_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export FULL_IMAGE_NAME=&quot;${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${AWS_RESOURCE_NAME_PREFIX}:${CIRCLE_SHA1}&quot;' &amp;gt;&amp;gt; $BASH_ENV
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;ECR에 로그인하고 Docker 이미지를 push합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - run:
          name: Push image
          command: |
            eval $(aws ecr get-login --region $AWS_DEFAULT_REGION --no-include-email)
            docker push $FULL_IMAGE_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;ECS 서비스를 업데이트합니다.
기존 이미지를 새로 빌드한 Docker 이미지로 빌드합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - aws-ecs/update-service:
          family: &quot;${ECS_SERVICE_NAME}&quot;
          cluster-name: &quot;${ECS_CLUSTER_NAME}&quot;
          container-image-name-updates: &quot;container=${ECS_SERVICE_NAME},image-and-tag=${FULL_IMAGE_NAME}&quot;
          verify-revision-is-deployed: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;배포한 ECS 서비스가 정상 동작하는지 테스트합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
    steps:
      ...
      - run:
          name: Test deployment (Please manually tear down AWS resources after use, if desired)
          command: |
            TARGET_GROUP_ARN=$(aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME | jq -r '.services[0].loadBalancers[0].targetGroupArn')
            ELB_ARN=$(aws elbv2 describe-target-groups --target-group-arns $TARGET_GROUP_ARN | jq -r '.TargetGroups[0].LoadBalancerArns[0]')
            ELB_DNS_NAME=$(aws elbv2 describe-load-balancers --load-balancer-arns $ELB_ARN | jq -r '.LoadBalancers[0].DNSName')
            for attempt in {1..50}; do
              curl -s --retry 10 http://$ELB_DNS_NAME | grep -E &quot;Hello World&quot;
            done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;workflows를 설정합니다.
앞선 과정의 build 및 deploy를 순차적으로 실행합니다.
filters를 설정해 Github의 master 브랜치에 변경이 있는 경우에만 빌드를 하도록합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
jobs:
  build:
    ...
  deploy:
    ...
workflows:
  version: 2
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              only: master
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;전체-설정-코드&quot;&gt;전체 설정 코드&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: 2.1
orbs:
  aws-cli: circleci/aws-cli@0.1.4
  aws-ecs: circleci/aws-ecs@0.0.3
jobs:
  build:
    working_directory: ~/circleci-demo

    docker:
      - image: circleci/openjdk:8-jdk-browsers

    steps:
      - checkout
      - setup_remote_docker

      - restore_cache:
          key: circleci-demo-
      
      - run: mvn dependency:go-offline
      
      - save_cache:
          paths:
            - ~/.m2
          key: circleci-demo-
      
      - run: mvn package
      
      - store_test_results:
          path: target/surefire-reports
      
      - store_artifacts:
          path: target/circleci-demo-0.0.1-SNAPSHOT.jar

      - run:
          name: Setup common environment variables
          command: |
            echo 'export ECR_REPOSITORY_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export FULL_IMAGE_NAME=&quot;${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY_NAME}:${CIRCLE_SHA1}&quot;' &amp;gt;&amp;gt; $BASH_ENV
      
      - run:
          name: Build image
          command: |
            docker build -t $FULL_IMAGE_NAME .

      - run:
          name: Test image
          command: |
            docker run -d -p 8080:8080 --name built-image $FULL_IMAGE_NAME
            sleep 10
            docker run --network container:built-image appropriate/curl --retry 10 --retry-connrefused http://localhost:8080 | grep &quot;Hello World&quot;
      
      - run:
          name: Save image to an archive
          command: |
            mkdir docker-image
            docker save -o docker-image/image.tar $FULL_IMAGE_NAME
            
      - persist_to_workspace:
          root: .
          paths:
            - docker-image
  deploy:  
    docker:
      - image: circleci/python:3.6.1
    environment:
      AWS_DEFAULT_OUTPUT: json
    steps:
      - checkout
      - setup_remote_docker
      - attach_workspace:
          at: workspace
      - aws-cli/install
      - aws-cli/configure:
          aws-access-key-id: &quot;$AWS_ACCESS_KEY_ID&quot;
          aws-region: &quot;$AWS_DEFAULT_REGION&quot;
      - run:
          name: Load image
          command: |
            docker load --input workspace/docker-image/image.tar
      - run:
          name: Setup common environment variables
          command: |
            echo 'export ECS_CLUSTER_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export ECS_SERVICE_NAME=&quot;${AWS_RESOURCE_NAME_PREFIX}&quot;' &amp;gt;&amp;gt; $BASH_ENV
            echo 'export FULL_IMAGE_NAME=&quot;${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${AWS_RESOURCE_NAME_PREFIX}:${CIRCLE_SHA1}&quot;' &amp;gt;&amp;gt; $BASH_ENV
      - run:
          name: Push image
          command: |
            eval $(aws ecr get-login --region $AWS_DEFAULT_REGION --no-include-email)
            docker push $FULL_IMAGE_NAME
      - aws-ecs/update-service:
          family: &quot;${ECS_SERVICE_NAME}&quot;
          cluster-name: &quot;${ECS_CLUSTER_NAME}&quot;
          container-image-name-updates: &quot;container=${ECS_SERVICE_NAME},image-and-tag=${FULL_IMAGE_NAME}&quot;
          verify-revision-is-deployed: true
      - run:
          name: Test deployment (Please manually tear down AWS resources after use, if desired)
          command: |
            TARGET_GROUP_ARN=$(aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME | jq -r '.services[0].loadBalancers[0].targetGroupArn')
            ELB_ARN=$(aws elbv2 describe-target-groups --target-group-arns $TARGET_GROUP_ARN | jq -r '.TargetGroups[0].LoadBalancerArns[0]')
            ELB_DNS_NAME=$(aws elbv2 describe-load-balancers --load-balancer-arns $ELB_ARN | jq -r '.LoadBalancers[0].DNSName')
            for attempt in {1..50}; do
              curl -s --retry 10 http://$ELB_DNS_NAME | grep -E &quot;Hello World&quot;
            done
workflows:
  version: 2
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              only: master
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;변경사항-반영&quot;&gt;변경사항 반영&lt;/h3&gt;

&lt;p&gt;변경사항을 Github에 반영합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add --all
$ git commit -m &quot;Updated circleci configuration&quot;
$ git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;빌드-및-배포-상태-확인&quot;&gt;빌드 및 배포 상태 확인&lt;/h3&gt;

&lt;p&gt;Github에 변경사항이 발생하면 CircleCI에서 이를 감지하여 빌드 및 배포를 수행합니다.&lt;/p&gt;

&lt;p&gt;CicleCI 콘솔에서 Workflows 메뉴를 선택하면 빌드 및 배포 상태를 확인할 수 있습니다.
빌드 또는 배포 상태를 선택하면 해당 Job의 상세 정보를 확인할 수 있습니다.
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-workflows.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CicleCI 콘솔에서 Jobs 메뉴를 선택하면 실행 또는 완료된 Job의 목록을 확인할 수 있습니다.
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-jobs-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;목록에서 Job을 선택하면 상세정보를 확인할 수 있습니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-jobs-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Deploy job의 마지막 단계인 Test deployment 로그를 확인해보면 ECS 서비스가 정상적으로 
배포되었는지 테스트하는 로그를 확인할 수 있습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Hello World(Version 1)&lt;/code&gt; 메세지가 계속 출력되면 배포가 정상적으로 완료된것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/cloud/circleci/circleci-jobs-03.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;slack-연동&quot;&gt;Slack 연동&lt;/h3&gt;

&lt;p&gt;다음으로 CircleCI를 Slack Chat 서비스와 연동하여 빌드 및 배포 성공/실패에 대한 알람을 받을 수 있도록 설정해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://api.slack.com/apps&quot;&gt;Slack MyApp&lt;/a&gt; 페이지에 접속합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create New App 버튼을 선택합니다.
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-slack-01.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;App Name에 circleci-demo를 입력하고 Slack workspace를 선택한뒤 Create App 버튼은 선택합니다.
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-slack-02.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Slack 메신저에서 circleci-demo 채널을 생성합니다.
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-slack-03.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다시 Slack MyApp 페이지로 돌아와서 생성한 circleci-demo 앱을 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Features &amp;gt; Incoming Webhooks &amp;gt; Activate Incoming Webhooks를 On으로 변경합니다.
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-slack-04.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하단의 Webhook URL의 Add New Webhook to Workspace 버튼을 선택합니다. 
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-slack-05.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Post to에서 circleci-demo 채널을 선택하고 Install 버튼을 선택합니다.
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-slack-06.png&quot; alt=&quot;&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;생성된 Webhook URL을 복사해둡니다.
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-slack-07.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다시 CircleCI 콘솔로 이동해서 프로젝트 설정 화면으로 이동합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notifications &amp;gt; Chat Notifications &amp;gt; Webhook URL에 복사해둔 URL을 붙여넣고 저장합니다.
&lt;img src=&quot;/assets/images/cloud/circleci/circleci-slack-08.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제 소스코드를 수정해서 빌드 및 배포를 다시 실행해보겠습니다. 
아래 파일에서 Version을 2로 변경하고 Commit &amp;amp; Push합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;circleci-demo/src/main/java/com/example/demo/HomeRestController.java&amp;gt;
...
  @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)
  public String getHome() {
    return &quot;Hello World(Version 2)&quot;; 
  }
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CircleCI에서 소스 변경을 감지하고 빌드 및 배포 Job을 실행합니다. 
완료 되면 아래와 같이 Slack 채널에 빌드 및 배포 성공을 알리는 메세지가 출력됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/circleci/circleci-slack-09.png&quot; alt=&quot;&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>sj</name></author><category term="circleci" /><category term="cicd" /><category term="devops" /><summary type="html">Overview</summary></entry><entry><title type="html">AWS ECS 구성 및 활용하기 #3 - 서비스(ECS Service) 구성하기</title><link href="http://localhost:4000/cloud/2019/06/23/aws-ecs-03.html" rel="alternate" type="text/html" title="AWS ECS 구성 및 활용하기 #3 - 서비스(ECS Service) 구성하기" /><published>2019-06-23T00:00:00+09:00</published><updated>2019-06-23T00:00:00+09:00</updated><id>http://localhost:4000/cloud/2019/06/23/aws-ecs-03</id><content type="html" xml:base="http://localhost:4000/cloud/2019/06/23/aws-ecs-03.html">&lt;p&gt;AWS에서 ECS(Elastic Container Service)의 서비스(ECS Service)를 통해 작업 정의(컨테이너)를 관리할 수 있습니다. 
로드 밸런서와 연동하여 트랙픽을 다중 컨테이너에 분산할 수 있습니다. 
Auto Scailing을 사용하여 사용량에 기반하여 컨테이너 개수를 조절할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 서비스(ECS Service)를 구성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;p&gt;ECS 서비스를 구성하기 위해서 EBL를 생성합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;EC2 Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; 로드 밸런싱 &amp;gt; 로드밸런서 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;로드 밸런서 생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-01.png&quot; alt=&quot;&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로드밸런서 유형 선택 &amp;gt; Application Load Balancer &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기본 구성 &amp;gt; 이름 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리스너 &amp;gt; 기본 값인 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP, 80&lt;/code&gt; 그대로 사용(애플리케이션 접속시 http를 사용하여 접속)
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;가용 영역 &amp;gt; VPC, 가용 영역 및 Subnet(Public) 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;보안 설정은 변경 없이 &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;보안 그룹 구성&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;보안 그룹 할당 &amp;gt; 새 보안 그룹 생성 선택&lt;/li&gt;
      &lt;li&gt;보안 그룹 이름에 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력&lt;/li&gt;
      &lt;li&gt;설명에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Allow http&lt;/code&gt; 입력&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;유형 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대상 그룹&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;대상 그룹 &amp;gt; 새 대상 그룹 선택&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이름 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo-service&lt;/code&gt; 입력&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상태 검사&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;고급 상태 검사 설정 확장&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;포트 &amp;gt; 재정의 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;8080&lt;/code&gt; 입력(작업 정의에서 컨테이너 포트를 8080으로 지정)&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대상 등록은 설정 변경 없이 &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;전체적으로 검토 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-lb-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;서비스-생성하기&quot;&gt;서비스 생성하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ECS Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; Amazon ECS &amp;gt; 클러스터 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터 리스트 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 탭 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-01.png&quot; alt=&quot;&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 구성&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;시작 유형 &amp;gt; FARGATE 선택&lt;/li&gt;
      &lt;li&gt;서비스 이름 &amp;gt; cicd-demo 입력&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;작업 개수 &amp;gt; 2 입력&lt;/p&gt;

        &lt;p&gt;&lt;a href=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-02.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deployments &amp;gt; Rolling Update 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
    &lt;p class=&quot;tip-content&quot;&gt;
  - Rolling Update는 기존 버전의 인스턴스를 순차적으로 새로운 버전으로 업데이트하는 방식입니다.
  새로운 인스턴스를 생성하지 않기 때문에 비용 효율적입니다.&lt;br /&gt;

  - Blue/green deployment는 기존 버전의 인스턴스만큼 새로운 버전의 인스턴스를 배포합니다.
  새로운 버전을 테스트하고 트래픽을 일시에 기존 버전에서 새로운 버전으로 이동할 수 있습니다.
  새로운 인스턴스를 기존 버전만큼 생성해야하므로 비용면에서 상대적으로 비효율적입니다.
  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;네트워크 구성 &amp;gt; VPC 및 보안 그룹&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;클러스터 VPC &amp;gt; 컨테이너가 위치할 VPC를 선택&lt;/li&gt;
      &lt;li&gt;서브넷 &amp;gt; 컨테이너가 위치할 서브넷을 선택(이 문서에서는 Private 서브넷을 기준으로 작성함)&lt;/li&gt;
      &lt;li&gt;보안 그룹 &amp;gt; 편집 선택 &amp;gt; 보안 그룹 구성&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;자동 할당 퍼블릭 IP &amp;gt; DISABLED 선택&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-04-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

        &lt;p class=&quot;warning-title&quot;&gt;경고&lt;/p&gt;
        &lt;p class=&quot;warning-content&quot;&gt;
  - 자동 할당 퍼블릭 IP를 DISABLED로 선택할 경우 컨테이너에 퍼블릭 IP가 할당되지 않습니다.
  컨테이너에서 외부와의 통신을 하려면 컨테이너가 위치한 Private 서브넷이 외부와 통신할 수 있는 NAT와 연결되어야 합니다.&lt;br /&gt;
  - 자동 할당 퍼블릭 IP를 ENABLED로 선택할 경우 컨테이너에 퍼블릭 IP가 할당됩니다.
  컨테이너는 Public 서브넷에 위치하고 해당 서브넷은 IGW(Internet Gateway)와 연결되어 있어야 합니다.
  &lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;보안 그룹 구성&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;할당된 보안 그룹 &amp;gt; 새 보안 그룹 생성 선택&lt;/li&gt;
          &lt;li&gt;보안 그룹 이름 &amp;gt; cicd-demo-service 입력&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;인바운드 규칙 &amp;gt; 유형에서 Custom TCP 선택 &amp;gt; 포트 범위 8080 입력(로드밸런서에서 컨테이너의 8080 포트로의 인바운드 트래픽)&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-04-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Elastic Load Balancing&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ELB 유형 &amp;gt; Application Load Balancer 선택&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;ELB 이름 &amp;gt; cicd-demo 선택(사전 준비에서 생성)&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로드를 밸런싱할 컨테이너&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;cicd-demo:8080:8080 선택(작업 정의에서 생성) &amp;gt; ELB에 추가 버튼 선택&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-06-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;리스너 포트 &amp;gt; 80:HTTP 선택(사전 준비에서 생성)&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;대상 그룹 이름 &amp;gt; cicd-demo-service 선택&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-06-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다른 설정은 기본 설정을 사용 &amp;gt; 다음 단계 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 Auto Scaling은 사용하지 않음 &amp;gt; 다음 단계 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 검토를 전반적으로 하고 생성하기 버튼 선택해서 서비스 생성 완료
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;서비스-확인&quot;&gt;서비스 확인&lt;/h2&gt;

&lt;p&gt;이제 서비스가 정상적으로 구성되었는지 확인해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ECS Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; Amazon ECS &amp;gt; 클러스터 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터 리스트 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 탭 선택 &amp;gt; 상태가 Active인지 확인
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;작업 탭 선택 &amp;gt; 마지막/원하는 상태가 Running인지 확인
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EC2 Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; 로드 밸런싱 &amp;gt; 로드밸런서 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로드밸런서 리스트 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대상 탭 선택 &amp;gt; 등록된 대상 &amp;gt; 상태가 healthy인지 확인
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설명 탭 선택 &amp;gt; DNS 이름 복사
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;웹 브라우저 &amp;gt; 복사한 DNS 이름 붙여넣고 접속 &amp;gt; 서비스 정상 접속 확인
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bluegreen-deployment선택&quot;&gt;Blue/green deployment(선택)&lt;/h2&gt;

&lt;p&gt;위 과정에서는 서비스 생성 시 deployment 방식을 Rolling Update로 선택했습니다.&lt;/p&gt;

&lt;p&gt;Blue/green deployment를 활용하는 방법을 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;사전-준비-1&quot;&gt;사전 준비&lt;/h3&gt;

&lt;p&gt;Blue/green deployment 방식으로 서비스를 생성하는 경우 CodeDeploy에 애플리케이션 및 배포 그룹이 자동 생성됩니다.&lt;/p&gt;

&lt;p&gt;이를 위해 CodeDeploy 서비스 권한이 있는 IAM 역할 생성이 필요합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IAM Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; AWS Account &amp;gt; 역할 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;역할 만들기&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;신뢰할 수 있는 유형의 개체 선택 &amp;gt; AWS 서비스 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-02-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 역할을 사용할 서비스 선택 &amp;gt; CodeDeploy 선택 &amp;gt; CodeDeploy - ECS 선택 &amp;gt; 다음 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-02-02.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-02-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설정 변경 없이 다음 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설정 변경 없이 다음 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;역할 이름 &amp;gt; codedeploy-cicd-demo-role 입력 &amp;gt; 역할 만들기 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-bg-iam-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서비스-생성&quot;&gt;서비스 생성&lt;/h3&gt;

&lt;p&gt;Blue/green deployment 방식으로 서비스를 생성하는 경우 Rolling Update 방식과 아래 과정만 다릅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Deployments
    &lt;ul&gt;
      &lt;li&gt;Deployment type &amp;gt; Blue/green deployment 선택&lt;/li&gt;
      &lt;li&gt;Service role for CodeDeploy &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음&lt;/code&gt; 버튼 선택
  &lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-bg-01.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Additional configuration
    &lt;ul&gt;
      &lt;li&gt;Target group 1 name &amp;gt; cicd-demo-service 선택&lt;/li&gt;
      &lt;li&gt;Target group 2 name &amp;gt; 새로 생성 선택 &amp;gt; cicd-demo-service-green 입력&lt;/li&gt;
      &lt;li&gt;Target group 2 protocol &amp;gt; HTTP 선택
  &lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-bg-02.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서비스-확인-1&quot;&gt;서비스 확인&lt;/h3&gt;

&lt;p&gt;서비스 확인 방법도 Rolling Update와 동일합니다.&lt;/p&gt;

&lt;p&gt;다른 점은 Blue/green deployment 방식으로 서비스를 생성하는 경우 CodeDeploy에 애플리케이션 및 배포 그룹이 자동 생성됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CodeDeploy console 접속 &amp;gt; 왼쪽 메뉴의 애플리케이션 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 리스트 &amp;gt; AppECS-cicd-demo-cicd-demo 선택 
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-bg-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 그룹 리스트 &amp;gt; DgpECS-cicd-demo-cicd-demo 선택 
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-bg-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 그룹 확인
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-service-bg-05-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>sj</name></author><category term="aws" /><category term="container" /><category term="awsecs" /><category term="awsecsservice" /><category term="awsecsfargate" /><summary type="html">AWS에서 ECS(Elastic Container Service)의 서비스(ECS Service)를 통해 작업 정의(컨테이너)를 관리할 수 있습니다. 로드 밸런서와 연동하여 트랙픽을 다중 컨테이너에 분산할 수 있습니다. Auto Scailing을 사용하여 사용량에 기반하여 컨테이너 개수를 조절할 수 있습니다.</summary></entry><entry><title type="html">AWS ECS 구성 및 활용하기 #2 - 작업 정의 구성하기(ECS Task)</title><link href="http://localhost:4000/cloud/2019/06/23/aws-ecs-02.html" rel="alternate" type="text/html" title="AWS ECS 구성 및 활용하기 #2 - 작업 정의 구성하기(ECS Task)" /><published>2019-06-23T00:00:00+09:00</published><updated>2019-06-23T00:00:00+09:00</updated><id>http://localhost:4000/cloud/2019/06/23/aws-ecs-02</id><content type="html" xml:base="http://localhost:4000/cloud/2019/06/23/aws-ecs-02.html">&lt;p&gt;AWS에서 ECS(Elastic Container Service)의 작업 정의(ECS Task)를 통해 컨테이너 관련 설정을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 작업 정의(ECS Task)를 구성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;p&gt;ECS 작업 정의를 구성하기 위해서 IAM 역할을 생성합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IAM Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; AWS Account &amp;gt; 역할 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;역할 만들기&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-iam-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;개체 선택에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS 서비스&lt;/code&gt; 선택 &amp;gt; 서비스 선택에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Elastic Container Service&lt;/code&gt; 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-iam-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용 사례에서 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Elastic Container Service Task&lt;/code&gt; 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음: 권한&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-iam-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;권한 정책 연결 &amp;gt; 정책 필터에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ecs&lt;/code&gt; 입력 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;AmazonECSTaskExecutionRolePolicy&lt;/code&gt; 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음: 태그&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-iam-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;태그 입력 또는 다음으로 넘어가기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;역할 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;ecstask-cicd-demo-role&lt;/code&gt; 입력 &amp;gt; 역할 검토 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;역할 만들기&lt;/code&gt; 버튼 선택 
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-iam-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ecs-작업-정의&quot;&gt;ECS 작업 정의&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ECS Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; Amazon ECS &amp;gt; 작업 정의 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;새 작업 정의 선택&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecstask-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Fargate 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;다음 단계&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecstask-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;작업 정의 이름에 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력 &amp;gt; 작업 역할 &lt;code class=&quot;highlighter-rouge&quot;&gt;ecstask-cicd-demo-role&lt;/code&gt; 선택(시작하기 에서 생성)
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecstask-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;작업 실행 역할 &lt;code class=&quot;highlighter-rouge&quot;&gt;ecsTaskExecutionRole&lt;/code&gt; 선택(없는 경우 새 역할 생성 선택)
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecstask-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;작업 메모리 &lt;code class=&quot;highlighter-rouge&quot;&gt;2GB&lt;/code&gt; 선택 &amp;gt; 작업 CPU &lt;code class=&quot;highlighter-rouge&quot;&gt;1vCPU&lt;/code&gt; 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecstask-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;컨테이너 정의
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;컨테이너 추가&lt;/code&gt; 버튼 선택&lt;/li&gt;
      &lt;li&gt;팝업 창 &amp;gt; 컨테이너 이름 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력&lt;/li&gt;
      &lt;li&gt;이미지 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;이미지 주소&lt;/code&gt; 입력(시작하기에서 복사한 주소)&lt;/li&gt;
      &lt;li&gt;메모리 제한 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;소프트 제한&lt;/code&gt; 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;500&lt;/code&gt; 입력&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;포트 매핑 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;8080&lt;/code&gt; 입력 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;추가&lt;/code&gt; 버튼 선택&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecstask-06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택해서 작업 정의 생성 완료
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecstask-07.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음으로 &lt;a href=&quot;/cloud/2019/06/23/aws-ecs-03.html&quot;&gt;AWS ECS 구성 및 활용하기 #3 - 서비스(ECS Service) 구성하기&lt;/a&gt;
문서에서 서비스(ECS Service)를 구성하는 방법을 살펴보겠습니다.&lt;/p&gt;</content><author><name>sj</name></author><category term="aws" /><category term="container" /><category term="awsecs" /><category term="awsecstask" /><category term="awsecsfargate" /><summary type="html">AWS에서 ECS(Elastic Container Service)의 작업 정의(ECS Task)를 통해 컨테이너 관련 설정을 할 수 있습니다. 이 문서에서는 작업 정의(ECS Task)를 구성하는 방법을 알아보겠습니다.</summary></entry><entry><title type="html">AWS ECS 구성 및 활용하기 #1 - 사전 준비 및 클러스터 생성하기</title><link href="http://localhost:4000/cloud/2019/06/23/aws-ecs-01.html" rel="alternate" type="text/html" title="AWS ECS 구성 및 활용하기 #1 - 사전 준비 및 클러스터 생성하기" /><published>2019-06-23T00:00:00+09:00</published><updated>2019-06-23T00:00:00+09:00</updated><id>http://localhost:4000/cloud/2019/06/23/aws-ecs-01</id><content type="html" xml:base="http://localhost:4000/cloud/2019/06/23/aws-ecs-01.html">&lt;p&gt;AWS에서 ECS(Elastic Container Service)를 구성하기 위해 필요한 사전 준비와 ECS 클러스터를 생성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;

&lt;p&gt;ECS에 애플리케이션을 배포하기 위해서 소스코드를 Docker 이미지로 빌드하고 이를 Docker Registry에 저장해야합니다.
또한 애플리케이션을 다중 컨테이너에 배포한 경우 로드밸런싱을 활용하여 트래픽을 분산해야합니다.&lt;/p&gt;

&lt;p&gt;이 문서에서는 아래와 같은 구성을 활용하여 ECS를 구성하고 애플리케이션을 배포하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;샘플 애플리케이션: &lt;a href=&quot;https://github.com/spring-projects/spring-petclinic&quot;&gt;spring-petclinic&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;형상 관리: CodeCommit&lt;/li&gt;
  &lt;li&gt;코드 빌드: CodeBuild&lt;/li&gt;
  &lt;li&gt;이미지 저장소: ECR(Elastic Container Registry)&lt;/li&gt;
  &lt;li&gt;로드밸런싱 : ELB(Elastic Load Balancing)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
&lt;p class=&quot;tip-content&quot;&gt;
ECR 또는 외부 이미지 저장소에 이미 빌드한 이미지가 있다면 이 과정을 넘어가도됩니다.
&lt;/p&gt;

&lt;h3 id=&quot;애플리케이션-준비&quot;&gt;애플리케이션 준비&lt;/h3&gt;

&lt;p&gt;아래 문서를 참고하여 형상 관리 저장소에 샘플 애플리케이션을 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/cloud/2019/06/20/aws-cicd02.html&quot;&gt;AWS에서 CI/CD 환경 구성 #2 - 형상 관리 구성, CodeCommit&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;코드-빌드-및-이미지-저장&quot;&gt;코드 빌드 및 이미지 저장&lt;/h3&gt;

&lt;p&gt;다음으로 아래 문서를 참고하여 코드를 빌드하고 이를 이미지 저장소에 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/cloud/2019/06/21/aws-cicd03.html&quot;&gt;AWS에서 CI/CD 환경 구성 #3 - 코드 빌드, CodeBuild&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 단계를 완료하면 아래와 같이 이미지 저장소 주소를 복사합니다.
이 주소는 ECS 환경에 애플리케이션을 배포할 때 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-prep-ecr-01.png&quot; alt=&quot;&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ecs-cluster-생성&quot;&gt;ECS Cluster 생성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ECS Console에 접속 &amp;gt; 왼쪽 메뉴 &amp;gt; Amazon ECS &amp;gt; 클러스터 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메인 화면 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;클러스터 생성&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터 템플릿 선택 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;네트워킹 전용(AWS Fargate 제공)&lt;/code&gt; 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p class=&quot;tip-title&quot;&gt;참고&lt;/p&gt;
    &lt;p class=&quot;tip-content&quot;&gt;
  ECS Fargate는 ECS 서비스를 위한 EC2 인스턴스를 생성하지 않는 완전 관리형 컨테이너 서비스입니다.
  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터 구성 &amp;gt; 클러스터 이름 &lt;code class=&quot;highlighter-rouge&quot;&gt;cicd-demo&lt;/code&gt; 입력 &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt; 버튼 선택
&lt;img src=&quot;/assets/images/cloud/aws/ecs/aws-ecs-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음으로 &lt;a href=&quot;/cloud/2019/06/23/aws-ecs-02.html&quot;&gt;AWS ECS 구성 및 활용하기 #2 - 작업 정의 구성하기(ECS Task)&lt;/a&gt;
문서에서 작업 정의(ECS Task)를 구성하는 방법을 살펴보겠습니다.&lt;/p&gt;</content><author><name>sj</name></author><category term="aws" /><category term="container" /><category term="awsecs" /><category term="awsecsfargate" /><summary type="html">AWS에서 ECS(Elastic Container Service)를 구성하기 위해 필요한 사전 준비와 ECS 클러스터를 생성하는 방법을 알아보겠습니다.</summary></entry></feed>