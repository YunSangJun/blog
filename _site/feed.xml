<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.0">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2018-07-18T08:23:18+09:00</updated><id>http://localhost:4000/blog/</id><title type="html">윤상준의 기술 블로그</title><subtitle>Software &amp; Cloud Engineer 입니다. Kubernetes, Cloud Foundry등의 PaaS와 Cloud 및 DevOps 관련 기술에 관심이 있습니다.</subtitle><author><name>Yun SangJun</name></author><entry><title type="html">Kubernetes 스터디 #7 Logging</title><link href="http://localhost:4000/blog/kubernetes/2018/07/06/kubernetes-logging.html" rel="alternate" type="text/html" title="Kubernetes 스터디 #7 Logging" /><published>2018-07-06T00:00:00+09:00</published><updated>2018-07-06T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/07/06/kubernetes-logging</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/07/06/kubernetes-logging.html">&lt;h2 id=&quot;cloud-native-환경에서-logging-architecture의-변화&quot;&gt;Cloud Native 환경에서 Logging Architecture의 변화&lt;/h2&gt;

&lt;h3 id=&quot;legacy&quot;&gt;Legacy&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/logging/logging-legacy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;고사양의 서버에 Application을 크게 운영&lt;/li&gt;
  &lt;li&gt;Log를 Application이 실행 중인 서버 내부에 저장&lt;/li&gt;
  &lt;li&gt;개발자/운영자는 서버 내부에 접속해 Log를 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cloud-native&quot;&gt;Cloud Native&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/logging/logging-cloud-native.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Application을 작게 운영하고 필요할 때 마다 확장&lt;/li&gt;
  &lt;li&gt;다중 인스턴스의 로그를 효율적으로 검색하기 위해 외부 Log 시스템에 저장&lt;/li&gt;
  &lt;li&gt;개발자/운영자는 서버에 직접 접속하지 않고 외부 Log Backend에서 로그 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cloud-native-logging-architecture&quot;&gt;Cloud Native Logging Architecture&lt;/h2&gt;

&lt;h3 id=&quot;overview&quot;&gt;Overview&lt;/h3&gt;

&lt;h4 id=&quot;daemonset-pattern&quot;&gt;DaemonSet Pattern&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/logging/logging-daemonset.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;App Console Log가 각 Node의 Storage에 자동 저장&lt;/li&gt;
  &lt;li&gt;각 Node의 Agent가 Log를 Aggregator로 전달&lt;/li&gt;
  &lt;li&gt;Log data를 전/후 처리 후 Backend로 전달&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sidecar-pattern&quot;&gt;Sidecar Pattern&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/logging/logging-sidecar.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;App Log를 Pod의 Storage에 파일로 저장(Log4j 등 사용)&lt;/li&gt;
  &lt;li&gt;Pod의 Agent가 Log data를 전/후 처리 후 Backend로 전달&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;daemonset-pattern-상세-architecture&quot;&gt;DaemonSet Pattern 상세 Architecture&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/logging/logging-daemonset-detail.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;App Console Log가 각 Node의 Storage에 자동 저장&lt;/li&gt;
  &lt;li&gt;Fluentbit가 각 Node의 Log 수집해 FluentD로 전달&lt;/li&gt;
  &lt;li&gt;FluentD가 수집한 Log를 전/후 처리 후 ElasticSearch로 전달&lt;/li&gt;
  &lt;li&gt;Log raw data를 S3와 같은 저장소에 동시 전달 가능(Log Data 백업 활용)&lt;/li&gt;
  &lt;li&gt;Kibana를 통해 ES의 Log data 검색/분석 및 시각화&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sidecar-pattern-상세-architecture&quot;&gt;Sidecar Pattern 상세 Architecture&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/logging/logging-sidecar-detail.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;App Log를 Pod의 Storage에 파일로 저장(Log4j 등 사용)&lt;/li&gt;
  &lt;li&gt;Fluentbit가 저장된 Log를 전/후 처리 후 ElasticSearch로 전달.&lt;/li&gt;
  &lt;li&gt;Log raw data를 S3와 같은 저장소에 동시 전달 가능(Log Data 백업 활용)&lt;/li&gt;
  &lt;li&gt;Kibana를 통해 ES의 Log data 검색/분석 및 시각화&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;logging-실습&quot;&gt;Logging 실습&lt;/h2&gt;

&lt;h3 id=&quot;sidecar-pattern-1&quot;&gt;Sidecar Pattern&lt;/h3&gt;

&lt;h4 id=&quot;demo-application-download-및-build&quot;&gt;Demo Application Download 및 Build&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Demo Application Download&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/YunSangJun/logging-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Maven build&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mvn clean package
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Docker build&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker build -t logging-demo .

$ docker images
REPOSITORY                              TAG                 IMAGE ID            CREATED             SIZE
logging-demo                            latest              1444f50dcadc        9 seconds ago       117M
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Application 실행 및 Web Browser에서 localhost:8080 접속.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -p 8080:8080 logging-demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Docker Container에 접속하여 log file 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
79e28edfbb12        logging-demo        &quot;java -Djava.securit…&quot;   4 minutes ago       Up 4 minutes        0.0.0.0:8080-&amp;gt;8080/tcp   gifted_ride

$ docker exec -it 79e28edfbb12 sh
/ # tail -f logs/spring-boot-logging.log
....
2018-07-16 17:31:40.153 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - FrameworkServlet 'dispatcherServlet': initialization completed in 86 ms
2018-07-16 17:31:40.315 [http-nio-8080-exec-1] INFO  com.example.demo.HomeRestController - logback example - info level
2018-07-16 17:31:40.316 [http-nio-8080-exec-1] WARN  com.example.demo.HomeRestController - logback example - warn level
2018-07-16 17:31:40.318 [http-nio-8080-exec-1] ERROR com.example.demo.HomeRestController - logback example - error level
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;deom-application-구조&quot;&gt;Deom Application 구조&lt;/h4&gt;

&lt;p&gt;Logback 설정해 &lt;code class=&quot;highlighter-rouge&quot;&gt;/logs&lt;/code&gt; directory 하위에 log message를 file로 저장&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Log message 출력하는 HomeRestController&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slf4j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slf4j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LoggerFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;springframework&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;web&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RequestMapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;springframework&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;web&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RequestMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;springframework&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;web&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RestController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RestController&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HomeRestController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Logger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LoggerFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLogger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RequestMapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RequestMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getHome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;logback example - debug level&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;logback example - info level&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;warn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;logback example - warn level&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;logback example - error level&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;    

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Logback 설정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;logback-spring.xml&amp;gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;!-- Send debug messages to System.out --&amp;gt;
    &amp;lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
        &amp;lt;!-- By default, encoders are assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder --&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{5} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- Send debug message to file --&amp;gt;
    &amp;lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;file&amp;gt;logs/spring-boot-logging.log&amp;lt;/file&amp;gt;

        &amp;lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&amp;gt;
            &amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;

        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;logs/spring-boot-logging.%d{yyyy-MM-dd}_%i.log&amp;lt;/fileNamePattern&amp;gt;

            &amp;lt;!-- each file should be at most 10MB, keep 30 days worth of history --&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&amp;gt;
                &amp;lt;maxFileSize&amp;gt;10MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;root level=&quot;INFO&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;STDOUT&quot; /&amp;gt;
        &amp;lt;appender-ref ref=&quot;FILE&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;demo-application-및-fluentbit-배포&quot;&gt;Demo Application 및 Fluentbit 배포&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Fluentbit Configmap에 Elasticsearch의 정보 설정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi configmap.yaml
...
  - name: fluent-bit
    env:
     - name: FLUENT_ELASTICSEARCH_HOST
       value: &quot;elasticsearch.kube-system.svc.cluster.local&quot;
     - name: FLUENT_ELASTICSEARCH_PORT
       value: &quot;9200&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;FLUENT_ELASTICSEARCH_HOST의 value : Elasticsearch의 endpoint. IP or Domain or Service&lt;/li&gt;
      &lt;li&gt;FLUENT_ELASTICSEARCH_PORT의 value : Elasticsearch의 port&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Fluentbit Configmap 배포&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl apply -f configmap.yaml

$ kubectl get cm
NAME                 DATA      AGE
fluent-bit-config    4         1m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Demo Application Deployment yaml의 docker image 정보 수정(default 그대로 사용해도 무관)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi deployment.yaml
...
  spec:
      containers:
      - name: logging-demo
        image: yunsangjun/logging-demo:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Demo Application 및 Fluentbit Kubernetes Deployment 배포&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl apply -f deployment.yaml

$ kubectl get deploy
NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
logging-demo       1         1         1            1           1m

$ kubectl get po
NAME                             READY     STATUS     RESTARTS   AGE
logging-demo-6c659fb7cb-zndhs    2/2       Running    0          1m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Demo Application에 Port Forwarding 설정 &amp;gt; Web browser에서 localhost:8080으로 접속&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl port-forward logging-demo-6c659fb7cb-zndhs 8080:8080
Forwarding from 127.0.0.1:8080 -&amp;gt; 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Demo Application 및 Fluentbit Container에 접속해 Log file 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl exec -it logging-demo-6c659fb7cb-zndhs -c logging-demo sh
/ # tail -f /logs/spring-boot-logging.log
2018-07-17 07:47:59.751 [http-nio-8080-exec-5] INFO  com.example.demo.HomeRestController - logback example - info level

$ kubectl exec -it logging-demo-6c659fb7cb-zndhs -c fluent-bit sh
# tail -f /var/logs/spring-boot-logging.log
2018-07-17 07:47:59.751 [http-nio-8080-exec-5] INFO  com.example.demo.HomeRestController - logback example - info level
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;kibana-index-pattern-설정-및-log-message-검색&quot;&gt;Kibana Index Pattern 설정 및 Log message 검색&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Kibana 접속 &amp;gt; Left 메뉴 &amp;gt; Management 메뉴 선택 &amp;gt; Kibana Index Patterns 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/logging/logging-kibana-index-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Index name or pattern input box에 fluentbit 입력 후 Time Filter field name combo box에 @timestamp 선택&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/logging/logging-kibana-index-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정상적으로 생성 시 아래와 같은 모습&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/logging/logging-kibana-index-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Left 메뉴 &amp;gt; Discover 메뉴 선택 &amp;gt; Demo Application의 Log message 검색 됨&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/blog/assets/images/kubernetes/logging/logging-kibana-search.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>윤상준</name></author><summary type="html">Cloud Native 환경에서 Logging Architecture의 변화</summary></entry><entry><title type="html">Terraform 사용하기</title><link href="http://localhost:4000/blog/terraform/2018/06/29/terraform.html" rel="alternate" type="text/html" title="Terraform 사용하기" /><published>2018-06-29T00:00:00+09:00</published><updated>2018-06-29T00:00:00+09:00</updated><id>http://localhost:4000/blog/terraform/2018/06/29/terraform</id><content type="html" xml:base="http://localhost:4000/blog/terraform/2018/06/29/terraform.html">&lt;p&gt;Terraform은 인프라를 코드로 관리할 수 있도록 지원하는 오픈소스 프로젝트입니다.&lt;/p&gt;

&lt;p&gt;멀티 클라우드를 사용하는 것이 최근 트렌드입니다. 그만큼 다양하고 복잡한 클라우드 자원을 효율적으로 관리하는 것이 중요합니다.&lt;/p&gt;

&lt;p&gt;Terraform은 AWS, GCP, Microsoft Azure, OpenStack 등의 멀티 클라우드를 지원하므로 이를 활용해 코드로 인프라 자원을 효율적으로 관리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;참고:&lt;a href=&quot;https://www.terraform.io/docs/providers/index.html&quot;&gt;Terraform 지원 provider&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 페이지에서는 terraform을 사용하여 IBM Cloud에 가상머신을 생성, 삭제하는 방법에 대해 설명합니다.&lt;/p&gt;

&lt;h2 id=&quot;준비하기&quot;&gt;준비하기&lt;/h2&gt;

&lt;p&gt;아래 가이드를 참고하여 Terraform 및 softlayer 플러그인을 설치합니다.&lt;/p&gt;

&lt;p&gt;이 페이지에서는 아래와 같은 버전을 기준으로 작성했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Terraform : v0.11.7&lt;/li&gt;
  &lt;li&gt;softlayer 플러그인 : 1.5.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;terraform-설치&quot;&gt;Terraform 설치&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;아래 페이지에서 OS별 바이너리 다운로드&lt;/p&gt;

    &lt;p&gt;https://www.terraform.io/downloads.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OSX&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mv terraform /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;softlayer-플러그인-다운로드&quot;&gt;softlayer 플러그인 다운로드&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;아래 페이지에서 OS별 바이너리 다운로드&lt;/p&gt;

    &lt;p&gt;https://github.com/softlayer/terraform-provider-softlayer/releases&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아래와 같이 플러그인 경로 설정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # vi ~/.terraformrc
  providers {
      softlayer = &quot;/path/to/bin/terraform-provider-softlayer&quot;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;softlayer-포탈에서-ssh-key-생성&quot;&gt;Softlayer 포탈에서 ssh key 생성&lt;/h3&gt;

&lt;p&gt;Terraform을 이용하여 VM을 생성할 때 사용할 ssh key를 설정하는 방법입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;디바이스 &amp;gt; 관리 &amp;gt; SSH 키 선택 &amp;gt; 추가 탭 클릭&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;퍼블릭 키 및 라벨 입력 후 추가 버튼 클릭(이 페이지에서는 ssh key 이름을 sl_key로 가정)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Terraform &lt;code class=&quot;highlighter-rouge&quot;&gt;main.tf&lt;/code&gt;에 위 키를 정의해서 VM 생성시 활용합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  data &quot;softlayer_ssh_key&quot; &quot;public_key&quot; {
      label = &quot;sl_key&quot;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자원-정의&quot;&gt;자원 정의&lt;/h2&gt;

&lt;p&gt;디렉토리를 생성하고 생성할 자원에 대한 정의를 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;자원 정의&lt;/p&gt;

    &lt;p&gt;계정, ssh key, VM 등의 자원에 대해 정의합니다.&lt;/p&gt;

    &lt;p&gt;자주 사용하는 값들은 변수화 해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;vars.tf&lt;/code&gt;에 정의합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ vi main.tf

  //계정 정보
  provider &quot;softlayer&quot; {
    username = &quot;${var.username}&quot;
    api_key  = &quot;${var.api_key}&quot;
  }

  //VM에서 사용할 ssh key
  data &quot;softlayer_ssh_key&quot; &quot;public_key&quot; {
      label = &quot;sl_key&quot;
  }

  //VM 정의
  resource &quot;softlayer_virtual_guest&quot; &quot;sample_vm&quot; {
    count                = &quot;${var.sample_vm_count}&quot;                           //VM 개수
    os_reference_code    = &quot;${var.os}&quot;                                        //OS 타입
    public_vlan_id       = &quot;${var.public_vlan_id}&quot;                            //Public VLAN ID
    private_vlan_id      = &quot;${var.private_vlan_id}&quot;                           //Private VLAN ID
    domain               = &quot;${var.domain}&quot;                                    //VM의 도메인 명
    dedicated_acct_host_only = &quot;${var.dedicated_host}&quot;                        //Dedicated VM 생성 여부
    hostname             = &quot;${var.sample_vm_hostname}-0${count.index+1}&quot;      //VM의 호스트 명
    ssh_key_ids          = [&quot;${data.softlayer_ssh_key.public_key.id}&quot;]        //VM에서 사용할 ssh key
    datacenter           = &quot;${var.datacenter}&quot;                                //데이터센터 명
    disks                = [100,250]                                          //디스크 크기. SAN 타입[Primary Disk, Second Disk, ...]
    local_disk           = &quot;${var.local_disk}&quot;                                //로컬 디스크 사용여부
    hourly_billing       = &quot;${var.hourly_billing}&quot;                            //시간 단위 과금 사용여부
    private_network_only = &quot;${var.private_network_only}&quot;                      //VM 생성 시 사설 네트워크만 사용할지 여부. true일 경우 public_vlan_id 주석 처리 필요
    network_speed        = 1000                                               //VM 네트워크 속도. Shared VM 타입은 100Mbps가 최대
    cores                = 2                                                  //VM CPU Core 수
    memory               = 4096                                               //VM Memory 수
    notes                = &quot;${var.notes}&quot;                                     //VM에 대한 태크 명
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;환경 변수 정의&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main.tf&lt;/code&gt;에서 사용하는 환경 변수를 정의합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ vi vars.tf

  variable username {}        //환경변수로 입력받기 위해 템플릿만 선언

  variable api_key {}         //환경변수로 입력받기 위해 템플릿만 선언

  variable datacenter {
      default = &quot;seo01&quot;
  }

  variable domain {
      default = &quot;example.com&quot;
  }

  variable dedicated_host {
      default = &quot;false&quot;
  }

  variable os {
      default = &quot;CENTOS_7_64&quot;
  }

  variable hourly_billing {
      default = &quot;true&quot;
  }

  variable private_network_only {
      default = &quot;false&quot;
  }

  variable local_disk {
      default = &quot;false&quot;
  }

  variable public_vlan_id {
      default = xxx
  }

  variable private_vlan_id {
      default = xxx
  }

  variable sample_vm_hostname {
      default = &quot;sample&quot;
  }

  variable sample_vm_count {
      default = 1
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ibm-account-정보-export&quot;&gt;IBM Account 정보 export&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export IBM_ACCOUNT=xxx
export API_KEY=xxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;초기화&quot;&gt;초기화&lt;/h2&gt;

&lt;p&gt;아래 명령 실행해 초기화&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;terraform init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;자원-생성&quot;&gt;자원 생성&lt;/h2&gt;

&lt;p&gt;아래 명령 실행해 자원 생성&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;terraform apply -var &quot;username=$IBM_ACCOUNT&quot; -var &quot;api_key=$API_KEY&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;자원-삭제&quot;&gt;자원 삭제&lt;/h2&gt;

&lt;p&gt;아래 명령 실행해 자원 삭제&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;terraform destroy -var &quot;username=$IBM_ACCOUNT&quot; -var &quot;api_key=$API_KEY&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">Terraform은 인프라를 코드로 관리할 수 있도록 지원하는 오픈소스 프로젝트입니다.</summary></entry><entry><title type="html">Cronjob 사용하기</title><link href="http://localhost:4000/blog/kubernetes/2018/06/25/how-to-use-cronjob.html" rel="alternate" type="text/html" title="Cronjob 사용하기" /><published>2018-06-25T00:00:00+09:00</published><updated>2018-06-25T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/06/25/how-to-use-cronjob</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/06/25/how-to-use-cronjob.html">&lt;p&gt;이 페이지는 Kubernetes 상에서 CronJob을 사용하는 방법에 대해 설명합니다.&lt;/p&gt;

&lt;p&gt;Unix 계열의 서버 환경에서 &lt;a href=&quot;https://ko.wikipedia.org/wiki/Cron&quot;&gt;Cron&lt;/a&gt;을 사용해 정기적인 배치 작업을 수행하는데 활용합니다.&lt;/p&gt;

&lt;p&gt;하지만 Kubernetes 환경에서는 서버(Pod)가 언제든지 삭제되고 다시 생성 될 수 있습니다.
이 경우 설정한 Cron 설정도 초기화됩니다.&lt;/p&gt;

&lt;p&gt;Kubernetes 상에서는 CronJob을 활용하여 정기적인 배치 작업에 활용할 수 있습니다.
CronJob은 실행 시점에만 Pod를 생성해 자원을 사용하므로 매우 효율적입니다.&lt;/p&gt;

&lt;h2 id=&quot;cronjob-배포하기&quot;&gt;CronJob 배포하기&lt;/h2&gt;

&lt;p&gt;샘플 CronJob을 Kubernetes 클러스터에 배포합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi cronjob.yaml
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: sample-cron
spec:
  schedule: '*/35 * * * *'
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: busybox
            image: busybox
            imagePullPolicy: IfNotPresent
            args:
            - /bin/sh
            - -c
            - date; echo &quot;CronJob has been excuted successfully.&quot;
          restartPolicy: OnFailure

$ kubectl apply -f cronjob.yaml
cronjob &quot;sample-cron&quot; created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CronJob에서는 Job을 생성하기 위한 jobTemplate spec 정의가 필요합니다.
또한 Job에는 Pod를 생성하기 위한 Pod spec 정의가 필요합니다.&lt;/p&gt;

&lt;p&gt;CronJob에서는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cron#Overview&quot;&gt;Unix standard crontab format&lt;/a&gt;으로 schedule을 정의합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;첫 번째 값은 분을 의미합니다.(0~59 사이)&lt;/li&gt;
  &lt;li&gt;두 번째 값은 시간을 의미합니다.(0~23 사이)&lt;/li&gt;
  &lt;li&gt;세 번째 값은 일을 의미합니다.(1~31 사이)&lt;/li&gt;
  &lt;li&gt;네 번째 값은 월을 의미합니다.(1~12 사이)&lt;/li&gt;
  &lt;li&gt;다섯 번째 값은 주를 의미합니다.(0~6 사이)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스케줄에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; wildcard를 사용할 수 있습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;*/35 * * * *&lt;/code&gt;는 매달, 매일 35분에 반복적으로 CronJob을 실행한다는 의미입니다.&lt;/p&gt;

&lt;h2 id=&quot;cronjob-확인하기&quot;&gt;CronJob 확인하기&lt;/h2&gt;

&lt;p&gt;아래 명령어를 실행하여 등록한 CronJob을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get cronjob
NAME          SCHEDULE       SUSPEND   ACTIVE    LAST SCHEDULE   AGE
sample-cron   */35 * * * *   False     0         &amp;lt;none&amp;gt;          4s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Schedule에 설정한 시간이 되면 아래와 같이 Job이 실행됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get jobs
NAME                     DESIRED   SUCCESSFUL   AGE
sample-cron-1529850900   1         1            24s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Job이 실행되면 Pod를 생성하고 정해진 작업을 수행합니다.
Job이 생성한 Pod는 아래와 같이 조회할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get po -a
NAME                           READY     STATUS      RESTARTS   AGE
sample-cron-1529850900-5hfzn   0/1       Completed   0          41s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod의 로그를 조회해 수행한 작업 내용을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl logs -f sample-cron-1529850900-5hfzn
Sun Jun 24 14:35:06 UTC 2018
CronJob has been excuted successfully.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Kubernetes 상에서 CronJob을 사용하는 방법에 대해 설명합니다.</summary></entry><entry><title type="html">Pod에 타임존 설정하기</title><link href="http://localhost:4000/blog/kubernetes/2018/06/24/setup-timezone-to-pod.html" rel="alternate" type="text/html" title="Pod에 타임존 설정하기" /><published>2018-06-24T00:00:00+09:00</published><updated>2018-06-24T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/06/24/setup-timezone-to-pod</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/06/24/setup-timezone-to-pod.html">&lt;p&gt;이 페이지는 Pod에 타임존을 설정하는 방법에 대해 설명합니다.&lt;/p&gt;

&lt;p&gt;클라우드 환경에서는 기본 타임존이 UTC로 설정되어 있는 경우가 많습니다.&lt;/p&gt;

&lt;p&gt;Kubernetes 클러스터의 경우에도 호스트의 타임존이 UTC로 설정되어 있으면 Pod의 타임존 또한 UTC로 설정됩니다.&lt;/p&gt;

&lt;p&gt;아래의 가이드를 참고하여 특정 Pod의 타임존을 변경할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;준비하기&quot;&gt;준비하기&lt;/h2&gt;

&lt;p&gt;먼저 테스트를 위한 샘플앱을 Kubernetes 클러스터에 배포합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl run nginx --image=nginx --port=80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;현재-타임존-확인&quot;&gt;현재 타임존 확인&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하여 현재 Pod의 타임존을 확인합니다.&lt;/p&gt;

&lt;p&gt;현재 타임존이 UTC로 설정되어 있는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get po
NAME                     READY     STATUS    RESTARTS   AGE
nginx-7587c6fdb6-wl962   1/1       Running   0          11s

$ kubectl exec nginx-7587c6fdb6-wl962 -it -- date
Sun Jun 24 07:30:17 UTC 2018
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod의 로그 또한 UTC 시간을 기준으로 조회되는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl logs -f nginx-7587c6fdb6-wl962
127.0.0.1 - - [24/Jun/2018:07:30:34 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36&quot; &quot;-&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;타임존-변경&quot;&gt;타임존 변경&lt;/h2&gt;

&lt;p&gt;아래와 같이 타임존을 변경하기 위해 deployment 리소스를 편집합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get deploy
NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx     1         1         1            1           2m

$ kubectl edit deploy nginx
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx
spec:
  ...
  template:
    ...
    spec:
      containers:
      ...
        volumeMounts:
        - mountPath: /etc/localtime
          name: timezone-config
      volumes:
      - hostPath:
          path: /usr/share/zoneinfo/Asia/Seoul
        name: timezone-config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;변경된-타임존-확인&quot;&gt;변경된 타임존 확인&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하여 변경된 Pod의 타임존을 확인합니다.&lt;/p&gt;

&lt;p&gt;타임존이 KST로 변경된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get po
NAME                    READY     STATUS    RESTARTS   AGE
nginx-7c8fc894b-m6cw9   1/1       Running   0          1m

$ kubectl exec nginx-7c8fc894b-m6cw9 -it -- date
Sun Jun 24 16:35:31 KST 2018
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod의 로그 또한 KST 시간을 기준으로 조회되는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl logs -f nginx-7c8fc894b-m6cw9
127.0.0.1 - - [24/Jun/2018:16:37:04 +0900] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36&quot; &quot;-&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Pod에 타임존을 설정하는 방법에 대해 설명합니다.</summary></entry><entry><title type="html">Spinnaker 설치하기</title><link href="http://localhost:4000/blog/spinnaker/2018/06/03/installing-spinnaker.html" rel="alternate" type="text/html" title="Spinnaker 설치하기" /><published>2018-06-03T00:00:00+09:00</published><updated>2018-06-03T00:00:00+09:00</updated><id>http://localhost:4000/blog/spinnaker/2018/06/03/installing-spinnaker</id><content type="html" xml:base="http://localhost:4000/blog/spinnaker/2018/06/03/installing-spinnaker.html">&lt;p&gt;이 페이지는 Spinnaker를 설치하는 방법에 대해 설명합니다.
자세한 내용은 &lt;a href=&quot;https://www.spinnaker.io/setup/&quot;&gt;Set up Spinnaker&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;halyard-설치하기&quot;&gt;Halyard 설치하기&lt;/h2&gt;

&lt;p&gt;Halyard는 배포 구성 작성 및 유효성 검사, Spinnaker의 마이크로 서비스 배포 및 업데이트를 포함하여 Spinnaker 배포의 수명주기를 관리합니다.
운영가능한 Spinnaker를 설치 및 업데이트하기 위해 Halyard가 필요합니다. Halyard없이 Spinnaker를 설치할 수는 있지만 권장하지 않습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;&gt;Docker CE&lt;/a&gt;를 설치&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로컬 환경에 Halyard 설정 디렉토리를 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ mkdir ~/.hal
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Halyard Docker 컨테이너 실행&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 Halyard Docker 컨테이너를 생성합니다. 이 명령은 Halyard 설정 및 kubeconfig 디렉토리를 마운트합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ docker run -p 8084:8084 -p 9000:9000 \
     --name halyard --rm \
     -v ~/.hal:/home/spinnaker/.hal \
     -v ~/.kube:/home/spinnaker/.kube \
     -it \
     gcr.io/spinnaker-marketplace/halyard:stable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Halyard에 접속&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 Halyard Docker 컨테이너에 접속합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ docker exec -it halyard bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자동 완성&lt;/p&gt;

    &lt;p&gt;아래 명령을 실행하여 자동완성을 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ source &amp;lt;(hal --print-bash-completion)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hal&lt;/code&gt; 명령어에 대한 자세한 내용은 &lt;a href=&quot;https://www.spinnaker.io/reference/halyard/commands&quot;&gt;Halyard command Reference&lt;/a&gt;를 참고하세요.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cloud-공급자-선택하기&quot;&gt;Cloud 공급자 선택하기&lt;/h2&gt;

&lt;p&gt;Spinnaker를 통해 애플리케이션을 배포할 Cloud 공급자를 선택합니다.&lt;/p&gt;

&lt;p&gt;아래와 같은 Cloud 공급자를 지원합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;App Engine&lt;/li&gt;
  &lt;li&gt;Amazon Web Services&lt;/li&gt;
  &lt;li&gt;Amazon Web Services - ECS&lt;/li&gt;
  &lt;li&gt;Azure&lt;/li&gt;
  &lt;li&gt;DC/OS&lt;/li&gt;
  &lt;li&gt;Google Compute Engine&lt;/li&gt;
  &lt;li&gt;Kubernetes (legacy)&lt;/li&gt;
  &lt;li&gt;Kubernetes V2 (manifest based)&lt;/li&gt;
  &lt;li&gt;Openstack&lt;/li&gt;
  &lt;li&gt;Oracle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 페이지에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Kubernetes V2&lt;/code&gt;를 선택해 Spinnaker를 설치해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;kubernetes-v2-공급자&quot;&gt;Kubernetes V2 공급자&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Kubernetes V2&lt;/code&gt;는 Spinnaker 1.6의 알파 기능을 포함하고 있으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Kubernetes (legacy)&lt;/code&gt;에 비해 불안정할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;계정&quot;&gt;계정&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Kubernetes V2&lt;/code&gt;의 경우 Spinnaker 계정이 Kubernetes Cluster에 대해 인증 할 수 있는 자격 증명에 매핑됩니다. V1 공급자와 달리 V2에서는 Docker Registry Accounts가 필요하지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h4&gt;

&lt;p&gt;아래 두 가지 사항이 필요합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;kubeconfig&lt;/p&gt;

    &lt;p&gt;kubeconfig를 사용하면 Spinnaker가 관리 할 것으로 예상되는 모든 리소스에 대한 읽기/쓰기 권한을 가질 수 있습니다. Kubernetes 클러스터 관리자에게 요청할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;이 페이지에서는 Docker 컨테이너에서 Halyard를 실행시 로컬환경의 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.kube&lt;/code&gt; 폴더를 Docker 컨테이너의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/home/spinnaker/.kube&lt;/code&gt;에 mount 했습니다.
  로컬환경의 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.kube&lt;/code&gt; 폴더 하위에 kubeconfig를 생성하면됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kubectl&lt;/p&gt;

    &lt;p&gt;Spinnaker는 kubectl을 사용하여 모든 API 액세스를 관리합니다. Spinnaker와 함께 설치됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;계정-추가&quot;&gt;계정 추가&lt;/h4&gt;

&lt;p&gt;이제 계정을 추가합니다. 먼저, 공급자가 활성화 되어 있는지 확인합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal config provider kubernetes enable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 계정을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal config provider kubernetes account add my-k8s-v2-account \
    --provider-version v2 \
    --context $(kubectl config current-context)

$ hal config features edit --artifacts true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;추가-설정&quot;&gt;추가 설정&lt;/h4&gt;

&lt;p&gt;추가 설정에 대한 내용은 &lt;a href=&quot;https://www.spinnaker.io/reference/halyard/commands#hal-config-provider-kubernetes-account-add&quot;&gt;Halyard Reference&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;설치환경-선택하기&quot;&gt;설치환경 선택하기&lt;/h2&gt;

&lt;p&gt;Halyard가 Spinnaker를 어디에 설치할지 선택합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분산 설치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Halyard가 Spinnaker’s 마이크로서비스를 분산 설치합니다. 운영환경으로 설치 시 권장합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로컬 설치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하나의 머신에 설치됩니다. 소규모 배포에 적합합니다.
 of Debian packages Spinnaker is deployed on a single machine. This is good for smaller deployments.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;github에서 설치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spinnaker 프로젝트에 기여하는 개발자에게 적합합니다.&lt;/p&gt;

&lt;p&gt;이 페이지에서는 분산 설치 방식으로 진행해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;분산-설치&quot;&gt;분산 설치&lt;/h3&gt;

&lt;p&gt;분산 설치는 리소스가 많은 개발 조직 및 Spinnaker 업데이트 중 다운 타임을 없어야 하는 경우에 적합합니다.&lt;/p&gt;

&lt;p&gt;Spinnaker는 원격 클라우드에 배포되며 각 마이크로 서비스는 독립적으로 배포됩니다. Halyard는 Spinnaker 마이크로 서비스를 무중단으로 업데이트합니다.&lt;/p&gt;

&lt;p&gt;Spinnaker를 설치하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 cores&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;8GB of RAM&lt;/code&gt;을 권장합니다.&lt;/p&gt;

&lt;p&gt;아래 명령을 실행합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;$ACCOUNT&lt;/code&gt;는 공급자 선택에서 설정한 생성한 계정입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal config deploy edit --type distributed --account-name $ACCOUNT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;스토리지-선택하기&quot;&gt;스토리지 선택하기&lt;/h2&gt;

&lt;p&gt;Spinnaker에는 애플리케이션 설정 및 파이프 라인 설정을 유지하기 위해 외부 저장소가 필요합니다.&lt;/p&gt;

&lt;p&gt;Spinnaker는 아래와 같은 스토리지를 지원합니다. 어떤 옵션을 선택해도 Cloud 공급자 선택에 영향을 미치지 않습니다.
예를 들어, Google Cloud Storage를 저장소 소스로 사용할 수 있지만 여전히 Microsoft Azure에 배포 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Azure Storage&lt;/li&gt;
  &lt;li&gt;Google Cloud Storage&lt;/li&gt;
  &lt;li&gt;Minio&lt;/li&gt;
  &lt;li&gt;Redis&lt;/li&gt;
  &lt;li&gt;S3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고: Redis는 운영환경에서는 권장하지 않습니다.&lt;/p&gt;

&lt;p&gt;이 페이지에서는 Minio를 사용해서 Self 호스팅하는 S3와 연동하는 방식으로 진행해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;minio&quot;&gt;Minio&lt;/h3&gt;

&lt;p&gt;Minio의 데이터를 잃으면 Spinnaker 애플리케이션 메타 데이터 및 파이프 라인이 모두 손실됩니다.&lt;/p&gt;

&lt;p&gt;Minio는 Self 호스팅 할 수있는 S3 호환 Object Storage입니다. Spinnaker 데이터를 호스팅하기 위해 클라우드 제공 업체에 의존하고 싶지 않을 때 권장되는 영구 저장소 솔루션입니다.&lt;/p&gt;

&lt;h4 id=&quot;사전-준비-1&quot;&gt;사전 준비&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.minio.io/&quot;&gt;Minio 홈페이지&lt;/a&gt;에 있는 가이드를 따라 Minio를 설치합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;S3에 Bucket을 생성합니다. 이 Bucket 명을 아래 스토리지 설정에서 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;스토리지-설정&quot;&gt;스토리지 설정&lt;/h4&gt;

&lt;p&gt;Minio가 버전 객체를 지원하지 않으므로 Spinnaker에서 버전 객체를 비활성화합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi ~/.hal/$DEPLOYMENT/profiles/front50-local.yml:
spinnaker.s3.versioning: false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;$DEPLOYMENT 일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;아래 명령을 실행해 S3를 저장소 유형으로 선택합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export ENDPOINT=S3_ENDPOINT
$ export MINIO_ACCESS_KEY=S3_ACCESS_KEY_ID

$ hal config storage s3 edit --endpoint $ENDPOINT \
    --access-key-id $MINIO_ACCESS_KEY \
    --bucket BUCKET_NAME
    --secret-access-key
  Your AWS Secret Key.:

$ hal config storage edit --type s3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;spinnaker-설치&quot;&gt;Spinnaker 설치&lt;/h2&gt;

&lt;p&gt;설치 가능한 버전을 조회합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal version list
  + Get current deployment
    Success
  + Get Spinnaker version
    Success
  + Get released versions
    Success
  + You are on version &quot;&quot;, and the following are available:
   - 1.5.4 (Atypical):
     Changelog: https://gist.github.com/spinnaker-release/6b9fd632caeaefd32246074998af8498
     Published: Wed Jan 10 18:46:49 UTC 2018
     (Requires Halyard &amp;gt;= 0.40.0)
   - 1.6.1 (GLOW):
     Changelog: https://gist.github.com/spinnaker-release/f1cd6232151b70492ebdcbb557a209fc
     Published: Wed Apr 04 19:20:54 UTC 2018
     (Requires Halyard &amp;gt;= 0.41.0)
   - 1.7.6 (Ozark):
     Changelog: https://gist.github.com/spinnaker-release/5d3af465f07eaca64f4383167877897d
     Published: Tue May 29 16:26:20 UTC 2018
     (Requires Halyard &amp;gt;= 1.0.0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원하는 버전을 선택합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal config version edit --version $VERSION
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ingress에서 사용할 도메인을 입력합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal config security ui edit --override-base-url http://spinnaker.zcp-dev.jp-tok.containers.mybluemix.net
$ hal config security api edit --override-base-url http://spinnaker-api.zcp-dev.jp-tok.containers.mybluemix.net
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 Spinnaker를 배포합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hal deploy apply
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;spinnaker-expose&quot;&gt;Spinnaker expose&lt;/h2&gt;

&lt;p&gt;Spinnaker에 접속하기 위해서 ingress를 통해 서비스를 노출시켜보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;ingress.yaml&lt;/code&gt;을 작성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi ingress.yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: spinnaker
spec:
  rules:
  - host: spinnaker.example.com
    http:
      paths:
      - backend:
          serviceName: spin-deck
          servicePort: 9000
  - host: spinnaker-api.example.com
    http:
      paths:
      - backend:
          serviceName: spin-gate
          servicePort: 8084
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 명령어를 통해 ingress를 배포합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl apply -f ingress.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;spinnaker.example.com&lt;/code&gt;에 접속해 Spinnaker 대시보드를 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;trouble-shooting&quot;&gt;Trouble Shooting&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Service: Amazon S3; Status Code: 400; Error Code: InvalidLocationConstraint&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;아래와 같은 에러 발생 시 S3에서 bucket을 수동으로 생성 후 halyard config에서 새로 생성한 bucket명으로 수정한 후 다시 배포해봅니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.netflix.spinnaker.front50.model.S3StorageService]: Factory method 's3StorageService' threw exception; nested exception is com.amazonaws.services.s3.model.AmazonS3Exception: Container storage location with specified provisioning code not available (Service: Amazon S3; Status Code: 400; Error Code: InvalidLocationConstraint; Request ID: d08c26ee-34ba-4e62-83bc-5d9a26b23947; S3 Extended Request ID: null), S3 Extended Request ID: null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ vi ~/.hal/config
  - name: default
    persistentStorage:
      s3:
        bucket: example-bucket

  $ hal deploy apply      
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Spinnaker를 설치하는 방법에 대해 설명합니다. 자세한 내용은 Set up Spinnaker을 참고하세요.</summary></entry><entry><title type="html">Cannot find module ‘webpack/lib/node/NodeTemplatePlugin’</title><link href="http://localhost:4000/blog/angular/2018/05/29/angular-cannot-find-module.html" rel="alternate" type="text/html" title="Cannot find module 'webpack/lib/node/NodeTemplatePlugin'" /><published>2018-05-29T00:00:00+09:00</published><updated>2018-05-29T00:00:00+09:00</updated><id>http://localhost:4000/blog/angular/2018/05/29/angular-cannot-find-module</id><content type="html" xml:base="http://localhost:4000/blog/angular/2018/05/29/angular-cannot-find-module.html">&lt;p&gt;Angular build 시 아래와 같은 에러가 나는 경우가 있습니다.
npm5에 도입된 &lt;code class=&quot;highlighter-rouge&quot;&gt;package-lock.json&lt;/code&gt;을 삭제하지 않고 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt;을 한 경우 발생합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn run xxx
yarn run v1.7.0
$ ng build --prod --aot --progress=false --output-path rootfs/dist
Cannot find module 'webpack/lib/node/NodeTemplatePlugin'
Error: Cannot find module 'webpack/lib/node/NodeTemplatePlugin'
    at Function.Module._resolveFilename (module.js:547:15)
    at Function.Module._load (module.js:474:25)
    at Module.require (module.js:596:17)
    at require (internal/module.js:11:18)
    at Object.&amp;lt;anonymous&amp;gt; (/Users/sangjunyun/git/zcp-catalog-ui/node_modules/html-webpack-plugin/lib/compiler.js:11:26)
    at Module._compile (module.js:652:30)
    at Object.Module._extensions..js (module.js:663:10)
    at Module.load (module.js:565:32)
    at tryModuleLoad (module.js:505:12)
    at Function.Module._load (module.js:497:3)
    at Module.require (module.js:596:17)
    at require (internal/module.js:11:18)
    at Object.&amp;lt;anonymous&amp;gt; (/Users/sangjunyun/git/zcp-catalog-ui/node_modules/html-webpack-plugin/index.js:7:21)
    at Module._compile (module.js:652:30)
    at Object.Module._extensions..js (module.js:663:10)
    at Module.load (module.js:565:32)
error Command failed with exit code 1.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
make: *** [compile-aot] Error 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 명령어를 실행해 &lt;code class=&quot;highlighter-rouge&quot;&gt;node_modules&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;dist&lt;/code&gt; 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;package-lock.json&lt;/code&gt;을 삭제합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rm -rf node_modules dist package-lock.json
$ npm cache clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt; 명령을 실행해 node_modules을 다시 설치합니다.
이후 Angular build를 다시하면 정상적으로 실행됩니다.&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">Angular build 시 아래와 같은 에러가 나는 경우가 있습니다. npm5에 도입된 package-lock.json을 삭제하지 않고 npm install을 한 경우 발생합니다.</summary></entry><entry><title type="html">Helm 설치하기</title><link href="http://localhost:4000/blog/helm/2018/05/27/installing-helm.html" rel="alternate" type="text/html" title="Helm 설치하기" /><published>2018-05-27T00:00:00+09:00</published><updated>2018-05-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/27/installing-helm</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/27/installing-helm.html">&lt;p&gt;이 페이지는 Helm을 설치하는 방법에 대해 설명합니다.
자세한 내용은 &lt;a href=&quot;https://docs.helm.sh/using_helm/#installing-helm&quot;&gt;Installing Helm&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;helm-client-바이너리-다운로드&quot;&gt;Helm client 바이너리 다운로드&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/helm/releases&quot;&gt;Helm release&lt;/a&gt; 바이너리를 다운로드합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;바이너리 압축 해제합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  tar -zxvf helm-vX.X.X-OS_NAME-amd64.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Helm 바이너리를 원하는 위치로 이동시킵니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mv OS_NAME-amd64/helm /usr/local/bin/helm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tiller-설치&quot;&gt;Tiller 설치&lt;/h2&gt;

&lt;p&gt;Helm의 서버 부분 인 Tiller는 일반적으로 Kubernetes 클러스터 내부에서 실행됩니다. 그러나 개발을 위해 로컬로 실행될 수도 있고 원격 Kubernetes 클러스터와 통신하도록 구성 될 수도 있습니다.&lt;/p&gt;

&lt;p&gt;Tiller를 클러스터에 설치하는 가장 쉬운 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;helm init&lt;/code&gt;를 실행하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;helm init&lt;/code&gt; 실행 후 Tiller가 running 상태가 될 때까지 대기합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pods --namespace kube-system |grep tiller
tiller-deploy-7ccf99cd64-pd7c2        1/1       Running   0          3d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Helm client와 server의 버전을 확인합니다.
Server의 버전이 Client의 버전과 같거나 높아야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm version
Client: &amp;amp;version.Version{SemVer:&quot;v2.9.0&quot;, GitCommit:&quot;xxx&quot;, GitTreeState:&quot;clean&quot;}
Server: &amp;amp;version.Version{SemVer:&quot;v2.9.1&quot;, GitCommit:&quot;xxx&quot;, GitTreeState:&quot;clean&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Server를 제외한 Client만 설치하고 싶은 경우 아래와 같이 실행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm init --client-only
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 Helm을 활용해 chart를 Kubernetes에 배포할 수 있습니다.&lt;/p&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Helm을 설치하는 방법에 대해 설명합니다. 자세한 내용은 Installing Helm을 참고하세요.</summary></entry><entry><title type="html">Ingress TLS Secret 생성하기</title><link href="http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html" rel="alternate" type="text/html" title="Ingress TLS Secret 생성하기" /><published>2018-05-27T00:00:00+09:00</published><updated>2018-05-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret</id><content type="html" xml:base="http://localhost:4000/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html">&lt;p&gt;이 페이지에서는 Ingress에 TLS를 적용하기 위한 Secret을 생성하는 방법을 가이드합니다.&lt;/p&gt;

&lt;h2 id=&quot;tls-secret-생성&quot;&gt;TLS Secret 생성&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하여 TLS Secret을 생성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create secret tls example-tls --cert example.crt --key example.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 아래와 같이 yaml 파일 형태로 생성할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi secret.yaml
apiVersion: v1
data:
  tls.crt: base64 encoded cert
  tls.key: base64 encoded key
kind: Secret
metadata:
  name: example-tls
type: Opaque

$ kubectl create -f secret.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tls-secret을-ingress에-적용&quot;&gt;TLS Secret을 Ingress에 적용&lt;/h2&gt;

&lt;p&gt;아래와 같이 Ingress의 secretName 속성에 example-tls을 적용합니다.
이제 Ingress를 배포한 후 host로 접속하면 TLS가 적용된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: example-ingress
spec:
  rules:
  - host: example.com
    http:
      paths:
      - backend:
          serviceName: example
          servicePort: 80
  tls:
  - hosts:
    - example.com
    secretName: example-tls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지에서는 Ingress에 TLS를 적용하기 위한 Secret을 생성하는 방법을 가이드합니다.</summary></entry><entry><title type="html">Helm chart를 사용하여 Jenkins를 컨테이너로 배포하기</title><link href="http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart.html" rel="alternate" type="text/html" title="Helm chart를 사용하여 Jenkins를 컨테이너로 배포하기" /><published>2018-05-26T00:00:00+09:00</published><updated>2018-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/26/jenkins-helm-chart.html">&lt;p&gt;이 페이지는 Helm chart를 사용하여 Jenkins를 컨테이너로 배포하는 방법에 대해 설명합니다.
자세한 내용은 &lt;a href=&quot;https://github.com/kubernetes/charts/tree/master/stable/jenkins&quot;&gt;Jenkins Helm Chart&lt;/a&gt;에서 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;준비-사항&quot;&gt;준비 사항&lt;/h2&gt;

&lt;p&gt;아래 가이드를 참고하여 Helm Client를 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/helm/2018/05/27/installing-helm.html&quot;&gt;Helm 설치하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;빠른-설치&quot;&gt;빠른 설치&lt;/h2&gt;

&lt;p&gt;아래 명령을 실행하면 Kubernetes 클러스터에 Jenkins가 배포됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm install --name jenkins stable/jenkins
NAME:   jenkins
...
NOTES:
1. Get your 'admin' user password by running:
  printf $(kubectl get secret --namespace default jenkins -o jsonpath=&quot;{.data.jenkins-admin-password}&quot; | base64 --decode);echo
2. Get the Jenkins URL to visit by running these commands in the same shell:
  NOTE: It may take a few minutes for the LoadBalancer IP to be available.
        You can watch the status of by running 'kubectl get svc --namespace default -w jenkins'
  ...
  echo http://$SERVICE_IP:8080/login

3. Login with the password from step 1 and the username: admin

For more information on running Jenkins on Kubernetes, visit:
https://cloud.google.com/solutions/jenkins-on-container-engine
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정상적으로 설치가 완료되었다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOTES&lt;/code&gt;의 가이드를 참고하여 Jenkins 대시보드에 접속할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;참고 : 기본 설정을 사용하므로 클러스터 환경에 따라 설치 중 에러가 발생할 수 있습니다.
이런 경우 아래 가이드를 따라 사용자 설정 방식으로 배포 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사용자-정의-설치&quot;&gt;사용자 정의 설치&lt;/h2&gt;

&lt;h3 id=&quot;설정&quot;&gt;설정&lt;/h3&gt;

&lt;p&gt;사용자의 Kubernetes 클러스터 환경에 맞게 Jenkins의 서비스, 스토리지 등의 설정을 변경할 수 있습니다.
아래 가이드를 참고하여 사용자의 환경에 맞도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;values.yaml&lt;/code&gt; 파일을 작성합니다.&lt;/p&gt;

&lt;h4 id=&quot;jenkins-admin-사용자-암호&quot;&gt;Jenkins admin 사용자 암호&lt;/h4&gt;

&lt;p&gt;Jenkins admin의 초기 사용자 암호입니다. 기본 설정은 랜덤한 패스워드입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  AdminPassword: ExamplePassword
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;서비스&quot;&gt;서비스&lt;/h4&gt;

&lt;p&gt;서비스는 Jenkins 대시보드를 접속을 어떤 방식으로 제공할지에 대한 설정입니다.
기본 설정은 LoadBalancer 방식입니다. 사용자의 클러스터의 환경에 동적으로 제공되는 LoadBalancer 서비스가 있다면 사용 가능합니다.
LoadBalancer 서비스가 없다면 아래와 같이 NodePort 또는 Ingress 방식을 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;NodePort&lt;/p&gt;

    &lt;p&gt;NodePort를 사용하면 Worker Node의 Public IP를 통하여 서비스에 접근 할 수 있습니다.
ServiceType을 NodePort로 설정하고 NodePort에 30000~32767사이의 포트 번호를 입력합니다.
포트 번호를 입력하지 않으면 30000~32767사이의 숫자에서 랜덤하게 선택됩니다.&lt;/p&gt;

    &lt;p&gt;접속 URI 예시 : http://WORKER_NODE_PUBLIC_IP:3xxxx&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  ServiceType: NodePort
  NodePort: 30000-32767
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ingress&lt;/p&gt;

    &lt;p&gt;Ingress를 사용하면 Ingress Controller의 Public IP를 통하여 서비스에 접근 할 수 있습니다.
ServiceType을 ClusterIP로 설정하고 HostName에 원하는 도메인을 입력합니다.(이 때 도메인이 Ingress Controller의 Public IP와 연결되어야 합니다.)
SSL 접속을 지원하려면 TLS 설정의 secretName과 host명을 입력합니다.&lt;/p&gt;

    &lt;p&gt;Ingress TLS Secret 생성 방법은 아래 가이드를 참고하세요.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/kubernetes/2018/05/27/how-to-create-ingress-secret.html&quot;&gt;Ingress TLS Secret 생성하기&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Master:
  ServiceType: ClusterIP
  HostName: jenkins.example.com
  Ingress:
    TLS:
      - secretName: example-tls
        hosts:
          - jenkins.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;스토리지&quot;&gt;스토리지&lt;/h4&gt;

&lt;p&gt;Jenkins는 영구적으로 저장해야 하는 데이터를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/jenkins_home&lt;/code&gt;에 저장합니다.
이 데이터를 영구적으로 저장하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/jenkins_home&lt;/code&gt; 폴더를 PV(Persistent Volume)에 mount 해야합니다.
사용자의 Cluster에서 동적으로 PV를 생성 및 관리해주는 기능이 있다면 별도의 설정이 필요없습니다.
GKE, AWS, AKS 등의 환경에서는 Storage Class를 정의하면 PV를 생성하고 관리합니다.
또한 미리 구성된 PVC(PersistentVolumeClaim)를 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Storage Class 사용&lt;/p&gt;

    &lt;p&gt;Storage Class를 사용하여 동적으로 PV를 생성합니다.
Storage Class 명은 아래와 같이 확인할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get storageclass
NAME                       PROVISIONER         AGE
default                    ibm.io/ibmc-file    41d
ibmc-block-bronze          ibm.io/ibmc-block   3d
ibmc-file-bronze           ibm.io/ibmc-file    26d
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;원하는 Storage Class 명을 입력합니다. Storage의 크기를 원하는 값으로 설정합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Persistence:
  StorageClass: &quot;default&quot;
  Size: 8Gi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사전 구성된 PVC 사용&lt;/p&gt;

    &lt;p&gt;미리 구성된 PVC(PersistentVolumeClaim)를 사용합니다.
미리 구성된 PVC 명은 아래와 같이 확인할 수 있습니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pvc
NAME          STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS        AGE
jenkins-pvc   Bound     pvc-47aec304-5e4e-11e8-915d-82c09a00d8d2   20Gi       RWO            ibmc-block-bronze   3d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;미리 구성된 PVC 명을 입력합니다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;values.yaml&amp;gt;
Persistence:
  ExistingClaim: &quot;jenkins-pvc&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설치&quot;&gt;설치&lt;/h3&gt;

&lt;p&gt;이제 아래 명령을 실행하여 사용자 정의에 맞게 Jenkins를 설치합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ helm install --name jenkins -f values.yaml stable/jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>윤상준</name></author><summary type="html">이 페이지는 Helm chart를 사용하여 Jenkins를 컨테이너로 배포하는 방법에 대해 설명합니다. 자세한 내용은 Jenkins Helm Chart에서 참고하세요.</summary></entry><entry><title type="html">Helm chart repository 호스팅</title><link href="http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository.html" rel="alternate" type="text/html" title="Helm chart repository 호스팅" /><published>2018-05-26T00:00:00+09:00</published><updated>2018-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository</id><content type="html" xml:base="http://localhost:4000/blog/helm/2018/05/26/hosting-helm-chart-repository.html">&lt;p&gt;Helm chart를 개발한 후 외부에서 helm cli를 통해 다운로드 및 설치 하려면 Helm chart repository를 만들어야 합니다.&lt;/p&gt;

&lt;p&gt;kubernetes helm &lt;a href=&quot;https://github.com/kubernetes/helm/blob/master/docs/chart_repository.md&quot;&gt;가이드&lt;/a&gt;에서 지원하는 방식은 3가지 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Github Pages&lt;/li&gt;
  &lt;li&gt;Object Storage(GCS, AWS S3)&lt;/li&gt;
  &lt;li&gt;Ordinary Web Servers&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github-pages&quot;&gt;Github Pages&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Github에 Repository 생성 및 docs 폴더 생성&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/YunSangJun/sj-charts&quot;&gt;샘플 코드&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Chart Repository
     | ㅡ docs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Github Page 설정&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Repository -&amp;gt; Settings -&amp;gt; Github Pages&lt;/code&gt; 메뉴 클릭&lt;/p&gt;

    &lt;p&gt;Source를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/docs&lt;/code&gt; 로 지정. 지정 후 아래와 같은 site 주소 확인&lt;/p&gt;

    &lt;p&gt;https://yunsangjun.github.io/sj-charts&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm Package 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # helm create mychart
 # helm package mychart
 # mv mychart-0.1.0.tgz docs
 # helm repo index docs --url https://yunsangjun.github.io/sj-charts
 # git add --all
 # git commit -m 'init'
 # git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm repository에 추가&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # helm repo add mychart https://yunsangjun.github.io/sj-charts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>윤상준</name></author><summary type="html">Helm chart를 개발한 후 외부에서 helm cli를 통해 다운로드 및 설치 하려면 Helm chart repository를 만들어야 합니다.</summary></entry></feed>