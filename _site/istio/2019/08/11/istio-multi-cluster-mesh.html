<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/css/home.css">
  <link rel="stylesheet" href="/assets/css/category.css">
  <link rel="stylesheet" href="/assets/css/tag.css">
  <link rel="stylesheet" href="/assets/main.css"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Istio를 활용해 Multi Cluster 환경에 Service Mesh 구성하기 | 개발 노트</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Istio를 활용해 Multi Cluster 환경에 Service Mesh 구성하기" />
<meta name="author" content="sj" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Overview" />
<meta property="og:description" content="Overview" />
<link rel="canonical" href="http://localhost:4000/istio/2019/08/11/istio-multi-cluster-mesh.html" />
<meta property="og:url" content="http://localhost:4000/istio/2019/08/11/istio-multi-cluster-mesh.html" />
<meta property="og:site_name" content="개발 노트" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-11T00:00:00+09:00" />
<script type="application/ld+json">
{"description":"Overview","author":{"@type":"Person","name":"sj"},"@type":"BlogPosting","url":"http://localhost:4000/istio/2019/08/11/istio-multi-cluster-mesh.html","headline":"Istio를 활용해 Multi Cluster 환경에 Service Mesh 구성하기","dateModified":"2019-08-11T00:00:00+09:00","datePublished":"2019-08-11T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/istio/2019/08/11/istio-multi-cluster-mesh.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <meta property="article:tag" content="istio" >
  
  <meta property="article:tag" content="servicemesh" >
  
  <meta property="article:tag" content="multicluster" >
  
  <meta property="article:tag" content="kubernetes" >
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="개발 노트" /><meta name="naver-site-verification" content="33e13a38620284ab48998da35e7c8e63ec9c7319"/>
  <script data-ad-client="ca-pub-7576652482735281" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">개발 노트</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/categories">Categories</a>
            <a class="page-link" href="/tags">Tags</a>
        </div>

        <!--div class="trigger"><a class="page-link" href="/assets/images/oauth-proxy/2018-05-23-oauth-proxy.html">OAuth Proxy를 활용한 애플리케이션 인증 및 인가</a><a class="page-link" href="/categories/">Categories</a><a class="page-link" href="/tags/">Tags</a></div-->
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Istio를 활용해 Multi Cluster 환경에 Service Mesh 구성하기</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-08-11T00:00:00+09:00" itemprop="datePublished">Aug 11, 2019
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">sj</span></span></p>
      
<img src="/assets/images/tag-256.png" alt="Tags: " class="tag-img"/>
<div class="post-tags">
  
  
  <a href="/blog/tags/#istio">istio</a>,
  
  <a href="/blog/tags/#servicemesh">servicemesh</a>,
  
  <a href="/blog/tags/#multicluster">multicluster</a>,
  
  <a href="/blog/tags/#kubernetes">kubernetes</a>
  
</div>
<br/>

  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="overview">Overview</h2>

<p>Istio를 활용하여 여러개의 Kubernetes Cluster 환경에 Service Mesh를 구성할 수 있습니다.</p>

<p>인프라 및 Kubernetes Cluster 환경에 따라 3가지 구성 방법이 있습니다.</p>

<p>이 문서에서는 1번 방법을 활용하여 Service Mesh를 구성해보겠습니다.</p>

<ol>
  <li>
    <p><a href="https://istio.io/docs/setup/kubernetes/install/multicluster/shared-gateways/">Shared control plane (multi-network)</a></p>

    <p>이 방법은 여러개의 Cluster가 하나의 Istio Control Plane을 공유합니다.
 Istio Gateway를 통해 Cluster간 통신하므로 각 Cluster의 네트워크가 분리되어 있고 VPN 또는 Direct 네트워크로 연결되어 있지 않아도 됩니다.</p>

    <p><img src="/assets/images/kubernetes/istio/istio-shared-multi.svg" alt="" /></p>
  </li>
  <li>
    <p><a href="https://istio.io/docs/setup/kubernetes/install/multicluster/shared-vpn/">Shared control plane (single-network)</a></p>

    <p>1번과 마찬가지로 여러개의 Cluster가 하나의 Istio Control Plane을 공유합니다.
 별도의 Gateway가 없기 때문에 각 Cluster의 네트워크가 VPN 등을 통해 연결성이 있어야합니다.
 각 Cluster의 네트워크에서 Pod와 Service의 CIDR은 중복되서는 안되고 서로간의 라우팅이 가능해야합니다.</p>

    <p><img src="/assets/images/kubernetes/istio/istio-shared-single.svg" alt="" /></p>
  </li>
  <li>
    <p><a href="https://istio.io/docs/setup/kubernetes/install/multicluster/gateways/">Multiple control planes</a></p>

    <p>1번과 마찬가지로 Istio Gateway를 통해 Cluster간 통신을 하지만 Istio Control Plance을 공유하지 않고 각각의 Cluster에 설치합니다.</p>

    <p><img src="/assets/images/kubernetes/istio/istio-multiple-multi.svg" alt="" /></p>
  </li>
</ol>

<h2 id="준비하기">준비하기</h2>

<h3 id="kubernetes-cluster-준비">Kubernetes Cluster 준비</h3>

<p>1.12, 1.13, 1.14 버전의 Kubernetes Cluster를 2개 이상 준비합니다.
이 문서에서는 1.12 버전의 2개의 Cluster를 활용하겠습니다.</p>

<p>편의상 2개의 Cluster를 아래와 같이 환경 변수로 설정합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl config get-contexts
CURRENT   NAME       CLUSTER    AUTHINFO       NAMESPACE
*         cluster1   cluster1   user@foo.com   default
          cluster2   cluster2   user@foo.com   default

$ export CTX_CLUSTER1=$(kubectl config view -o jsonpath='{.contexts[0].name}')
$ export CTX_CLUSTER2=$(kubectl config view -o jsonpath='{.contexts[1].name}')
$ echo CTX_CLUSTER1 = ${CTX_CLUSTER1}, CTX_CLUSTER2 = ${CTX_CLUSTER2}
CTX_CLUSTER1 = cluster1, CTX_CLUSTER2 = cluster2
</code></pre></div></div>

<h3 id="istio-다운로드">Istio 다운로드</h3>

<p><a href="https://github.com/istio/istio/releases">Istio Release</a> 페이지에서 원하는 버전을 다운로드합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -L https://git.io/getLatestIstio | ISTIO_VERSION=x.x.x sh -
</code></pre></div></div>

<h3 id="platform-설정">Platform 설정</h3>

<p><a href="https://istio.io/docs/setup/kubernetes/platform-setup/">platform-specific setup</a> 페이지를 참고하여 각 클라우드별로
필요한 설정을합니다.</p>

<h3 id="helm-설치">Helm 설치</h3>

<p><a href="/blog/helm/2018/05/27/installing-helm.html">Helm 설치하기</a> 문서를 참고하여 Helm Client를 설치합니다.</p>

<h2 id="multi-cluster에-service-mesh-구성하기">Multi Cluster에 Service Mesh 구성하기</h2>

<h3 id="primary-cluster-설정">Primary Cluster 설정</h3>

<ol>
  <li>
    <p>Primary Cluster의 Istio deployment yaml 생성합니다.</p>

    <p>위에서 다운로드 받은 Istio 디렉토리로 이동합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ cd istio-x.x.x
</code></pre></div>    </div>

    <p>helm template 기능을 사용하여 istio deployment yaml 파일을 생성합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ helm template --name=istio --namespace=istio-system \
 --set global.mtls.enabled=true \
 --set security.selfSigned=false \
 --set global.controlPlaneSecurityEnabled=true \
 --set global.proxy.accessLogFile="/dev/stdout" \
 --set global.meshExpansion.enabled=true \
 --set 'global.meshNetworks.network1.endpoints[0].fromRegistry'=Kubernetes \
 --set 'global.meshNetworks.network1.gateways[0].address'=0.0.0.0 \
 --set 'global.meshNetworks.network1.gateways[0].port'=443 \
 --set gateways.istio-ingressgateway.env.ISTIO_META_NETWORK="network1" \
 --set global.network="network1" \
 --set 'global.meshNetworks.network2.endpoints[0].fromRegistry'=n2-k8s-config \
 --set 'global.meshNetworks.network2.gateways[0].address'=0.0.0.0 \
 --set 'global.meshNetworks.network2.gateways[0].port'=443 \
 install/kubernetes/helm/istio &gt; istio-auth.yaml
</code></pre></div>    </div>
  </li>
  <li>
    <p>Primary Cluster에 Istio를 설치합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl create --context=$CTX_CLUSTER1 ns istio-system
 $ kubectl create --context=$CTX_CLUSTER1 secret generic cacerts -n istio-system --from-file=samples/certs/ca-cert.pem --from-file=samples/certs/ca-key.pem --from-file=samples/certs/root-cert.pem --from-file=samples/certs/cert-chain.pem
 $ for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply --context=$CTX_CLUSTER1 -f $i; done
 $ kubectl apply --context=$CTX_CLUSTER1 -f istio-auth.yaml
</code></pre></div>    </div>

    <p>아래와 같이 모든 Pod의 Running 상태가 될 때까지 기다립니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl get pods --context=$CTX_CLUSTER1 -n istio-system
 NAME                                      READY   STATUS      RESTARTS   AGE
 istio-citadel-9bbf9b4c8-nnmbt             1/1     Running     0          2m8s
 istio-cleanup-secrets-1.1.0-x9crw         0/1     Completed   0          2m12s
 istio-galley-868c5fff5d-9ph6l             1/1     Running     0          2m9s
 istio-ingressgateway-6c756547b-dwc78      1/1     Running     0          2m8s
 istio-pilot-54fcf8db8-sn9cn               2/2     Running     0          2m8s
 istio-policy-5fcbd55d8b-xhbpz             2/2     Running     2          2m8s
 istio-security-post-install-1.1.0-ww5zz   0/1     Completed   0          2m12s
 istio-sidecar-injector-6dcc9d5c64-7hnnl   1/1     Running     0          2m8s
 istio-telemetry-57875ffb6d-n2vmf          2/2     Running     3          2m8s
 prometheus-66c9f5694-8pccr                1/1     Running     0          2m8s
</code></pre></div>    </div>
  </li>
  <li>
    <p>Ingress Gateway를 생성합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl apply --context=$CTX_CLUSTER1 -f - &lt;&lt;EOF
 apiVersion: networking.istio.io/v1alpha3
 kind: Gateway
 metadata:
 name: cluster-aware-gateway
 namespace: istio-system
 spec:
 selector:
     istio: ingressgateway
 servers:
 - port:
     number: 443
     name: tls
     protocol: TLS
     tls:
     mode: AUTO_PASSTHROUGH
     hosts:
     - "*.local"
 EOF
</code></pre></div>    </div>
  </li>
  <li>
    <p>Primary Cluster의 Ingress IP와 Port를 확인합니다.</p>

    <p>Primary Cluster에서 Ingress Gateway의 Service를 조회합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl config use-context $CTX_CLUSTER1
 $ kubectl get svc istio-ingressgateway -n istio-system
 NAME                   TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)                                      AGE
 istio-ingressgateway   LoadBalancer   172.x.x.1        130.x.x.1       80:31380/TCP,443:31390/TCP,31400:31400/TCP   17h
</code></pre></div>    </div>

    <p>Ingress의 Host 주소와 Secure port를 확인합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ export INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
 $ export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="https")].port}')
 $ echo The ingress gateway of cluster1: address=$INGRESS_HOST, port=$SECURE_INGRESS_PORT
 130.x.x.1, 443
</code></pre></div>    </div>
  </li>
  <li>
    <p>Istio Configmap의 mesh nework 설정에서 gateway 주소를 위에서 조회한 Ingress 정보로 변경합니다.</p>

    <p>data.mesh.meshNetworks.networks.network1.address를 0.0.0.0에서 INGRESS_HOST로 변경합니다.
 data.mesh.meshNetworks.networks.network1.port를 443에서 SECURE_INGRESS_PORT 변경합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl edit cm -n istio-system --context=$CTX_CLUSTER1 istio
 apiVersion: v1
 data:
     mesh:
     ...
         meshNetworks: "networks:\n  network1:\n    endpoints:\n    - fromRegistry: Kubernetes\n
     \   gateways:\n    - address: 0.0.0.0\n      port: 443\n  ...
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="second-cluster-설정">Second Cluster 설정</h3>

<ol>
  <li>
    <p>Primary Cluster의 Ingress Gateway 주소를 확인합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ export LOCAL_GW_ADDR=$(kubectl get --context=$CTX_CLUSTER1 svc --selector=app=istio-ingressgateway \
 -n istio-system -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}') &amp;&amp; echo ${LOCAL_GW_ADDR}
</code></pre></div>    </div>
  </li>
  <li>
    <p>Second Cluster의 Istio deployment yaml 생성합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ helm template --name istio-remote --namespace=istio-system \
 --values install/kubernetes/helm/istio/values-istio-remote.yaml \
 --set global.mtls.enabled=true \
 --set gateways.enabled=true \
 --set security.selfSigned=false \
 --set global.controlPlaneSecurityEnabled=true \
 --set global.createRemoteSvcEndpoints=true \
 --set global.remotePilotCreateSvcEndpoint=true \
 --set global.remotePilotAddress=${LOCAL_GW_ADDR} \
 --set global.remotePolicyAddress=${LOCAL_GW_ADDR} \
 --set global.remoteTelemetryAddress=${LOCAL_GW_ADDR} \
 --set gateways.istio-ingressgateway.env.ISTIO_META_NETWORK="network2" \
 --set global.network="network2" \
 install/kubernetes/helm/istio &gt; istio-remote-auth.yaml
</code></pre></div>    </div>
  </li>
  <li>
    <p>Second Cluster에 Istio를 설치합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl create --context=$CTX_CLUSTER2 ns istio-system
 $ kubectl create --context=$CTX_CLUSTER2 secret generic cacerts -n istio-system --from-file=samples/certs/ca-cert.pem --from-file=samples/certs/ca-key.pem --from-file=samples/certs/root-cert.pem --from-file=samples/certs/cert-chain.pem
 $ kubectl apply --context=$CTX_CLUSTER2 -f istio-remote-auth.yaml
</code></pre></div>    </div>

    <p>Istio의 모든 Pod가 Running 상태가 될때까지 기다립니다. 
 Primary Cluster와 다르게 일부 컴포넌트만 설치됩니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl get pods --context=$CTX_CLUSTER2 -n istio-system -l istio!=ingressgateway
 NAME                                     READY   STATUS      RESTARTS   AGE
 istio-citadel-75c8fcbfcf-9njn6           1/1     Running     0          12s
 istio-cleanup-secrets-1.1.0-vtp62        0/1     Completed   0          14s
 istio-sidecar-injector-cdb5d4dd5-rhks9   1/1     Running     0          12s
</code></pre></div>    </div>
  </li>
  <li>
    <p>Second Cluster의 Ingress IP와 Port를 확인합니다.</p>

    <p>Second Cluster에서 Ingress Gateway의 Service를 조회합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl config use-context $CTX_CLUSTER2
 $ kubectl get svc istio-ingressgateway -n istio-system
 NAME                   TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)                                      AGE
 istio-ingressgateway   LoadBalancer   172.x.x.2        130.x.x.2       80:31380/TCP,443:31390/TCP,31400:31400/TCP   17h
</code></pre></div>    </div>

    <p>Ingress의 Host 주소와 Secure port를 확인합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ export INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
 $ export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="https")].port}')
 $ echo The ingress gateway of cluster2: address=$INGRESS_HOST, port=$SECURE_INGRESS_PORT
 130.x.x.2, 443
</code></pre></div>    </div>
  </li>
  <li>
    <p>Istio Configmap의 mesh nework 설정에서 gateway 주소를 위에서 조회한 Ingress 정보로 변경합니다.</p>

    <p>data.mesh.meshNetworks.networks.network2.address를 0.0.0.0에서 INGRESS_HOST로 변경합니다.
 data.mesh.meshNetworks.networks.network2.port를 443에서 SECURE_INGRESS_PORT 변경합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl edit cm -n istio-system --context=$CTX_CLUSTER2 istio
 apiVersion: v1
 data:
     mesh:
     ...
     meshNetworks: "networks:\n  network1:\n    endpoints:\n    - fromRegistry: Kubernetes\n
         \   gateways:\n    - address: 0.0.0.0\n      port: 443\n  network2:\n    endpoints:\n
         \   - fromRegistry: n2-k8s-config\n    gateways:\n    - address: 0.0.0.0\n
         \     port: 443\n  "
</code></pre></div>    </div>
  </li>
  <li>
    <p>n2-k8s-config 설정 파일을 생성하기 위한 환경 변수를 설정합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ CLUSTER_NAME=$(kubectl --context=$CTX_CLUSTER2 config view --minify=true -o jsonpath='{.clusters[].name}')
 $ SERVER=$(kubectl --context=$CTX_CLUSTER2 config view --minify=true -o jsonpath='{.clusters[].cluster.server}')
 $ SECRET_NAME=$(kubectl --context=$CTX_CLUSTER2 get sa istio-multi -n istio-system -o jsonpath='{.secrets[].name}')
 $ CA_DATA=$(kubectl get --context=$CTX_CLUSTER2 secret ${SECRET_NAME} -n istio-system -o jsonpath="{.data['ca\.crt']}")
 $ TOKEN=$(kubectl get --context=$CTX_CLUSTER2 secret ${SECRET_NAME} -n istio-system -o jsonpath="{.data['token']}" | base64 --decode)
</code></pre></div>    </div>
  </li>
  <li>
    <p>n2-k8s-config 파일을 생성합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ cat &lt;&lt;EOF &gt; n2-k8s-config
 apiVersion: v1
 kind: Config
 clusters:
 - cluster:
     certificate-authority-data: ${CA_DATA}
     server: ${SERVER}
     name: ${CLUSTER_NAME}
 contexts:
 - context:
     cluster: ${CLUSTER_NAME}
     user: ${CLUSTER_NAME}
     name: ${CLUSTER_NAME}
 current-context: ${CLUSTER_NAME}
 users:
 - name: ${CLUSTER_NAME}
     user:
     token: ${TOKEN}
 EOF
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="primary-cluster와-second-cluster-동기화">Primary Cluster와 Second Cluster 동기화</h3>

<ol>
  <li>
    <p>Primary Cluster에서 Second Cluster를 동기화합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl create --context=$CTX_CLUSTER1 secret generic n2-k8s-secret --from-file n2-k8s-config -n istio-system
 $ kubectl label --context=$CTX_CLUSTER1 secret n2-k8s-secret istio/multiCluster=true -n istio-system
</code></pre></div>    </div>
  </li>
  <li>
    <p>Second Cluster의 Ingress Gateway가 Running 상태가 될때까지 기다립니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl get pods --context=$CTX_CLUSTER2 -n istio-system -l istio=ingressgateway
 NAME                                    READY     STATUS    RESTARTS   AGE
 istio-ingressgateway-5c667f4f84-bscff   1/1       Running   0          16m
</code></pre></div>    </div>
  </li>
</ol>

<p>이제 Primary Cluster와 Seconde Cluster가 Service Mesh로 구성되었습니다.</p>

<p>다음으로 샘플 서비스를 배포하여 2개의 Cluster에서 Service Mesh가 어떻게 동작하는지 확인해보겠습니다.</p>

<h2 id="샘플-서비스-배포하기">샘플 서비스 배포하기</h2>

<p>Overview의 구성도와 같이 helloworld 애플리케이션을 Primary와 Second 클러스터에 각각 배포할것입니다.</p>

<p>각각의 인스턴스는 동일한 애플리케이션이지만 이미지의 버전이 v1, v2로 다릅니다.</p>

<h3 id="second-cluster에-helloworld-v2-버전-배포">Second Cluster에 helloworld v2 버전 배포</h3>

<ol>
  <li>
    <p>sample namespace를 생성하고 istio proxy가 자동으로 injection 되도록 설정합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl create --context=$CTX_CLUSTER2 ns sample
 $ kubectl label --context=$CTX_CLUSTER2 namespace sample istio-injection=enabled
</code></pre></div>    </div>
  </li>
  <li>
    <p>helloworld v2를 배포합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl create --context=$CTX_CLUSTER2 -f samples/helloworld/helloworld.yaml -l app=helloworld -n sample
 $ kubectl create --context=$CTX_CLUSTER2 -f samples/helloworld/helloworld.yaml -l version=v2 -n sample
</code></pre></div>    </div>
  </li>
  <li>
    <p>helloworld v2가 Running 상태가 될때까지 기다립니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl get po --context=$CTX_CLUSTER2 -n sample
 NAME                             READY     STATUS    RESTARTS   AGE
 helloworld-v2-7dd57c44c4-f56gq   2/2       Running   0          35s
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="primary-cluster에-helloworld-v1-버전-배포">Primary Cluster에 helloworld v1 버전 배포</h3>

<ol>
  <li>
    <p>sample namespace를 생성하고 istio proxy가 자동으로 injection 되도록 설정합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl create --context=$CTX_CLUSTER1 ns sample
 $ kubectl label --context=$CTX_CLUSTER1 namespace sample istio-injection=enabled
</code></pre></div>    </div>
  </li>
  <li>
    <p>helloworld v1을 배포합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl create --context=$CTX_CLUSTER1 -f samples/helloworld/helloworld.yaml -l app=helloworld -n sample
 $ kubectl create --context=$CTX_CLUSTER1 -f samples/helloworld/helloworld.yaml -l version=v1 -n sample
</code></pre></div>    </div>
  </li>
  <li>
    <p>helloworld v1이 Running 상태가 될때까지 기다립니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl get po --context=$CTX_CLUSTER1 -n sample
 NAME                            READY     STATUS    RESTARTS   AGE
 helloworld-v1-d4557d97b-pv2hr   2/2       Running   0          40s
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="cluster간-트래픽-흐름-확인">Cluster간 트래픽 흐름 확인</h3>

<p>2개의 Cluster에서 트래픽을 확인하기 위해 sleep 애플리케이션에서 helloworld 애플리케이션을 호출해보겠습니다.</p>

<ol>
  <li>
    <p>sleep 애플리케이션을 2개의 Cluster에 배포하고 Running 상태가 될때까지 기다립니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl apply --context=$CTX_CLUSTER1 -f samples/sleep/sleep.yaml -n sample
 $ kubectl apply --context=$CTX_CLUSTER2 -f samples/sleep/sleep.yaml -n sample
</code></pre></div>    </div>
  </li>
  <li>
    <p>Primary Cluster에서 helloworld를 여러번 호출합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl exec --context=$CTX_CLUSTER1 -it -n sample -c sleep $(kubectl get pod --context=$CTX_CLUSTER1 -n sample -l app=sleep -o jsonpath='{.items[0].metadata.name}') -- curl helloworld.sample:5000/hello
</code></pre></div>    </div>

    <p>각 클러스터의 v1, v2 버전이 번갈아가면서 호출되는 것을 확인할 수 있습니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Hello version: v2, instance: helloworld-v2-758dd55874-6x4t8
 Hello version: v1, instance: helloworld-v1-86f77cd7bd-cpxhv
</code></pre></div>    </div>

    <p>Primary Cluster의 sleep pod의 istio-proxy 컨테이너의 로그를 조회해봅니다.
 한번은 Second Cluster의 Gateway를 통하여 Second Cluster에 있는 helloworld v2가 호출되었고
 다른 한번은 같은 Cluster의 helloworld v1이 호출되었습니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ kubectl logs --context=$CTX_CLUSTER1 -n sample $(kubectl get pod --context=$CTX_CLUSTER1 -n sample -l app=sleep -o jsonpath='{.items[0].metadata.name}') istio-proxy
 [2018-11-25T12:37:52.077Z] "GET /hello HTTP/1.1" 200 - 0 60 190 189 "-" "curl/7.60.0" "6e096efe-f550-4dfa-8c8c-ba164baf4679" "helloworld.sample:5000" "130.x.x.2:15443" outbound|5000||helloworld.sample.svc.cluster.local - 10.20.194.146:5000 10.10.0.89:59496 -
 [2018-11-25T12:38:06.745Z] "GET /hello HTTP/1.1" 200 - 0 60 171 170 "-" "curl/7.60.0" "6f93c9cc-d32a-4878-b56a-086a740045d2" "helloworld.sample:5000" "10.10.0.90:5000" outbound|5000||helloworld.sample.svc.cluster.local - 10.20.194.146:5000 10.10.0.89:59646 -
</code></pre></div>    </div>
  </li>
</ol>

<p>지금까지 살펴본 내용을 보면 Istio의 Service Mesh 구성을 통해 서로 다른 네트워크에 구성한 Cluster에서 실행중인 서비스간의 통신이
가능하다는 것을 확인할 수 있었습니다.</p>

  </div>
<div id="disqus_thread"></div>
<script>
  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
  /*
  var disqus_config = function () {
  this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  };
  */
  (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://sj-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="u-url" href="/istio/2019/08/11/istio-multi-cluster-mesh.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <!--h2 class="footer-heading">개발 노트</h2-->

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Yun SangJun</li><li><a class="u-email" href="mailto:ysj188cm@gmail.com">ysj188cm@gmail.com</a></li>
            <li>subscribe <a href="/feed.xml">via RSS</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/yunsangjun"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">yunsangjun</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>iOS를 시작으로 개발자의 길로 들어서 모바일 프레임워크와 애플리케이션을 개발했고 이후, 웹 개발자로 커리어를 전환해 웹 프레임워크, IDE를 개발했습니다. 최근에는 Kubernetes 및 Cloud 환경에서 애플리케션을 개발하고 빌드, 배포, 모니터링하는 운영 단계를 자동화하는 DevOps 엔지니어링을 하고 있습니다.</p>
      </div>

    </div>

  </div>

</footer>
</body>

</html>
