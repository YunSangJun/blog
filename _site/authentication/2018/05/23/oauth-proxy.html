<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/blog/assets/css/home.css">
  <link rel="stylesheet" href="/blog/assets/css/category.css">
  <link rel="stylesheet" href="/blog/assets/css/tag.css">
  <link rel="stylesheet" href="/blog/assets/main.css"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>OAuth Proxy를 활용한 애플리케이션 인증 및 인가 | 개발 노트</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="OAuth Proxy를 활용한 애플리케이션 인증 및 인가" />
<meta name="author" content="sj" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="OIDC(OpenID Connect identity providers)와 연계하여 애플리케이션의 인증을 해야하는 경우가 있습니다. 자체 개발한 애플리케이션의 경우 OIDC와 연동하기 위한 인증 기능을 개발하면 됩니다. 하지만 오픈소스를 사용하는 경우 해당 오픈소스에서 OIDC와의 연동기능을 제공하지 않으면 오픈소스의 코드를 수정해야합니다(예 : Kibana). 하지만 오픈소스의 코드를 수정하면 업스트림과의 일관성을 유지해야하는 부분이 부담스러울수 있습니다. 이 경우 Keycloak Proxy와 같은 OAuth Proxy를 사용하여 애플리케이션의 인증/인가를 처리할 수 있습니다." />
<meta property="og:description" content="OIDC(OpenID Connect identity providers)와 연계하여 애플리케이션의 인증을 해야하는 경우가 있습니다. 자체 개발한 애플리케이션의 경우 OIDC와 연동하기 위한 인증 기능을 개발하면 됩니다. 하지만 오픈소스를 사용하는 경우 해당 오픈소스에서 OIDC와의 연동기능을 제공하지 않으면 오픈소스의 코드를 수정해야합니다(예 : Kibana). 하지만 오픈소스의 코드를 수정하면 업스트림과의 일관성을 유지해야하는 부분이 부담스러울수 있습니다. 이 경우 Keycloak Proxy와 같은 OAuth Proxy를 사용하여 애플리케이션의 인증/인가를 처리할 수 있습니다." />
<link rel="canonical" href="http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy.html" />
<meta property="og:url" content="http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy.html" />
<meta property="og:site_name" content="개발 노트" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-23T00:00:00+09:00" />
<script type="application/ld+json">
{"description":"OIDC(OpenID Connect identity providers)와 연계하여 애플리케이션의 인증을 해야하는 경우가 있습니다. 자체 개발한 애플리케이션의 경우 OIDC와 연동하기 위한 인증 기능을 개발하면 됩니다. 하지만 오픈소스를 사용하는 경우 해당 오픈소스에서 OIDC와의 연동기능을 제공하지 않으면 오픈소스의 코드를 수정해야합니다(예 : Kibana). 하지만 오픈소스의 코드를 수정하면 업스트림과의 일관성을 유지해야하는 부분이 부담스러울수 있습니다. 이 경우 Keycloak Proxy와 같은 OAuth Proxy를 사용하여 애플리케이션의 인증/인가를 처리할 수 있습니다.","author":{"@type":"Person","name":"sj"},"@type":"BlogPosting","url":"http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy.html","headline":"OAuth Proxy를 활용한 애플리케이션 인증 및 인가","dateModified":"2018-05-23T00:00:00+09:00","datePublished":"2018-05-23T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/authentication/2018/05/23/oauth-proxy.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <meta property="article:tag" content="oauth" >
  
  <meta property="article:tag" content="proxy" >
  
  <meta property="article:tag" content="authentication" >
  
  <meta property="article:tag" content="authorization" >
  
  <meta property="article:tag" content="keycloak" >
  
  <meta property="article:tag" content="oidc" >
  
  <meta property="article:tag" content="helm" >
  
  <meta property="article:tag" content="chart" >
  
  <meta property="article:tag" content="kubernetes" >
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="개발 노트" /><meta name="naver-site-verification" content="33e13a38620284ab48998da35e7c8e63ec9c7319"/>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">개발 노트</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/blog/categories">Categories</a>
            <a class="page-link" href="/blog/tags">Tags</a>
        </div>

        <!--div class="trigger"><a class="page-link" href="/blog/assets/images/oauth-proxy/2018-05-23-oauth-proxy.html">OAuth Proxy를 활용한 애플리케이션 인증 및 인가</a><a class="page-link" href="/blog/categories/">Categories</a><a class="page-link" href="/blog/tags/">Tags</a></div-->
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">OAuth Proxy를 활용한 애플리케이션 인증 및 인가</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-05-23T00:00:00+09:00" itemprop="datePublished">May 23, 2018
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">sj</span></span></p>
      
<img src="/blog/assets/images/tag-256.png" alt="Tags: " class="tag-img"/>
<div class="post-tags">
  
  
  <a href="/blog/tags/#oauth">oauth</a>,
  
  <a href="/blog/tags/#proxy">proxy</a>,
  
  <a href="/blog/tags/#authentication">authentication</a>,
  
  <a href="/blog/tags/#authorization">authorization</a>,
  
  <a href="/blog/tags/#keycloak">keycloak</a>,
  
  <a href="/blog/tags/#oidc">oidc</a>,
  
  <a href="/blog/tags/#helm">helm</a>,
  
  <a href="/blog/tags/#chart">chart</a>,
  
  <a href="/blog/tags/#kubernetes">kubernetes</a>
  
</div>
<br/>

  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>OIDC(OpenID Connect identity providers)와 연계하여 애플리케이션의 인증을 해야하는 경우가 있습니다. 자체 개발한 애플리케이션의 경우 OIDC와 연동하기 위한 인증 기능을 개발하면 됩니다. 하지만 오픈소스를 사용하는 경우 해당 오픈소스에서 OIDC와의 연동기능을 제공하지 않으면 오픈소스의 코드를 수정해야합니다(예 : Kibana). 하지만 오픈소스의 코드를 수정하면 업스트림과의 일관성을 유지해야하는 부분이 부담스러울수 있습니다. 이 경우 <a href="https://github.com/kubernetes/charts/tree/master/incubator/keycloak-proxy">Keycloak Proxy</a>와 같은 OAuth Proxy를 사용하여 애플리케이션의 인증/인가를 처리할 수 있습니다.</p>

<p>이 페이지에서는 Keycloak Proxy를 활용하여 애플리케이션의 인증을 처리하는 방법에 대해 설명합니다.
아래의 “데모 애플리케이션”과 “Keycloak Proxy” 배포 따라하기를 통해 Keycloak Proxy를 활용한 인증방법을 쉽게 이해할 수 있습니다.</p>

<h2 id="사전-준비">사전 준비</h2>

<h3 id="kubernetes-cluster-준비">Kubernetes Cluster 준비</h3>

<p>이 데모 애플리케이션과 Keycloak Proxy는 Kubernetes 환경을 위해 만들어졌습니다.</p>

<p>퍼블릭 클라우드에서 제공하는 Kubernetes(GKE, IKS, AKS, EKS 등)나 Private Kubernetes, Minikube 등의 환경을 준비합니다.</p>

<h3 id="keycloakopenid-connect-provider-환경-준비">Keycloak(OpenID Connect Provider) 환경 준비</h3>

<p>Keycloak Proxy는 OIDC인 Keycloak과의 연동을 위해 디자인 되었지만 다른 OIDC 와도 연동할 수 있습니다.</p>

<p><a href="https://github.com/kubernetes/charts/tree/master/incubator/keycloak">Keycloak Helm Chart</a>를 활용하여 Keycloak을 쉽게 설치할 수 있습니다.</p>

<p>또는 이미 설치되어 있는 Keycloak이나 다른 OIDC(OpenID Connect identity providers)를 사용할 수 있습니다.</p>

<h3 id="realm-client-role-생성">Realm, Client, Role 생성</h3>

<p>Keycloak Proxy와 Keycloak을 연동하기 위해서는 Keycloak 관리자 대시보드에서 Realm, Client, Role을 미리 생성해야합니다.</p>

<p><a href="https://github.com/YunSangJun/keycloak-proxy-demo/blob/master/keycloak-guide.md">Keycloak 가이드</a>를 참고하여 Realm, Client, Role을 생성합니다.</p>

<h2 id="데모-애플리케이션-배포하기">데모 애플리케이션 배포하기</h2>

<h3 id="구조">구조</h3>

<p>전제 조건 : 이 데모 애플리케이션에서는 Keycloak Proxy가 <code class="highlighter-rouge">/admin</code> endpoint에 대해서만 권한을 체크하도록 설정했습니다.</p>

<ul>
  <li>
    <p>Keycloak Proxy는 <code class="highlighter-rouge">/user</code> endpoint에 대한 클라이언트 요청을 허용합니다.</p>

    <p><img src="/blog/assets/images/oauth-proxy/keycloak_proxy_flow_user_allow.png" alt="Keycloak Proxy Flow Allow" /></p>
  </li>
  <li>
    <p>Keycloak Proxy는 클라이언트가 admin 권한을 가지고 있지 않다면 <code class="highlighter-rouge">/admin</code> endpoint에 대한 클라이언트 요청을 거부합니다.</p>

    <p><img src="/blog/assets/images/oauth-proxy/keycloak_proxy_flow_admin_deny.png" alt="Keycloak Proxy Flow Deny" /></p>
  </li>
  <li>
    <p>Keycloak Proxy는 클라이언트가 admin 권한을 가지고 있다면 <code class="highlighter-rouge">/admin</code> endpoint에 대한 클라이언트 요청을 허용합니다.</p>

    <p><img src="/blog/assets/images/oauth-proxy/keycloak_proxy_flow_admin_allow.png" alt="Keycloak Proxy Flow Deny" /></p>
  </li>
</ul>

<h3 id="다운로드">다운로드</h3>

<p>아래 github 저장소에서 데모 애플리케이션을 다운로드합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git clone https://github.com/YunSangJun/keycloak-proxy-demo
$ cd keycloak-proxy-demo
</code></pre></div></div>

<h3 id="배포">배포</h3>

<p>아래 명령을 실행하여 애플리케이션과 서비스를 배포합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl apply -f deployment.yaml
$ kubectl apply -f service.yaml
</code></pre></div></div>

<h3 id="배포-확인">배포 확인</h3>

<p>아래 명령을 실행하여 정상적으로 배포되었는지 확인합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl get po,svc
NAME                       READY     STATUS    RESTARTS   AGE
po/demo-85cdbcc8c7-6pkbv   1/1       Running   0          10s

NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
svc/demo-service   ClusterIP   172.21.189.11   &lt;none&gt;        80/TCP    10s
</code></pre></div></div>

<h3 id="접속-확인">접속 확인</h3>

<p>데모 애플리케이션에 접속 할 수 있도록 <code class="highlighter-rouge">port-forward</code> 설정을 합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl port-forward demo-85cdbcc8c7-6pkbv 8080:8080
Forwarding from 127.0.0.1:8080 -&gt; 8080
</code></pre></div></div>

<p>이제 <code class="highlighter-rouge">http://127.0.0.1:8080/user</code>와 <code class="highlighter-rouge">http://127.0.0.1:8080/admin</code>엡 접속해봅니다.
“Hello User!”와 “Hello Admin!” 메세지를 볼 수 있습니다.
현재는 <code class="highlighter-rouge">/user</code>와 <code class="highlighter-rouge">/admin</code> endpoint에 별도의 인증없이 접속 할 수 있습니다.</p>

<p>다음 과정에서는 Keycloak Proxy를 배포하고 이를 Keycloak과 연계하여 admin 권한을 가진 사용자만 <code class="highlighter-rouge">/admin</code> endpoint에 접속할 수 있도록 설정해보겠습니다.</p>

<h2 id="keycloak-proxy-배포하기">Keycloak Proxy 배포하기</h2>

<p>아래 가이드를 참고하여 Keycloak Proxy를 배포해보겠습니다.</p>

<p>Keycloak Proxy에 대한 자세한 설명은 <a href="https://github.com/kubernetes/charts/tree/master/incubator/keycloak-proxy">Keycloak Proxy Helm Chart</a>를 참고하세요.</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">values.yaml</code> 작성하기</p>

    <p>아래와 같이 <code class="highlighter-rouge">values.yaml</code>을 작성합니다.</p>

    <p>참고: 사전 준비에서 Keycloak 관리자 대시보드에서 Realm, Client, Role을 생성했습니다. 이 정보를 아래 <code class="highlighter-rouge">configmap</code> 속성에 작성해야합니다.
 이 페이지에서는 <code class="highlighter-rouge">NodePort</code>를 사용해 서비스를 외부에 노출시켰습니다. <code class="highlighter-rouge">LoadBalancer</code>나 <code class="highlighter-rouge">Ingress</code>를 사용할 수도 있습니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> service:
   type: NodePort
   nodePort: 32589
   port: 80

 configmap:
   targetUrl: http://demo-service
   realm: demo
   realmPublicKey: "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsLa2YmPyakziINoUgRLrEHLCKcyz62LhLU4JQsbJXMa1Zj4u/bU5D4dau1WkF94ivKV1osvqJqtQ4jCJYfRYrhCYeYOZWB7YFxELj+zMyP72Gxqg/YfWXKrzVnI5MYdZNx52dWAvBVDsDrxiZzJ0Xc92qCdKnEbvpK50XCh15KjWSjucbcJPwGX6kclLCmX0V47ziSo83FjH3ddFP81Kmza3on569Xi0QAAx3g/ZgPgZOSuF9OWwh3aMTwkfx9DlGeU5pY7uqvjuM9v33g0tdpOEelRAqu0aH/HEFXk9Mn74U1GQU/drflQVWEbv+9YvnUJN4cGt0oqmwQYU+Ix4qwIDAQAB"
   authServerUrl: http://url-to-keycloak.example.com/auth
   resource: demo
   secret: 2b2c17f0-245e-4978-a663-9a02a268a8f4
   pattern: /admin
   rolesAllowed: admin
</code></pre></div>    </div>
  </li>
  <li>
    <p>Keycloak Proxy 배포하기</p>

    <p>아래 명령을 실행하여 Keycloak Proxy를 배포합니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ helm install --name keycloak-proxy -f values.yaml incubator/keycloak-proxy
 NAME:   keycloak-proxy
 LAST DEPLOYED: Wed May 16 01:17:25 2018
 STATUS: DEPLOYED

 RESOURCES:
 ==&gt; v1beta1/Deployment
 NAME            DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
 keycloak-proxy  1        1        1           0          0s

 ==&gt; v1/Pod(related)
 NAME                             READY  STATUS             RESTARTS  AGE
 keycloak-proxy-67df99bbd5-ckfx7  0/1    ContainerCreating  0         0s

 ==&gt; v1/ConfigMap
 NAME                      DATA  AGE
 keycloak-proxy-configmap  1     0s

 ==&gt; v1/Service
 NAME                    TYPE      CLUSTER-IP     EXTERNAL-IP  PORT(S)       AGE
 keycloak-proxy-service  NodePort  172.21.215.70  &lt;none&gt;       80:32589/TCP  0s


 NOTES:
 1. Keycloak Proxy can be accessed:

    * Within your cluster, at the following DNS name at port 80:

      keycloak-proxy.demo.svc.cluster.local

    * From outside the cluster, run these commands in the same shell:

      export NODE_PORT=$(kubectl get --namespace demo -o jsonpath="{.spec.ports[0].nodePort}" services keycloak-proxy-service)
      export NODE_IP=$(kubectl get nodes --namespace demo -o jsonpath="{.items[0].status.addresses[0].address}")
      echo http://$NODE_IP:$NODE_PORT
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="무엇이-일어났는지-확인하기">무엇이 일어났는지 확인하기</h2>

<p>이제 Keycloak Proxy에 접속하여 admin 권한을 가진 사용자만 <code class="highlighter-rouge">/admin</code> endpoint에 접속할 수 있는지 확인해보겠습니다.</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">http://$NODE_IP:$NODE_PORT/user</code> 접속</p>

    <p>먼저 <code class="highlighter-rouge">/user</code> endpoint에 접속해봅니다. 이전과 마찬가지로 인증없이 접근이 가능합니다.
 Keycloak Proxy 배포 시 <code class="highlighter-rouge">pattern</code> 설정에 <code class="highlighter-rouge">/admin</code> 패턴만 설정했기 때문에 <code class="highlighter-rouge">/user</code> endpoint는 bypass 합니다.</p>

    <p><img src="/blog/assets/images/oauth-proxy/page_user.png" alt="Authentication and Authorization" /></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">http://$NODE_IP:$NODE_PORT/admin</code> 접속</p>

    <p><code class="highlighter-rouge">admin</code> endpoint에 접속해봅니다. Keycloak Proxy는 클라이언트를 Keycloak 로그인 페이지로 redirect 시킵니다.
 Keycloak Proxy 배포 시 <code class="highlighter-rouge">pattern</code> 설정에 <code class="highlighter-rouge">/admin</code> 패턴을 체크하도록 설정했기 때문입니다.</p>

    <p><img src="/blog/assets/images/oauth-proxy/login1.png" alt="Authentication and Authorization" /></p>

    <p>Keycloak 계정이 없다면 “Register” 버튼을 클릭하여 계정을 생성합니다.
 <img src="/blog/assets/images/oauth-proxy/add_user.png" alt="Authentication and Authorization" /></p>

    <p>Keycloak 계정으로 로그인합니다.
 <img src="/blog/assets/images/oauth-proxy/login2.png" alt="Authentication and Authorization" /></p>

    <p>이제 로그인에 성공했다면 제어권이 다시 Keycloak Proxy로 넘어갑니다.
 만약 로그인한 계정이 admin 권한을 가지고 있지 않다면 “HTTP 403” 에러가 발생 할 수 있습니다.
 <img src="/blog/assets/images/oauth-proxy/page_admin_error.png" alt="Authentication and Authorization" /></p>

    <p>Keycloak 관리자 대시보드에 접속한 후 User 관리메뉴를 클릭합니다.
 로그인한 사용자 계정을 선택한 후 admin 권한을 사용자에게 부여합니다.
 <img src="/blog/assets/images/oauth-proxy/role_mapping.png" alt="Authentication and Authorization" /></p>

    <p>이제 다시 접속해보면 아래와 같이 <code class="highlighter-rouge">/admin</code> endpoint에 정상적으로 접근할 수 있습니다.
 <img src="/blog/assets/images/oauth-proxy/page_admin_success.png" alt="Authentication and Authorization" /></p>
  </li>
</ol>

  </div>
<div id="disqus_thread"></div>
<script>
  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
  /*
  var disqus_config = function () {
  this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  };
  */
  (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://sj-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="u-url" href="/blog/authentication/2018/05/23/oauth-proxy.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <!--h2 class="footer-heading">개발 노트</h2-->

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Yun SangJun</li><li><a class="u-email" href="mailto:ysj188cm@gmail.com">ysj188cm@gmail.com</a></li>
            <li>subscribe <a href="/blog/feed.xml">via RSS</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/yunsangjun"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">yunsangjun</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>iOS를 시작으로 개발자의 길로 들어서 모바일 프레임워크와 애플리케이션을 개발했고 이후, 웹 개발자로 커리어를 전환해 웹 프레임워크, IDE를 개발했습니다. 최근에는 Kubernetes 및 Cloud 환경에서 애플리케션을 개발하고 빌드, 배포, 모니터링하는 운영 단계를 자동화하는 DevOps 엔지니어링을 하고 있습니다.</p>
      </div>

    </div>

  </div>

</footer>
</body>

</html>
